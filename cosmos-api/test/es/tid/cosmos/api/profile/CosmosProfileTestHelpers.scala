/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

package es.tid.cosmos.api.profile

import es.tid.cosmos.api.profile.dao.ProfileDataStore

/** Utilities for setting up users on integration tests. */
object CosmosProfileTestHelpers {

  /** Generates a registration object given a handle.
    * The rest of the fields are generated by plugin in the handle into dummy
    * domains or keys.
    *
    * @param handle  Handle for the registration
    * @return        A complete registration object
    */
  def registrationFor(handle: String): Registration = {
    val email = s"$handle@example.com"
    Registration(
      handle = handle,
      publicKey = s"ssh-rsa AAAAAA $email",
      email = email
    )
  }

  /** Generates a user id based on a keyword.
    *
    * @param keyword To fill in the auth id
    * @return        A user id on the default realm
    */
  def userIdFor(keyword: String): UserId = UserId(s"id-$keyword")

  /** Registers a new user by generating dummy data based on the handle.
    * See registrationFor and userIdFor methods for more details.
    *
    * @param handle  Handle to base the dummy info generation on
    * @param store   Where to create the user in
    * @return        The newly created profile
    *
    * @see [[es.tid.cosmos.api.profile.CosmosProfileTestHelpers$#registrationFor]]
    * @see [[es.tid.cosmos.api.profile.CosmosProfileTestHelpers$#userIdFor]]
    */
  def registerUser(handle: String)(implicit store: ProfileDataStore): CosmosProfile =
    store.withTransaction { implicit c =>
      registerUser(store, handle)
    }

  /** Overload of `registerUser` that uses a given transaction/connection.
    *
    * As this is intended for testing isolated from a ServiceManager implementation the user
    * is created directly as an enabled one.
    *
    * Note that `dao` and `c` should be in different argument groups to satisfy type checking.
    *
    * @param store   Where to create the user in
    * @param handle  Handle to base the dummy info generation on
    * @param c       Connection/transaction to do the changes on
    * @return        The newly created profile
    */
  def registerUser(store: ProfileDataStore, handle: String)
                  (implicit c: store.Conn): CosmosProfile = store.profile.register(
    userId = userIdFor(handle),
    reg = registrationFor(handle),
    state = UserState.Enabled
  )

  /** Lookup a user profile by their handle.
    *
    * @param handle  The user's handle
    * @param store   The store to use
    * @return        The profile iff found
    */
  def lookup(handle: String)(implicit store: ProfileDataStore): Option[CosmosProfile] =
    store.withTransaction{ implicit c =>
      lookup(store, handle)
    }

  /** Overload of `lookup` that uses a given transaction/connection
    *
    * @param store   The store to use
    * @param handle  The user's handle
    * @param c       Connection/transaction to do the changes on
    * @return        The profile iff found
    */
  def lookup(store: ProfileDataStore, handle: String)
            (implicit c: store.Conn): Option[CosmosProfile] =
    store.profile.lookupByUserId(userIdFor(handle))
}
