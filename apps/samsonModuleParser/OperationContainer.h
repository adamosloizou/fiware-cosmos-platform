/* ****************************************************************************
 *
 * FILE                     OperationContainer.h
 *
 * DESCRIPTION				Information about an operation  (module definition)
 *
 * ***************************************************************************/

#pragma once

#include <unistd.h>             /* _exit, ...                              */
#include <string.h>             /* strtok, strcpy, ...                     */
#include <cstdio>
#include <map>
#include <string>
#include <iostream>
#include <string>
#include <vector>

#include <samson/KVFormat.h>
#include "DataType.h"



namespace ss
{
	class DataCreator;
	class AUTockenizer;
	
	/** 
	 Container to hold information for an operation
	 */
	
	class OperationContainer
	{
		
	public:
		
		bool setup;
		
		std::string module;		// Name of the module
		std::string name;		// Name of the operation
		
		
		std::string type;
		std::vector <KVFormat> inputs;
		std::vector <KVFormat> outputs;
		
		std::string helpLine;				// Help in one line
		std::vector <std::string> help;		// More extended help
		
		std::string code;		// More extended help
		std::string file;		// File where this operation is defined
		std::vector <std::string> functions; 
		
		bool top;
		bool dynamic_input_formats;
		bool destructor;
		
		OperationContainer( std::string _module , std::string _type, std::string _name  )
		{
			module = _module;
			type = _type;
			name = _name; 
			
			setup = false;
			top =  false;
			dynamic_input_formats = false;
			destructor = false;
		}
		
		void parse( AUTockenizer *module_creator , int begin , int end );
		
		std::string parentClass()
		{
			if( type == "generator")
				return "ss::Generator";
			
			if( type == "map")
				return "ss::Map";
			
			if( type == "reduce")
				return "ss::Reduce";

			if( type == "script")
				return "ss::Script";

			if( type == "parser")
				return "ss::Parser";
			
			if( type == "parserOut")
				return "ss::ParserOut";
			
			fprintf(stderr, "Error: Unknown type of operation in the operation section (%s)\n" , type.c_str());
			_exit(0);
			
		}
		
		void printFile( std::string directory )
		{
			std::ostringstream fileName;
			fileName << directory;	// base directory
			fileName << "operations/";
			mkdir( fileName.str().c_str() , 0755 );
			fileName << name << ".h";

			std::ifstream _file( fileName.str().c_str() );
			if( _file.is_open() )
			{
				_file.close();
				std::cout << "File " << name << ".h is not generated because it already exist\n";
				return;
			}

			std::cout << "Creating file " << name << ".h" << std::endl;
			
			std::ofstream file( fileName.str().c_str() );
			
			file << "\n";
			file << "/**\n";
			file << " File autogenerated with samsonModuleParser. Please, edit to complete this operation\n";
			file << "*/\n";
			file << "\n";
			
			file << "#ifndef _H_SAMSON_" << module << "_" << name << "\n";
			file << "#define _H_SAMSON_" << module << "_" << name << "\n";
			
			file << "\n";
			file << "\n";
			
			file << "#include <samson/samson.h>\n";
			
			file << "\n";
			file << "\n";
			
			// Name space
			file << "namespace ss{\n";
			file << "namespace " << module << "{\n";
			
			file << "\n";
			file << "\n";
			
			// Class definition
			file << "\tclass " << name << " : public " << parentClass() << "\n";
			file << "\t{\n";

			file << "\n";
			
			// Public tag
			file << "\tpublic:\n";
			file << "\n\n";
			
			if( type != "script")
			{
				
				if( (type == "map") || (type == "reduce") )
					file << "\t\tvoid run(  ss::KVSetStruct* inputs , ss::KVWriter *writer )\n\t\t{\n\t\t}\n";
				if( type == "generator" )
					file << "\t\tvoid run( ss::KVWriter *writer )\n\t\t{\n\t\t}\n";
				if( type == "parser" )
					file << "\t\tvoid run( char *data , size_t length , ss::KVWriter *writer )\n\t\t{\n\t\t}\n";
				if( type == "parserOut" )
					file << "\t\tvoid run(KVSetStruct* inputs , TXTWriter *writer )\n\t\t{\n\t\t}\n";

			}
			
			file << "\n\n";
			
			// End of the class
			file <<  "\t};\n";			
			
			
			file << "\n";
			file << "\n";
			
			// End of namspace
			file << "} // end of namespace ss\n";
			file << "} // end of namespace " << module << "\n";
			
			file << "\n";
			
			file << "#endif\n";
			
			
			file.close();			
			
		}
		
		std::string getCompareFunctionForData( std::string data );
		std::string getIncludeForData( std::string data );

		void getIncludes( std::set<std::string>& includes )
		{
			for (size_t i = 0 ; i < inputs.size() ; i++)
			{
				includes.insert( getIncludeForData( inputs[i].keyFormat ) );
				includes.insert( getIncludeForData( inputs[i].valueFormat ) );
			}
		}
		
		
		std::string getCompareFunction()
		{
			std::ostringstream output;
			
			output << "\tint " << getCompareFunctionName() << "(KV* kv1 , KV* kv2)" << std::endl;
			output << "\t{" << std::endl;

			output << "\t\tint res_key = " << getCompareFunctionForData( inputs[0].keyFormat ) << "(kv1->key , kv2->key);\n";
			
			output << "\t\tif(res_key!=0)\n";
			output << "\t\t\treturn (res_key<0);\n";

			output << "\t\tif( kv1->input != kv2->input )\n";
			output << "\t\t\treturn (kv1->input < kv2->input);\n";
			
			output << "\t\tswitch (kv1->input) {\n";
			
			for (size_t i = 0 ; i < inputs.size() ; i++)
				output << "\t\tcase "<<i<<": return ("<< getCompareFunctionForData( inputs[i].valueFormat ) <<"(kv1->value , kv2->value)<0); break;\n";
			
			output << "\t\tdefault: exit(1); break;\n";
			output << "\t\t}\n";
			
			output << "\t\treturn 0;\n";
			
			output << "\t}" << std::endl;
			
			return output.str();
		}
		
		std::string getCompareFunctionName()
		{
			std::ostringstream output;
			output << "compare_" << module << "_" << name;
			return output.str();
		}

		std::string getCompareByKeyFunction()
		{
			std::ostringstream output;
			
			output << "\tint " << getCompareByKeyFunctionName() << "(KV* kv1 , KV* kv2)" << std::endl;
			output << "\t{" << std::endl;
			output << "\t\treturn " << getCompareFunctionForData( inputs[0].keyFormat ) << "(kv1->key , kv2->key);\n";
			output << "\t}" << std::endl;
			
			return output.str();
		}
		
		std::string getCompareByKeyFunctionName()
		{
			std::ostringstream output;
			output << "compare_" << module << "_" << name << "_by_key";
			return output.str();
		}		
		
		
		
	};
}
