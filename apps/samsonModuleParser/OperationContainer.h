/* ****************************************************************************
 *
 * FILE                     OperationContainer.h
 *
 * DESCRIPTION				Information about an operation  (module definition)
 *
 * ***************************************************************************/

#pragma once

#include <unistd.h>             /* _exit, ...                              */
#include <string.h>             /* strtok, strcpy, ...                     */
#include <cstdio>
#include <map>
#include <string>
#include <iostream>
#include <string>
#include <vector>

#include <samson/KVFormat.h>
#include "DataType.h"



namespace ss
{
	class DataCreator;
	class AUTockenizer;
	
	/** 
	 Container to hold information for an operation
	 */
	
	class OperationContainer
	{
		
	public:
		
		bool setup;
		
		std::string module;		// Name of the module
		std::string name;		// Name of the operation
		
		
		std::string type;
		std::vector <KVFormat> inputs;
		std::vector <KVFormat> outputs;
		
		std::string helpLine;				// Help in one line
		std::vector <std::string> help;		// More extended help
		
		std::string code;		// More extended help
		std::string file;		// File where this operation is defined
		std::vector <std::string> functions; 
		
		bool top;
		bool dynamic_input_formats;
		bool destructor;
		
		OperationContainer( std::string _module , std::string _type, std::string _name  )
		{
			module = _module;
			type = _type;
			name = _name; 
			
			setup = false;
			top =  false;
			dynamic_input_formats = false;
			destructor = false;
		}
		
		void parse( AUTockenizer *module_creator , int begin , int end );
		
		std::string parentClass()
		{
			if( type == "generator")
				return "ss::Generator";
			
			if( type == "map")
				return "ss::Map";
			
			if( type == "reduce")
				return "ss::Reduce";

			if( type == "script")
				return "ss::Script";

			if( type == "parser")
				return "ss::Parser";
			
			fprintf(stderr, "Error: Unknown type of operation in the operation section (%s)\n" , type.c_str());
			_exit(0);
			
		}
		
		void printFile( std::string directory )
		{
			std::ostringstream fileName;
			fileName << directory;	// base directory
			fileName << "operations/";
			mkdir( fileName.str().c_str() , 0755 );
			fileName << name << ".h";

			std::ifstream _file( fileName.str().c_str() );
			if( _file.is_open() )
			{
				_file.close();
				std::cout << "File " << name << ".h is not generated because it already exist\n";
				return;
			}

			std::cout << "Creating file " << name << ".h" << std::endl;
			
			std::ofstream file( fileName.str().c_str() );
			
			file << "\n";
			file << "/**\n";
			file << " File autogenerated with samsonModuleParser. Please, edit to complete this operation\n";
			file << "*/\n";
			file << "\n";
			
			file << "#ifndef _H_SAMSON_" << module << "_" << name << "\n";
			file << "#define _H_SAMSON_" << module << "_" << name << "\n";
			
			file << "\n";
			file << "\n";
			
			file << "#include <samson/Operation.h>\n";
			
			file << "\n";
			file << "\n";
			
			// Name space
			file << "namespace ss{\n";
			file << "namespace " << module << "{\n";
			
			file << "\n";
			file << "\n";
			
			// Class definition
			file << "\tclass " << name << " : public " << parentClass() << "\n";
			file << "\t{\n";

			file << "\n";
			
			// Public tag
			file << "\tpublic:\n";
			file << "\n\n";
			
			if( type != "script")
			{
				
				if( (type == "map") || (type == "reduce") )
					file << "\t\tvoid run(  ss::KVSetStruct* inputs , std::vector<ss::KVWriter*>& outputs )\n\t\t{\n\t\t}\n";
				if( type == "generator" )
					file << "\t\tvoid run( ss::KVWriter *writer )\n\t\t{\n\t\t}\n";
				if( type == "parser" )
					file << "\t\tvoid run( char *data , size_t length , ss::KVWriter *writer )\n\t\t{\n\t\t}\n";
			}
			
			file << "\n\n";
			
			// End of the class
			file <<  "\t};\n";			
			
			
			file << "\n";
			file << "\n";
			
			// End of namspace
			file << "} // end of namespace ss\n";
			file << "} // end of namespace " << module << "\n";
			
			file << "\n";
			
			file << "#endif\n";
			
			
			file.close();			
			
		}
		
		
	};
}
