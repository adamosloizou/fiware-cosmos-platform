/* ****************************************************************************
 *
 * FILE                     DataContainer.h
 *
 * DESCRIPTION				Information about a data type (module definition)
 *
 * ***************************************************************************/

#pragma once

#include <unistd.h>             /* _exit, ...                              */
#include <string.h>             /* strtok, strcpy, ...                     */
#include <cstdio>
#include <map>
#include <string>
#include <iostream>
#include <string>
#include <vector>
#include <set>

#include <samson/KVFormat.h>
#include "DataType.h"
#include <sys/stat.h>			// mkdir(.)
#include <fstream>

namespace ss
{
	class DataCreator;
	class AUTockenizer;

	class DataContainer
	{
		
	 public:
	  
		std::string module;					// Module where this data is included ( ejemple sna )
		std::string name;					// Name of the element inside the module (ejemple CDR)
		std::vector <DataType> items;		// Data items it includes

		std::set<std::string> includes;		// List of includes necessary for the system
			
		DataContainer( std::string _module, std::string _name )
		{
			module = _module;
			name = _name; 
		}
		
		void addItem( DataType item )
		{
			items.push_back( item );
			
			includes.insert( item.getInclude() );
			
		}
		
		bool parse( AUTockenizer *module_creator , int begin , int end );
		
		std::string mainClassName()
		{
			return name;
		}
		
		void printBaseFile(std::string directory)
		{
			
			if( items.size() == 0)
			{
				std::cout << "File " << name << "_base.h not created since there are no internal fields.\n";
				return ;
			}

			
			std::cout << "Creating file " << name << "_base.h\n";
			
			// Prepare the files and directories
			std::ostringstream fileName;
			fileName << directory;	// Base directory
			fileName << "samson";
			mkdir( fileName.str().c_str() , 0755 );
			fileName << "/modules";
			mkdir( fileName.str().c_str() , 0755 );
			fileName << "/" << module;
			mkdir( fileName.str().c_str() , 0755 );
			fileName << "/" << name << "_base.h";

			std::ofstream file( fileName.str().c_str() );
			
			file << "\n";
			file << "/**\n";
			file << " File autogenerated with samsonModuleParser, please do not edit\n";
			file << "*/\n";
			file << "\n";

			file << "#ifndef _H_SAMSON_" << module << "_" << name << "_BASE\n";
			file << "#define _H_SAMSON_" << module << "_" << name << "_BASE\n";
			
			file << "\n";
			file << "\n";
			
				
			std::set<std::string>::iterator include;
			for ( include = includes.begin() ; include != includes.end() ; include++)
				file << "#include " << *include << "\n";
			
			file << "\n";
			file << "\n";
			
			file << "namespace ss{\n";
			file << "namespace " << module << "{\n";
			
			file << "\n";
			file << "\n";

			file << "\tclass " << name << "_base : public ss::DataInstance{\n\n";
			
			file << "\tpublic:\n";
			
			//Field definition
			for (vector <DataType>::iterator field =items.begin() ; field != items.end() ; field++)
				file << (*field).getDeclaration("\t");
			file << "\n";
			
			// Constructor
			file << "\t"<<name<<"_base() : ss::DataInstance(){\n";
			for (vector <DataType>::iterator field = items.begin() ; field != items.end() ; field++)
				file << (*field).getInitialization("\t\t");
			file << "\t}\n\n";
			
			//Destructor
			file << "\t~" << name << "_base() {\n";
			for (vector <DataType>::iterator field = items.begin() ; field != items.end() ; field++)
				file << (*field).getDestruction("\t\t");
			file << "\t}\n\n";
			
			//Parse
			file << "\tint parse(char *data){\n" ;
			file << "\t\tint offset=0;\n";
			for (vector <DataType>::iterator field = items.begin() ; field != items.end() ; field++)
				file << (*field).getParseCommand("\t\t");
			file << "\t\treturn offset;\n";
			file << "\t}\n\n";
			
			
			//Serialization
			file << "\tint serialize(char *data){\n";
			file << "\t\tint offset=0;\n";
			for (vector <DataType>::iterator field = items.begin() ; field != items.end() ; field++)
				file << (*field).getSerializeCommand("\t\t");
			file << "\t\treturn offset;\n";
			file << "\t}\n\n";
			
			//Size
			file << "\tstatic inline int size(char *data){\n";
			file << "\t\tint offset=0;\n";
			for (vector <DataType>::iterator field = items.begin() ; field != items.end() ; field++)
				file << (*field).getSizeCommand("\t\t");
			file << "\t\treturn offset;\n";
			file << "\t}\n\n";
			
			//Get partition function
			if( items.size() > 0 ) 
			{
				file << "\tint hash(int max_num_partitions){\n";
				//Only get partition with the fist field
				file << (*items.begin()).getPartitionCommand("\t\t");
				file << "\t}\n\n";
			}
			
			//Comparison
			file << "\tinline static int compare(char * data1 , char *data2 , size_t *offset1 , size_t *offset2 ){\n";
			for (vector <DataType>::iterator field = items.begin() ; field != items.end() ; field++)
				file << (*field).getCompareCommand("\t\t");
			file << "\t\treturn 0; //If everything is equal\n";
			file << "\t}\n\n";
			
			// Global compare function
			file <<"\tinline static int compare( char* data1 , char* data2 )\n";
			file <<"\t{\n";
			file <<"\t\tsize_t offset_1=0;\n";
			file <<"\t\tsize_t offset_2=0;\n";
			file <<"\t\treturn compare( data1 , data2 , &offset_1 , &offset_2 );\n";
			file <<"\t}\n\n";
			
			
			//Vector functions
			for (vector <DataType>::iterator field = items.begin() ; field != items.end() ; field++)
			{
				if( (*field).vector )
				{
					file << (*field).getSetLengthFunction("\t");
					file << (*field).getAddFunction("\t");
				}
			}
			
			//Copy from
			file << "\tvoid copyFrom( "<< name << "_base *other ){\n";
			
			for (vector <DataType>::iterator field = items.begin() ; field != items.end() ; field++)
				file << (*field).getCopyFromCommand("\t\t");
			
			file << "\t};\n";
			
			// str
			file << "\n\tstd::string str(){\n";
			file << "\t\tstd::ostringstream o;\n";
			
			for (vector <DataType>::iterator field = items.begin() ; field != items.end() ; field++)
			{
				file << (*field).getToStringCommand("\t\t") ;
				file << "\t\to<<\" \";\n";
			}
			
			file <<"\t\treturn o.str();\n";
			file <<"\t}\n\n";
			
			
			file << "\t}; //class "<< name << "_base\n\n";	

			// End of namspace
			
			file << "} // end of namespace ss\n";
			file << "} // end of namespace " << module << "\n";

			file << "\n";
			
			file << "#endif\n";

			
			file.close();
			
		}
		
		std::string getIncludeFile()
		{
			std::ostringstream output;
			output << "<samson/modules/" << module << "/" << name << ".h>";
			return output.str();
		}
		
		void printNominalFile(std::string directory)
		{
			// Prepare the files and directories
			
			std::ostringstream fileName;
			fileName << directory;	// Base directory
			fileName << "samson";
			mkdir( fileName.str().c_str() , 0755 );
			fileName << "/modules";
			mkdir( fileName.str().c_str() , 0755 );
			fileName << "/" << module;
			mkdir( fileName.str().c_str() , 0755 );
			fileName << "/" << name << ".h";

			
			std::ifstream _file( fileName.str().c_str() );
			if( _file.is_open() )
			{
				_file.close();
				std::cout << "File " << name << ".h is not generated because it already exist\n";
				return;
			}
			else
				std::cout << "Creating file " << name << ".h\n";

			
			std::ofstream file( fileName.str().c_str() );
	
			file << "\n";
			file << "/**\n";
			file << " File autogenerated with samsonModuleParser. Please, edit to complete this data\n";
			file << "*/\n";
			file << "\n";
			
			file << "#ifndef _H_SAMSON_" << module << "_" << name << "\n";
			file << "#define _H_SAMSON_" << module << "_" << name << "\n";
			
			file << "\n";
			file << "\n";
			
			file << "#include <samson/modules/" << module << "/" << name << "_base.h>\n";
			
			file << "\n";
			file << "\n";

			// Name space
			file << "namespace ss{\n";
			file << "namespace " << module << "{\n";

			file << "\n";
			file << "\n";
			
			file << "\tclass " << name << " : public " << name << "_base\n";
			file << "\t{\n";
			file << "\t};\n";
			
			file << "\n";
			file << "\n";
			
			// End of namspace
			file << "} // end of namespace ss\n";
			file << "} // end of namespace " << module << "\n";
			
			file << "\n";
			
			file << "#endif\n";
			
			
			file.close();			
			
			
		}
		
		
		
		void printFiles( std::string directory)
		{
			// Print the base file
			printBaseFile(directory);
			
			// Print the nominal file ( only if it does not exist )
			printNominalFile(directory);

		}
		
	};

}



