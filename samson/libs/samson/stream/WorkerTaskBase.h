#ifndef _H_SAMSON_QUEUE_TASK_BASE
#define _H_SAMSON_QUEUE_TASK_BASE

#include <set>
#include <set>                       // std::set
#include <sstream>

#include "au/string.h"               // au::Format

#include "samson/common/MessagesOperations.h"
#include "samson/common/samson.pb.h"

#include "engine/ProcessItem.h"      // engine::ProcessItem

#include "samson/stream/Block.h"     // samson::Stream::Block
#include "samson/stream/BlockList.h"  // stream::BlockList
#include "samson/stream/BlockListContainer.h"


namespace samson {
namespace stream {
class Block;

/*
 *
 * WorkerTaskBase
 *
 * Base class for WorkerTask and WorkerSystemTask
 *
 */

class WorkerTaskBase {
public:

  // Constructor and destructor
  WorkerTaskBase(size_t id, const std::string& name , const std::string& operation );
  virtual ~WorkerTaskBase();

  // Add blocks for input
  void add_input(int channel, BlockPointer block, KVRange range, KVInfo info);

  // Add blocks for output ( generated by running the operation )
  void add_output(int channel, BlockPointer block, KVRange range, KVInfo info);

  bool is_ready();  // Funciton to check if all the blocks are in memory
  size_t get_id()const;  // Get the id of this task
  std::string name()const;
  std::string operation()const;

  // set & get over queue_task_state
  void SetTaskState(const std::string& _queue_task_state);
  std::string task_state();

  // Debug string to list last operations executed
  virtual std::string str() = 0;

  // Method to fill records with my information ( tables on delilah )
  virtual void fill(samson::gpb::CollectionRecord *record, const Visualization& visualization) = 0;

  // Methods implemented by ProcessItem in all subclasses
  virtual size_t waiting_time_seconds()=0;
  virtual size_t running_time_seconds()=0;

  std::string str_inputs()
  {
    std::ostringstream output;
    for (int i = 0; i < 3; i++) {
      BlockList *block_list = block_list_container_.getBlockList(au::str("input_%d", i));
      BlockInfo block_info = block_list->getBlockInfo();
      output << block_info.strShortInfo() << " ";
    }
  return output.str();
  }
  std::string str_outputs()
  {
    std::ostringstream output;
    for (int i = 0; i < 3; i++) {
      BlockList *block_list = block_list_container_.getBlockList(au::str("output_%d", i));
      BlockInfo block_info = block_list->getBlockInfo();
      output << block_info.strShortInfo() << " ";
    }
    return output.str();
  }

  
protected:

  // Container for all input/output blocks
  BlockListContainer block_list_container_;

private:

  // Id of the operation
  size_t id_;

  // Name of this type of task
  std::string name_;

  // Name of the operation ( for statistics only )
  std::string operation_;
  
  // State information
  std::string task_state_;

  // Falg to determine if this task is ready ( all blocks in memory )
  bool ready_;
};
}
}

#endif  // ifndef _H_SAMSON_QUEUE_TASK_BASE

