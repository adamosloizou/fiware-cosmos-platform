#include "samson/stream/StreamOperationRangeInfo.h"      // Own interface

#include <string>

#include "samson/common/gpb_operations.h"
#include "samson/common/MessagesOperations.h"
#include "samson/common/SamsonSetup.h"
#include "samson/module/ModulesManager.h"
#include "samson/stream/WorkerTask.h"
#include "samson/worker/SamsonWorker.h"

namespace samson {
namespace stream {
StreamOperationRangeInfo::StreamOperationRangeInfo(SamsonWorker *samson_worker, size_t stream_operation_id,
                                                   const std::string& stream_operation_name, const KVRange& range) {

  // Informaiton for this stream operation info
  stream_operation_id_ = stream_operation_id;
  stream_operation_name_ = stream_operation_name;
  range_ = range;

  // Keep a pointer to samson worker
  samson_worker_ = samson_worker;

  // Default values
  priority_rank_ = 0;
  state_ = "No info";
  worker_task_ = NULL; // No task by default
}

StreamOperationRangeInfo::~StreamOperationRangeInfo() {
}

void StreamOperationRangeInfo::ReviewCurrentTask() {

  // Init pending size and priority to be recomputed
  state_ = au::str("Running task %lu", worker_task_->worker_task_id());
  pending_size_ = 0;
  priority_rank_ = 0;

  if (worker_task_ != NULL) {

    // Process possibly generated output buffers
    worker_task_->processOutputBuffers();

    // If we are running a task, let see if it is finished
    if (worker_task_->finished()) {

      // Process outputs generated by this task
      worker_task_->processOutputBuffers();

      if (worker_task_->error().IsActivated()) {
        ResetWithError(worker_task_->error().GetMessage()); // If there is an error, reset
        return;
      } else {

        // Commit changes and release task
        std::string commit_command = worker_task_->commit_command();
        std::string caller = au::str("task %lu // %s", worker_task_->worker_task_id(), str().c_str());
        au::ErrorManager error;
        samson_worker_->data_model()->Commit(caller, commit_command, &error);
        if (error.IsActivated()) {
          ResetWithError(au::str("Error commiting tasks: %s", error.GetMessage().c_str()));
        }

        // Release our copy of this task
        worker_task_ = NULL;

        state_ = "Reviwing...";

      }
    }
  }
}

size_t StreamOperationRangeInfo::priority_rank() {
  return priority_rank_;
}

au::SharedPointer<WorkerTask> StreamOperationRangeInfo::schedule_new_task(size_t task_id, gpb::Data *data) {

  // Init pending size and priority to be recomputed
  priority_rank_ = 0;
  pending_size_ = 0;

  // Recover stream operation from data
  gpb::StreamOperation *stream_operation = gpb::getStreamOperation(data, stream_operation_id_);
  if (!stream_operation) {
    ResetWithError("Stream operation not found");
    return au::SharedPointer<WorkerTask>(NULL);
  }
  // Reset error in timeout 60
  if ((error_.IsActivated() && (cronometer_error_.seconds() > 60))) {
    error_.Reset();
  }

  // Previous error
  if (error_.IsActivated()) {
    state_ = au::str("E[%s]: ", error_.GetMessage().c_str());
    return au::SharedPointer<WorkerTask>(NULL);
  }

  // Check if the operatio is valid
  au::ErrorManager error;
  if (!isStreamOperationValid(data, *stream_operation, &error)) {
    state_ = au::str("E[%s]: ", error.GetMessage().c_str());
    ResetWithError(error.GetMessage());
    return au::SharedPointer<WorkerTask>(NULL);
  }

  // If operation is paused, do not consider then...
  if (stream_operation->paused()) {
    state_ = "Operation paused";
    return au::SharedPointer<WorkerTask>(NULL);
  }

  std::string operation_name = stream_operation->operation();
  Operation *operation = au::Singleton<ModulesManager>::shared()->getOperation(operation_name);

  if (!operation) {
    ResetWithError(au::str("Operation %s not found", operation_name.c_str()));
    return au::SharedPointer<WorkerTask>(NULL);
  }

  /*
   Dynamic inputs
   ----------------------------
   map,parse,...     All inputs are dynamic (1 dynamic input)
   Batch operation:  All inputs are non dynamic ( all input required )
   Stream operation: All inputs are dynamic except last ( state ) input
   Reduce forward:   All inputs are dynamic except last ( auxiliar data-set ) input

   Inputs to count for pending size
   ----------------------------
   map,parse,...     Single input ( counts )
   Batch operation:  All inputs
   Stream operation: N-1 ( last one is state and it is not considered pending.size)
   */

  bool batch_operation = stream_operation->batch_operation();

  int num_dynamic_inputs = 1;
  int num_pending_size_inputs = 1; // Numer of inputs to consider for the "pending size"
  if (operation->getType() == Operation::reduce) {
    if (batch_operation) {
      num_dynamic_inputs = 0;
      num_pending_size_inputs = operation->getNumInputs();
    } else {
      num_dynamic_inputs = operation->getNumInputs() - 1;
      num_pending_size_inputs = operation->getNumInputs() - 1;
    }
  }

  // Create candidate task ( if id is provided )
  if (task_id != (size_t) -1)
    worker_task_ = new WorkerTask(samson_worker_, task_id, *stream_operation, operation, range_);

  // Compute the limit block to start packaging blocks in the task
  size_t accumulated_size = 0; // Accumulated size required to be in memory for this operation
  au::Uint64Set block_ids; // Block required so far

  // Scan all inputs
  for (int i = 0; i < stream_operation->inputs_size(); i++) {
    std::string input_queue = stream_operation->inputs(i);
    gpb::Queue *queue = ::samson::gpb::get_queue(data, input_queue);

    if (!queue) {
      continue; // No data at this input
    }

    for (int b = 0; b < queue->blocks_size(); b++) {
      const gpb::Block& block = queue->blocks(b);
      size_t block_id = block.block_id();
      const gpb::KVRanges ranges = block.ranges();

      if (i < num_pending_size_inputs) {
        KVRanges ranges2 = block.ranges(); // Implicit conversion
        double overlap_factor = ranges2.GetOverlapFactor(range_);
        // TODO(@jges): Remove log messages
        LM_M(("pending_size(%lu) = pending_size(%lu) + overlap_factor(%lf)*block.size(%lu)", pending_size_ + (overlap_factor * block.size()), pending_size_, overlap_factor, block.size()));
        pending_size_ += (overlap_factor * block.size());
      }

      for (int r = 0; r < ranges.range_size(); r++) {
        KVRange range = ranges.range(r); // Implicit conversion
        KVRange intersection = range.Intersection(range_);

        if (intersection.size() > 0) {
          // This block should be considered
          BlockPointer real_block = BlockManager::shared()->GetBlock(block.block_id());
          if (real_block == NULL) {
            ResetWithError(au::str("Block %lu not found", block.block_id()));
            return au::SharedPointer<WorkerTask>(NULL);
          }

          // Add input to the task
          if (worker_task_ != NULL)
            worker_task_->AddInput(i, real_block, intersection, KVInfo(0, 0));

          // Accumulate size if the block was not considered before
          if (!block_ids.contains(block_id)) {
            accumulated_size += real_block->getSize(); // Accumulate size of the block
            block_ids.insert(block_id);
          }
        }
      }

      // Stop if we need to much memory for this task
      if (i < num_dynamic_inputs)
        if (accumulated_size > 200000000) { // Limit for dynamic inputs
          break; // No more data from this input
        }
    }
  }

  if (accumulated_size > (0.5 * (double) engine::Engine::shared()->memory_manager()->memory())) {
    // Excessive size, defrag is required
    state_ = au::str("Defrag required ( operation size %s )", au::str(accumulated_size).c_str());
    LM_W(("Individual range operation detected defrag was necessary..."));
    return au::SharedPointer<WorkerTask>(NULL);
  }

  // Compute priority rank based on time and size
  size_t time = last_task_cronometer_.seconds();
  priority_rank_ = pending_size_ * (1 + time);
  if (pending_size_ > 0) {
    // TODO(@jges): Remove log messages
    LM_M(("Ready to schedule a new task, with priority:%lu", priority_rank_));
    state_ = "Ready to schedule a new task";
  } else {
    state_ = "No data to be processed";
  }

  if (worker_task_ != NULL)
    state_ = "Running task...";

  if (task_id != (size_t) -1)
    if (worker_task_ != NULL) {
      last_task_cronometer_.Reset(); // Reset cronometer

      // Add environment variable to identify this stream_operation_id
      worker_task_->environment().Set("system.stream_operation_id", stream_operation_id_);

      // Return the newly generated worker task to be really shcedulled in the worker task manager
      state_ = au::str("Waiting task %lu", task_id);
    }

  return worker_task_;
}

std::string StreamOperationRangeInfo::state() {
  return state_;
}

void StreamOperationRangeInfo::set_state(const std::string& state) {
  state_ = state;
}

// Reset all pending worker_tasks
void StreamOperationRangeInfo::Reset() {
  // Release current working task ( if any )
  priority_rank_ = 0;
  worker_task_ = NULL;
}

void StreamOperationRangeInfo::ResetWithError(const std::string& error_message) {
  error_.set(error_message);
  cronometer_error_.Reset();
  Reset();
}

std::string StreamOperationRangeInfo::str() {
  std::ostringstream output;

  output << "StreamOperation " << stream_operation_id_;
  output << " " << stream_operation_name_;
  output << " " << range_.str();
  return output.str();
}

void StreamOperationRangeInfo::fill(samson::gpb::CollectionRecord *record, const Visualization& visualization) {
  // Common columns
  ::samson::add(record, "id", stream_operation_id_, "different");
  ::samson::add(record, "name", stream_operation_name_, "different");
  ::samson::add(record, "range", range_.str().c_str(), "different");

  if (visualization.get_flag("state")) {
    ::samson::add(record, "state", state_, "different");
    return;
  }

  if (visualization.get_flag("tasks")) {
    if (worker_task_ != NULL) {
      ::samson::add(record, "tasks",
                    au::str("%lu: %s", worker_task_->worker_task_id(), worker_task_->task_state().c_str()), "different");
    } else {
      ::samson::add(record, "tasks", "none", "different");
    }
    return;
  }

  // Default view

  ::samson::add(record, "pending_size", pending_size_, "sum,f=uint64");
  // TODO(@jges): remove log messages
  LM_M(("task:'%s', pending_size:%lu", stream_operation_name_.c_str(), pending_size_));
  ::samson::add(record, "time", au::str_time(last_task_cronometer_.seconds()), "different");
  ::samson::add(record, "priority rank", priority_rank(), "f=uint64,different");

  if (worker_task_ != NULL) {
    ::samson::add(record, "tasks", worker_task_->worker_task_id(), "different");
  } else {
    ::samson::add(record, "tasks", "none", "different");
  }
  ::samson::add(record, "state", state_, "different,left");
}

bool isStreamOperationValid(gpb::Data *data, const gpb::StreamOperation& stream_operation, au::ErrorManager *error) {

  std::string operation_name = stream_operation.operation();
  Operation *operation = au::Singleton<ModulesManager>::shared()->getOperation(operation_name);

  if (!operation) {
    error->set(au::str("Operation %s not found", operation_name.c_str()));
    return false;
  }

  // Check at least an input is defined
  if (stream_operation.inputs_size() == 0) {
    error->set("No inputs defined for this operation");
    return false;
  }

  // Check number of inputs and outputs
  if (operation->getNumInputs() != stream_operation.inputs_size()) {
    error->set(
               au::str("Operation %s needs %d inputs and %d are provided", operation_name.c_str(),
                       operation->getNumInputs(), stream_operation.inputs_size()));
    return false;
  }
  if (operation->getNumOutputs() != stream_operation.outputs_size()) {
    error->set(
               au::str("Operation %s needs %d output and %d are provided", operation_name.c_str(),
                       operation->getNumOutputs(), stream_operation.outputs_size()));
    return false;
  }

  // Check the format of all input queues
  for (int i = 0; i < operation->getNumInputs(); i++) {
    std::string queue_name = stream_operation.inputs(i);
    gpb::Queue *queue = get_queue(data, queue_name);
    if (queue) { // If queue does not exist, there is no problem. I will be automatically created
      KVFormat format(queue->key_format(), queue->value_format());
      if (format != operation->inputFormats[i]) {
        error->set(
                   au::str("%d-th input for %s ( queue %s ) should be %s and it is %s ", i + 1, operation_name.c_str(),
                           queue_name.c_str(), operation->inputFormats[i].str().c_str(), format.str().c_str()));
        return false;
      }
    }
  }

  // Check the format of all output queues
  for (int i = 0; i < operation->getNumOutputs(); i++) {
    std::string queue_name = stream_operation.outputs(i);
    gpb::Queue *queue = get_queue(data, queue_name);
    if (queue) { // If queue does not exist, there is no problem. I will be automatically created
      KVFormat format(queue->key_format(), queue->value_format());
      if (format != operation->outputFormats[i]) {
        error->set(
                   au::str("%d-th output for %s ( queue %s ) should be %s and it is %s ", i + 1,
                           operation_name.c_str(), queue_name.c_str(), operation->outputFormats[i].str().c_str(),
                           format.str().c_str()));
        return false;
      }
    }
  }

  // Additional checks for reduce operations....
  // TO BE COMPLETED


  return true;
}

au::SharedPointer<WorkerTask> StreamOperationRangeInfo::worker_task() {
  return worker_task_;
}

}
} // End of namespace samson::stream
