#!/bin/bash

function setup_test_vars
{
    HAVE_DELILAH_INIT=0
    HAVE_SHELL_INIT=0
    HAVE_COMMAND=0
    HAVE_SCRIPT=0
    HAVE_SHELL=0
    INIT_DELILAH_ERROR=0
    INIT_SHELL_ERROR=0
    MULTIPLE_TESTS=0
    TEST_FAILED=0
    HAVE_EXPECT=0
    HAVE_REGEXPECT=0

    # Get the name of the test script file
    TEST_SCRIPT=$(basename $TEST_PATH)

    TEST_BASENAME=$(echo $TEST_SCRIPT | sed 's/\.test//')
    TEST_NAME=$(sed -n '/--NAME--/,/^--/p' $TEST_SCRIPT  | grep -v "^--")

    #Extract the delilah init script
    if [ $(grep "\-\-DELILAH\-INIT\-\-" $TEST_SCRIPT | wc -l) -eq 1 ]; then
        TEST_DELILAH_INIT=${TEST_BASENAME}.delilah_init
        sed -n '/--DELILAH-INIT--/,/^--/p' $TEST_SCRIPT  | grep -v "^--" > $TEST_DELILAH_INIT
        HAVE_DELILAH_INIT=1
    fi

    #Extract the shell init script
    if [ $(grep "\-\-SHELL\-INIT\-\-" $TEST_SCRIPT | wc -l) -eq 1 ]; then
        TEST_SHELL_INIT=${TEST_BASENAME}.sh_init
        sed -n '/--SHELL-INIT--/,/^--/p' $TEST_SCRIPT  | grep -v "^--" > $TEST_SHELL_INIT
        HAVE_SHELL_INIT=1
    fi

    #Extract the delilah test command
    if [ $(grep "\-\-COMMAND\-\-" $TEST_SCRIPT | wc -l) -eq 1 ]; then
        TEST_COMMAND=$(sed -n '/--COMMAND--/,/^--/p' $TEST_SCRIPT  | grep -v "^--")
        HAVE_COMMAND=1
    fi

    #Extract the delilah test script
    if [ $(grep "\-\-SCRIPT\-\-" $TEST_SCRIPT | wc -l) -eq 1 ]; then
        TEST_DELILAH_SCRIPT=${TEST_BASENAME}.txt
        sed -n '/--SCRIPT--/,/^--/p' $TEST_SCRIPT  | grep -v "^--"  > $TEST_DELILAH_SCRIPT
        HAVE_SCRIPT=1
    fi

    #Extract the shell script
    if [ $(grep "\-\-SHELL\-\-" $TEST_SCRIPT | wc -l) -eq 1 ]; then
        TEST_SHELL_SCRIPT=${TEST_BASENAME}.sh
        sed -n '/--SHELL--/,/^--/p' $TEST_SCRIPT  | grep -v "^--" > $TEST_SHELL_SCRIPT
        HAVE_SHELL=1
    fi

    #Generate the canon file
    if [ $(grep "\-\-EXPECT\-\-" $TEST_SCRIPT | wc -l) -eq 1 ]; then
        TEST_EXPECT=${TEST_BASENAME}.expect
        sed -n '/--EXPECT--/,/^--/p' $TEST_SCRIPT  | grep -v "^--" > $TEST_EXPECT
        HAVE_EXPECT=1
    fi

    #Generate the dynamic canon file
    if [ $(grep "\-\-REGEXPECT\-\-" $TEST_SCRIPT | wc -l) -eq 1 ]; then
        TEST_REGEXPECT=${TEST_BASENAME}.regexpect
        sed -n '/--REGEXPECT--/,/^--/p' $TEST_SCRIPT  | grep -v "^--" > $TEST_REGEXPECT
	   HAVE_REGEXPECT=1
    fi

    TEST_DIFF=${TEST_BASENAME}.diff
    TEST_OUTPUT=${TEST_BASENAME}.out
    TEST_OUTPUT_COMPLETE=${TEST_BASENAME}.out.complete

    if [ $HAVE_COMMAND -eq 0 -a $HAVE_SHELL -eq 0 -a $HAVE_SCRIPT -eq 0 ]; then
        echo "ERROR: $TEST_SCRIPT is missing a test"
        exit 1
    fi

    if [ $HAVE_COMMAND -eq 1 ]; then
        if [ $HAVE_SHELL -eq 1 -o $HAVE_SCRIPT -eq 1 ]; then
            MULTIPLE_TESTS=1
        fi
    fi
    if [ $HAVE_SHELL -eq 1 ]; then
        if [ $HAVE_COMMAND -eq 1 -o $HAVE_SCRIPT -eq 1 ]; then
            MULTIPLE_TESTS=1
        fi
    fi
    if [ $HAVE_SCRIPT -eq 1 ]; then
        if [ $HAVE_COMMAND -eq 1 -o $HAVE_SHELL -eq 1 ]; then
            MULTIPLE_TESTS=1
        fi
    fi
    if [ $MULTIPLE_TESTS -eq 1 ]; then
        echo "Only one test type of --COMMAND--, --SCRIPT-- or --SHELL-- allowed"
        exit 1
    fi

    if [ $HAVE_EXPECT -eq 1 -a $HAVE_REGEXPECT -eq 1 ]; then
        echo "ERROR: Multiple expect sections detected, only one of EXPECT or REGEXPECT should be specified"
        exit 1
    fi

}

function execute_test
{
    echo "RUNNING: $TEST_NAME ($TEST_DIR/$TEST_PATH)"

    # Drop into the directory for the test
    pushd $(dirname $TEST_PATH) > /dev/null
    setup_test_vars

    # ------------------------------------------------ 
    # Initialize the test
    # ------------------------------------------------ 
    if [ $HAVE_DELILAH_INIT -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "Initializing test using delilah"
            cat  `basename $TEST_DELILAH_INIT`
        fi
        #pushd  `dirname $TEST_DELILAH_INIT` > /dev/null
        delilah ${SAMSON_LOG_LEVELS} -f `basename $TEST_DELILAH_INIT` ${SAMSON_TEST_HOST}:${SAMSON_WORKER_PORT_ENV} 2> `basename $TEST_DELILAH_INIT`.stderr > `basename $TEST_DELILAH_INIT`.stdout
        if [ $? -ne 0 ]; then
            INIT_DELILAH_ERROR=1
        fi
        #popd > /dev/null
    fi

    if [ $HAVE_SHELL_INIT -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "Initializing test using bash"
            cat $TEST_SHELL_INIT
        fi
        bash -ex $TEST_SHELL_INIT 2> $TEST_SHELL_INIT.stderr > $TEST_SHELL_INIT.stdout
        if [ $? -ne 0 ]; then
            INIT_SHELL_ERROR=1
        fi
    fi

    # ------------------------------------------------
    # Execute a single delilah command
    # ------------------------------------------------
    if [ $HAVE_COMMAND -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "Executing test command - ${TEST_COMMAND}"
        fi
        delilah ${SAMSON_LOG_LEVELS} ${SAMSON_TEST_HOST}:${SAMSON_WORKER_PORT_ENV} -command "$TEST_COMMAND"  > $TEST_OUTPUT_COMPLETE 2>/dev/null
        grep -v "^[MEWT]:" $TEST_OUTPUT_COMPLETE > $TEST_OUTPUT 2>/dev/null
    fi

    # ------------------------------------------------
    # Execute delilah script
    # ------------------------------------------------
    if [ $HAVE_SCRIPT -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "Executing test using delilah"
        fi
        if [ -f  $TEST_OUTPUT ]; then
            rm -f  $TEST_OUTPUT
        fi
        if [ -f  $TEST_OUTPUT_COMPLETE ]; then
            rm -f  $TEST_OUTPUT_COMPLETE
        fi
        IFS="
"
        for command in $(awk '{print $0}' $TEST_DELILAH_SCRIPT)
        do
            if [ $TEST_VERBOSE -eq 1 ]; then
                echo "Executing - ${command}"
            fi
            delilah ${SAMSON_TEST_HOST}:${SAMSON_WORKER_PORT_ENV} -command "${command}"  >> $TEST_OUTPUT_COMPLETE 2>/dev/null
        done
        grep -v "^[MEWT]:" $TEST_OUTPUT_COMPLETE > $TEST_OUTPUT 2>/dev/null
    fi

    # ------------------------------------------------
    # Execute shell script
    # ------------------------------------------------
    if [ $HAVE_SHELL -eq 1 ]; then
        if [ $TEST_VERBOSE -eq 1 ]; then
            bash -ex $(basename $TEST_SHELL_SCRIPT) > $(basename $TEST_OUTPUT_COMPLETE) 2>/dev/null
            if [ $? -ne 0 ]; then
                SHELL_TEST_ERROR=1
            fi
            grep -v "^[MEWT]:" $(basename $TEST_OUTPUT_COMPLETE) > $(basename $TEST_OUTPUT) 2>/dev/null
        else
            bash -e $(basename $TEST_SHELL_SCRIPT) > $(basename $TEST_OUTPUT_COMPLETE) # 2>/dev/null
            if [ $? -ne 0 ]; then
                SHELL_TEST_ERROR=1
            fi
            grep -v "^[MEWT]:" $(basename $TEST_OUTPUT_COMPLETE) > $(basename $TEST_OUTPUT) 2>/dev/null
        fi
    fi

    # Check to see if the output is what we expect
    if [ $HAVE_EXPECT -eq 1 ]; then
        diff -wbB -u $TEST_EXPECT $TEST_OUTPUT > $TEST_DIFF
    else
        testDiff.py -i $TEST_OUTPUT -r $TEST_REGEXPECT >  $TEST_DIFF
    fi
    if [ $? -ne 0 ]; then
        TEST_FAILED=1
        if [ $TEST_VERBOSE -eq 1 ]; then
            echo "----------------------------------------------------------------"
            echo "ERROR: executing $TEST_PATH"
            echo "Expected"
            if  [ $HAVE_EXPECT -eq 1 ]; then
                cat $TEST_EXPECT
            else
                cat $TEST_REGEXPECT
            fi
            echo "Got"
            cat $TEST_OUTPUT
            if [ $INIT_DELILAH_ERROR -ne 0 ]; then
                echo "Errors were seen initializing delilah"
                echo "STDOUT:"
                cat $TEST_DELILAH_INIT.stdout
                echo "STDERROR:"
                cat $TEST_DELILAH_INIT.stderr
            fi
            echo "----------------------------------------------------------------"
            if [ $INIT_SHELL_ERROR -ne 0 ]; then
                echo "Errors were seen with the shell initialization script"
                echo "STDOUT:"
                cat $TEST_SHELL_INIT.stdout
                echo "STDERROR:"
                cat $TEST_SHELL_INIT.stderr
            fi
            if [ $SHELL_TEST_ERROR -ne 0 ]; then
                echo "Errors were seen with the shell test script"
                echo "STDOUT:"
                cat $TEST_OUTPUT_COMPLETE
            fi
            echo "----------------------------------------------------------------"
        fi
    else
        # Clean up files for succesful test runs
        rm -f $TEST_EXPECT \
                $TEST_OUTPUT \
                $TEST_OUTPUT_COMPLETE \
                $TEST_DELILAH_SCRIPT \
                $TEST_SHELL_SCRIPT \
                $TEST_BASENAME.diff \
                $TEST_REGEXPECT
        if [ ! -z $TEST_DELILAH_INIT ]; then
            rm -f  $TEST_DELILAH_INIT $TEST_DELILAH_INIT.stderr $TEST_DELILAH_INIT.stdout
        fi
        if [ ! -z $TEST_SHELL_INIT ]; then
            rm -f  $TEST_SHELL_INIT $TEST_SHELL_INIT.stderr $TEST_SHELL_INIT.stdout
        fi
    fi

    # Return from whence we came
    popd
}

function test_header
{
    echo "SAMSON functional unit test harness"
    echo "Machine : $(hostname)"
    echo -n "OS      : "
    if [ -f /etc/lsb-release ]; then
        source /etc/lsb-release 
        echo $DISTRIB_DESCRIPTION
    fi
    echo "Date    : $(date)"
}

function usage
{
    echo "Usage: $0 [test_file|test_directory]"
    exit 1
}

if [ -z $1 ]
then
    usage
else
    test_header
fi

# Set TEST_VERBOSE=1 to show the diffs for failed tests
if [ -z $TEST_VERBOSE ]; then
    TEST_VERBOSE=0
fi

# If we have a directory we'll run a suite of tests
if [ -d $1 ];
then
    TEST_DIR=$1
fi

# Init success and failure counters
TEST_COUNT_SUCCESS=0
TEST_COUNT_FAIL=0

# Execute an individual test
if [ -f $1 ];
then
    TEST_DIR=$(dirname $1)
    TEST_SCRIPT=$(basename $1)
fi

if [ -d $1 ];
then
    TEST_DIR=$1
fi

if [ -z "${TEST_DIR}" ]
then
    echo "ERROR: $1 does not exist"
    exit 1
fi

# Drop in to the specified test directory
pushd $TEST_DIR > /dev/null

# If TEST_SCRIPT is defined we execute a single test otherwise we
# go looking for more tests to execute
if [ -z ${TEST_SCRIPT} ];
then
    for test in $(find . -name \*.test | sed 's,^.\/,,')
    do
        TEST_PATH=$test
        execute_test
        if [ $TEST_FAILED -eq 1 ]; then
            echo "FAILED : $TEST_NAME ($TEST_DIR/$TEST_PATH))"
            TEST_COUNT_FAIL=$(expr $TEST_COUNT_FAIL + 1)
            if [ -z "$TEST_FAIL_LIST" ]; then
                TEST_FAIL_LIST=$(echo $TEST_NAME - $TEST_DIR/$TEST_PATH)
            else
                TEST_FAIL_LIST=$(echo $TEST_FAIL_LIST:$TEST_NAME - $TEST_DIR/$TEST_PATH)
            fi

        else
            echo "SUCCESS: $TEST_NAME"
            TEST_COUNT_SUCCESS=$(expr $TEST_COUNT_SUCCESS + 1)
        fi

    done
    # Print summary
    echo "===================================================================="
    echo "Test Summary"
    echo "$TEST_COUNT_SUCCESS test(s) passed"
    echo "$TEST_COUNT_FAIL test(s) failed:"
    IFS=":"
    for test in $TEST_FAIL_LIST
    do
        echo $test
    done
    echo "===================================================================="
else
    # Enable verbose output for a single unit-test
    TEST_VERBOSE=1
    TEST_PATH=$TEST_SCRIPT
    execute_test
    if [ $TEST_FAILED -eq 1 ]; then
        echo "FAILED : $TEST_NAME ($(basename $TEST_PATH))"
        TEST_COUNT_FAIL=$(expr $TEST_COUNT_FAIL + 1)
        if [ -z "$TEST_FAIL_LIST" ]; then
            TEST_FAIL_LIST=$(echo $TEST_NAME - $(basename $TEST_PATH))
        else
            TEST_FAIL_LIST=$(echo $TEST_FAIL_LIST:$TEST_NAME - $(basename $TEST_PATH))
        fi

    else
        echo "SUCCESS: $TEST_NAME"
        TEST_COUNT_SUCCESS=$(expr $TEST_COUNT_SUCCESS + 1)
    fi
fi
popd > /dev/null
exit 0
