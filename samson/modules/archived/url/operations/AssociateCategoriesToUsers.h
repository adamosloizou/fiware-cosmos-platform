/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_url_AssociateCategoriesToUsers
#define _H_SAMSON_url_AssociateCategoriesToUsers


#include <samson/module/samson.h>


/*******************************************************************
reduce AssociateCategoriesToUsers
{
	in system.UInt url.CategoryVector	  # Server(id) - CategoryVector
	in system.UInt url.UserCountVector    # Server(id) - Users(Vector, with count)
	out system.UInt url.CategoryVector    # User(id) - CategoryVector

	helpLine "Assign categories to every user, according to the common key. For every user in the vector, emits the user-categories kv"
}
********************************************************************/

namespace samson{
namespace url{


	class AssociateCategoriesToUsers : public samson::Reduce
	{
		samson::system::UInt serverIdRef;
		samson::system::UInt serverId;
		samson::system::UInt userId;
		UserCountVector users;
		CategoryVector categories;
		CategoryVector categories_out;

	public:


		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
			if (inputs[0].num_kvs == 0)
			{
				return;		// We don't have category information for that server
			}

			if (inputs[0].num_kvs != 1)
			{
				OLM_E(("We should have only one category vector per server: inputs[0].num_kvs:%d", inputs[0].num_kvs));
				return;
			}

			serverIdRef.parse(inputs[0].kvs[0]->key);
			categories.parse(inputs[0].kvs[0]->value);

			size_t num_categories = categories.category_length;

			categories_out.categorySetLength(num_categories);

			for (size_t i = 0; (i < inputs[1].num_kvs); i++)
			{
				users.parse(inputs[1].kvs[i]->value);

				size_t countRef = users.countRef.value;

				// One solution to incorporate count information to the process is this.
				// But this produces some smoothing.
				// Another option could be to keep that count relevance associated to the CategoryVector,
				// and use it when averaging through user keys in the next reduce

				//size_t uniformWeight = CategoryVector::double_2_intScaled(1.0 / double(num_categories));

				for (int j = 0; (j < users.usersCount_length); j++)
				{
					userId = users.usersCount[j].user;

					size_t count = users.usersCount[j].count.value;
					double confidence = sqrt(countRef * count)/countRef;


					//OLM_T(LMT_User06,("For server:%d working with userId:%d, count:%d", serverIdRef.value, userId.value, count));
					for (size_t k = 0; (k < num_categories); k++)
					{
						// New weight is computed directly with the scaled integers (perhaps losing precision)
						// Should be improved, using the ratio between count and total count (no countRef),
						// but in this implementation we would need an extra reduce
						categories_out.category[k].weight = categories.category[k].weight;
						categories_out.category[k].confidence = CategoryVector::double_2_intScaled(confidence);
						//OLM_T(LMT_User06, ("(\t cat[%d]:%d (unif:(%d) + rel(%.2f)*cat(%d))/(1+rel) ", k, categories_out.category[k].value, uniformWeight, relevance, categories.category[k].value));
						categories_out.category[k].countServer = count;
						categories_out.category[k].countUser = count;
						//OLM_T(LMT_User06,("server:%d user:%d cat[%d]:%d (count(%d) ", serverIdRef.value, userId.value, k, categories_out.category[k].weight.value, categories_out.category[k].countServer.value));

					}
					//OLM_T(LMT_User06,("Emits userId:%d, count:%d", userId.value, count));

					writer->emit(0, &userId, &categories_out);

				}

			}

		}


	};


} // end of namespace samson
} // end of namespace url

#endif
