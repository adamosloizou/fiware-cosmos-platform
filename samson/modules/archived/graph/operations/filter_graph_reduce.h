/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_graph_filter_graph_reduce
#define _H_SAMSON_graph_filter_graph_reduce


#include <samson/module/samson.h>
#include <samson/modules/system/UInt.h>
#include <vector>

namespace samson{
namespace graph{


	class filter_graph_reduce : public samson::Reduce
	{

		samson::system::UInt node_id;
		samson::graph::Node node;
		std::vector<size_t>removedElement;
		
	public:

		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
			if( inputs[0].num_kvs <= 0 )
			   tracer->setUserError("No key-values at the input");
			
			//Get the key to discover the node of study	
			node_id.parse(inputs[0].kvs[0]->key);	
			
			//Element to get all information from the keyNode
			bool found = false;
			
			//Vector to hold all ids to be removed
			removedElement.clear();
			
			samson::graph::Node tmp_node;
			for (size_t i = 0 ; i < inputs[0].num_kvs ; i++)
			{
				tmp_node.parse(inputs[0].kvs[i]->value);
				
				if ( tmp_node.id.value == node_id.value )
				{
					if( found )
					{
						/*
						std::ostringstream o;
						o << "MRFilterGraphReduce error when processing node " << node_id.value << " .It appears twice in the reduce.";
						setErrorMessage( o.str() );
						return;
						 */

					   tracer->setUserError("Error since we found ourself twice");
					}
					
					found = true;
					node.parse(inputs[0].kvs[i]->value);	//reparse to get all information again

					if( node.links_length <= 0 )
					{
					   
					   OLM_E(("Error in node %lu. Found ourselves with %lu contacts ( number of kvs for me %lu)" , tmp_node.id.value , tmp_node.links_length , inputs[0].num_kvs ));
					   tracer->setUserError("Error with auto-loop nodes");
					}
				}
				else
				{
					//Kill node...
					if( tmp_node.links_length != 0 )
					   tracer->setUserError("Error tmp_node.links_length != 0");

					removedElement.push_back( tmp_node.id.value );
				}
			}
			
			if( found )
			{
				//This node should survive if it has still some connections
				
				int pos = 0;
				std::vector<size_t>::iterator iter = removedElement.begin();
				for (int i = 0 ; i < node.links_length ; i++)
				{
					while ( (iter < removedElement.end()) && ((*iter) < node.links[i].id.value ) ) {
						iter++;
					}
					
					if( ( iter >= removedElement.end() ) || ( (*iter) != node.links[i].id.value) )
					{
						if( i!=pos)
							node.links[pos] = node.links[i];
						pos++;
					}			
				}
				node.linksSetLength(pos);
				if( node.links_length > 0)
					writer->emit(0,&node_id, &node);
			}
			
		}


	};


} // end of namespace samson
} // end of namespace graph

#endif
