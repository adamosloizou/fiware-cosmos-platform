/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_sna_filter_graph_map
#define _H_SAMSON_sna_filter_graph_map


/****************************************************************************************
map filter_graph_map
{
  in  system.UInt sna.Node
  out system.UInt sna.Node

  setup

  help
  {
    "First phase of the filter-graph process. Please concatenate wiht sna.filter_reduce to perform the filter graph"
    "In this first step, graph elements are simply put at the output if they are correct."
    "If they are not correct, a \"kill-node\" is send at the output to all its connections to be removed in the second phase"
    "Use -only_extreme to filter out only nodes with over 2 * max_connections"
  }

}
 ******************************************************************************************/

#include <samson/module/samson.h>
#include "sna_environment_parameters.h"


namespace samson{
namespace sna{


class filter_graph_map : public samson::Map
{
	int max_connections;
	int max_strong_connections;

public:

	void init(samson::KVWriter *writer)
	{
		OLM_M(("filter_graph_map::init()"));
		// Here we filter elements with more than X connections
		max_connections = environment->getInt(SNA_PARAMETER_MAX_CONNECTIONS, SNA_PARAMETER_MAX_CONNECTIONS_DEFAULT);

		// Here we filter elements with more than X strong connections
		max_strong_connections = environment->getInt(SNA_PARAMETER_MAX_STRONG_CONNECTIONS, SNA_PARAMETER_MAX_STRONG_CONNECTIONS_DEFAULT);

		int only_extreme = environment->getInt(SNA_FLAG_ONLY_EXTREME, 0);
		if ( only_extreme )
		{
			max_connections = max_connections ;
			max_strong_connections = max_connections*2 ;
		}
	}

	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		//Used in the map to emit "kill" messages...
		samson::system::UInt killNode_id;
		Node killNode;

		//Inputs
		samson::system::UInt  node_id;
		Node node;

		// Already in init()
		/*****************
		max_connections = environment->getInt(SNA_PARAMETER_MAX_CONNECTIONS, SNA_PARAMETER_MAX_CONNECTIONS_DEFAULT);

		// Here we filter elements with more than X strong connections
		max_strong_connections = environment->getInt(SNA_PARAMETER_MAX_STRONG_CONNECTIONS, SNA_PARAMETER_MAX_STRONG_CONNECTIONS_DEFAULT);

		int only_extreme = environment->getInt(SNA_FLAG_ONLY_EXTREME, 0);
		if ( only_extreme )
		{
			max_connections = max_connections ;
			max_strong_connections = max_connections*2 ;
		}
		/******************/


		killNode.linksSetLength(0); //A node with no links will be identified as a mark to be removed

		for (size_t i = 0 ; i < inputs[0].num_kvs ; ++i)
		{
			//Parsing key and value
			node_id.parse( inputs[0].kvs[i]->key );
			node.parse( inputs[0].kvs[i]->value );
			//OLM_T(LMT_User01,("Working with node_id:%ld, node:%ld", node_id.value, node.id.value));

			if ( node_id.value != node.id.value )
			{
				OLM_E(("node_id.value(%ld) != node.id.value(%ld)", node_id.value, node.id.value));
				exit(1);
			}

			if ( node_id.value == 0 )
			{
				OLM_E(("node_id.value(%ld) == 0", node_id.value));
				exit(1);
			}

			if ((  node.numberOfLinksWithWeightEqualOrHigher( 1.0 ) >= max_strong_connections ) ||
				((node.numberOfLinksWithWeightEqualOrHigher( 0.0 ) - node.numberOfLinksWithWeightEqualOrHigher( 1.0 )) >= max_connections ))
			{
				//Emit kill messages to be removed in all the contrpart nodes in the reduce phase

				killNode.id = node_id.value ;
				//OLM_T(LMT_User01, ("node_id:%ld Checks connections for %ld links because node.numberOfLinksWithWeightEqualOrHigher( 1.0 )(%d) >= max_strong_connections(%d) ) || ((node.numberOfLinksWithWeightEqualOrHigher( 0.0 ) - node.numberOfLinksWithWeightEqualOrHigher( 1.0 ))(%d) >= max_connections(%d) )", node_id.value, node.links_length, node.numberOfLinksWithWeightEqualOrHigher( 1.0 ), max_strong_connections, (node.numberOfLinksWithWeightEqualOrHigher( 0.0 ) - node.numberOfLinksWithWeightEqualOrHigher( 1.0 )),  max_connections));

				for (int j = 0 ; j < node.links_length ; ++j)
				{
					killNode_id.value = node.links[j].id.value;   //This is the target node to be removed in
					//It is not necessary to emit a kill signal to a connection of this node if the connection
					//turns out to be the same node (calling itself). This prevents the reduce operation to collapse
					//and since we are killing the node already, it is not needed to send a kill signal to himself again.
					if (killNode_id.value != killNode.id.value)
					{
						//OLM_T(LMT_User01, ("node_id:%ld Emits killNode_id:%ld, killNode:%ld", node_id.value,killNode_id.value, killNode.id.value));
						writer->emit(0, &killNode_id, &killNode );
					}
				}
			}
			else
			{
				//OLM_T(LMT_User01, ("node_id:%ld Emits node_id:%ld, node:%ld with %d links", node_id.value,node_id.value, node.id.value, node.links_length));

				//Simply by pass the map to the reduce
				writer->emit(0, &node_id, &node);
			}
		}

	}


};


} // end of namespace samson
} // end of namespace sna

#endif
