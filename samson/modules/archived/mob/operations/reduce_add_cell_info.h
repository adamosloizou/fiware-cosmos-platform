/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_mob_reduce_add_cell_info
#define _H_SAMSON_mob_reduce_add_cell_info


#include <samson/module/samson.h>
#include <samson/modules/system/DateComplete.h>
#include <samson/modules/system/Time.h>
#include <samson/modules/system/ComplexTimeSlot.h>

#include "mob_environment_parameters.h"


namespace samson{
namespace mob{


class reduce_add_cell_info : public samson::Reduce
{

	// TimeSlots to characterize Home and Work
	samson::system::ComplexTimeSlot ctsH;
	samson::system::ComplexTimeSlot ctsW;

	// Input[0k]
	samson::system::UInt32 key;
	// Input[0v] & Output[0v]
	samson::cdr::mobCdr cdr;
	// Input[1v] & Output[1v]
	samson::cdr::Cell cell;
	// Output[012k]
	samson::system::UInt phone;
	// Output[2v]
	CellCounter cellCounter;

	// Local variables to handle TimeSlot
	samson::system::DateComplete lDate;
	samson::system::Time lTime;


public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.UInt32 cdr.mobCdr
	input: system.UInt32 cdr.Cell
	output: system.UInt cdr.mobCdr
	output: system.UInt cdr.Cell
	output: system.UInt mob.CellCounter
	output: system.UInt mob.CellCounter

	helpLine: Keep only CDRs with known cell id and add cell info from the catalogue.
	extendedHelp: 		Keep only CDRs with known cell id and add cell info from the catalogue.

#endif // de INFO_COMMENT


	/**
	 * Setup function before adding cell info to CDR's.
	 * It initializes the timeslot objects.
	 */
	void init(samson::KVWriter *writer )
	{

		// HOME
		// Mon-Thu from 21:00:00 to 23:59:59
		// Sat-Sun from 08:00:00 to 12:59:59
		std::string conf_timeslot_home = environment->get(MOB_PARAMETER_CONF_TIMESLOT_HOME, MOB_PARAMETER_CONF_TIMESLOT_HOME_DEFAULT);
		ctsH.set( conf_timeslot_home );

		// WORK
		// Mon-Fri from 09:00:00 to 14:59:59
		std::string conf_timeslot_work = environment->get(MOB_PARAMETER_CONF_TIMESLOT_WORK, MOB_PARAMETER_CONF_TIMESLOT_WORK_DEFAULT);
		ctsW.set( conf_timeslot_work );

		//OLM_T(LMT_User06, ("reduce_add_cell_info::init() of 0x%0x with '%s' and '%s'\n", this, conf_timeslot_home.c_str(), conf_timeslot_work.c_str()));
	}

	/**
	 * Reduce CDR's with the cell catalogue and add
	 * cell information.
	 */
	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{


		if( inputs[0].num_kvs > 0 )
		{
			if( inputs[1].num_kvs > 0 )
			{
				// CDR has its corresponding cell in the catalogue
				cell.parse( inputs[1].kvs[0]->value );
			}
			else
			{
				// CDR does not have its corresponding cell in the catalogue
				// we assign the null cell
				cell.cellId.value = 0;
				cell.btsId.value = 0;
				cell.lacId.value = 0;
				cell.stateId.value = 0;
			}

			key.parse(inputs[0].kvs[0]->key);

/*			if (inputs[0].num_kvs > 200000)
			{
				OLM_T(LMT_User06, ("reduce_add_cell_info::run() at 0x%0x: key:0x%0x with cell:0x%0x with inputs[0].num_kvs:%lu", this, key.value, cell.cellId.value, inputs[0].num_kvs));
			}*/
			for( size_t i=0; i<inputs[0].num_kvs; i++ )
			{
				cdr.parse( inputs[0].kvs[i]->value );

				// IDEA:
				// At this point, we could discard cdrs that neither
				// have cell information nor have mobility scope
				// information, because they are useless both
				// for mobility degree and place of home and work.
				// Must be studied in detail anyway.

				// fill only cell values
				cdr.cellId.value = cell.cellId.value;
				//cdr.btsId.value = cell.btsId.value;
				//cdr.lacId.value = cell.lacId.value;
				//cdr.stateId.value = cell.stateId.value;

				// get phone number
				phone.value = cdr.phone.value;


				// emit first output to keep complete cdrs
				// Optimization. Now, we only emit cdrs with cellId == 0
				// Later, cdrs are only used at reduce_compute_mobility_degree
				// and then to compute the total number of calls, and the
				// national and international calls when cellId == 0
				// Before, at reduce_cdr_clients we have emitted a mobility_degree
				// with the total number of calls per user, so now we only have to emit
				// the cdrs with cellId == 0, per user
				if (cdr.cellId.value == 0)
				{
					writer->emit(0, &phone, &cdr );
				}


				writer->emit(1, &phone, &cell);

				// for place of home and work, we can do nothing if
				// we do not have cell information
				if( cdr.cellId.value > 0 )
				{

					cellCounter.cell = cell;

					//OLM_T(LMT_User06, ("timeUnix :%s", cdr.timeUnix.str().c_str()));


					cdr.timeUnix.getDateTimeFromTimeUTC(&lDate, &lTime);

					cellCounter.count = lDate.days_2000;

					// emit CDR's for the place of home
					if( ctsH.includes( &lDate, &lTime ) == true )
					{
						writer->emit(2, &phone, &cellCounter);
						//OLM_T(LMT_User06, ("For key:0x%0x, cdr:'%s' detects home", key.value, cdr.str().c_str()));
					}
					else
					{
						//OLM_T(LMT_User06, ("For key:0x%0x, cdr:'%s' NOT detects home", key.value, cdr.str().c_str()));
					}

					// emit CDR's for the place of work
					if( ctsW.includes( &lDate, &lTime ) == true )
					{
						writer->emit(3, &phone, &cellCounter);
						//OLM_T(LMT_User06, ("For key:0x%0x, cdr:'%s' detects work", key.value, cdr.str().c_str()));
					}
					else
					{
						//OLM_T(LMT_User06, ("For key:0x%0x, cdr:'%s' NOT detects work", key.value, cdr.str().c_str()));
					}
				}
			}
		}
	}

	void finish(samson::KVWriter *writer )
	{
		//OLM_T(LMT_User06, ("reduce_add_cell_info::finish() of 0x%0x'\n", this));
	}



};


} // end of namespace samson
} // end of namespace mob

#endif
