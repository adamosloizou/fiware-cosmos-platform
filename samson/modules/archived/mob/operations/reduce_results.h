/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_mob_reduce_results
#define _H_SAMSON_mob_reduce_results


#include <samson/module/samson.h>

#include "mob_environment_parameters.h"


namespace samson{
namespace mob{


class reduce_results : public samson::Reduce
{

	size_t minMonthCalls_int;
	size_t minMonthCalls_nat;
	size_t minMonthCalls_sta;
	size_t minMonthCalls_lac;
	size_t minPercLacStaCalls;
	// set limits for home place
	size_t numDaysMin_cell_home;
	size_t freqMin_cell_home;
	size_t numDaysMin_bts_home;
	size_t freqMin_bts_home;
	size_t numDaysMin_lac_home;
	size_t freqMin_lac_home;
	size_t numDaysMin_sta_home;
	size_t freqMin_sta_home;
	// set limits for work place
	size_t numDaysMin_cell_work;
	size_t freqMin_cell_work;
	size_t numDaysMin_bts_work;
	size_t freqMin_bts_work;
	size_t numDaysMin_lac_work;
	size_t freqMin_lac_work;
	size_t numDaysMin_sta_work;
	size_t freqMin_sta_work;

	// Input[012k] & Output[0k]
	samson::system::UInt phone;
	// Input[0v]
	MobilityDegree md;
	// Input[12v]
	Place place;
	// Output[0v]
	Results results;


	// Not in use right now
	//samson::system::ComplexTimeSlot ctsH;
	//samson::system::ComplexTimeSlot ctsW;

public:

	/**
	 * Function to compute the final mobility degree
	 * from the reference locations and the thresholds
	 * set in the configuration parameters.
	 *
	 * @param md Pointer to the structure that holds
	 *    the information of mobility degree.
	 * @param degree Pointer to the value of the
	 *    mobility degree.
	 */
	void GetMobilityDegree( MobilityDegree *md, samson::system::UInt *degree)
	{
	   *degree = MD_UNKNOWN;

	   // to be revised if we process more than one month
	   if( md->internationalCalls.value >= minMonthCalls_int )
	   {
	      *degree = MD_INTERNATIONAL;
	   }
	   else if( md->nationalCalls.value >= minMonthCalls_nat )
	   {
	      *degree = MD_NATIONAL;
	   }
	   else if( md->lacCalls.value >= minMonthCalls_lac )
	   {
	      if( ((md->lacCalls.value*100)/md->stateCalls.value) >= minPercLacStaCalls )
	      {
		 *degree = MD_REDUCED;
	      }
	      else if( md->stateCalls.value >= minMonthCalls_lac )
	      {
		 *degree = MD_PROVINCIAL;
	      }
	   }
	}


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.UInt mob.MobilityDegree
	input: system.UInt mob.Place
	input: system.UInt mob.Place
	output: system.UInt mob.Results

	helpLine: Apply thresholds and compute final mobility results.
	extendedHelp: 		Apply thresholds and compute final mobility results.

#endif // de INFO_COMMENT

	/**
	 * Setup function before joining all
	 * mobility results into a structure.
	 */
	void init(samson::KVWriter *writer )
	{
		//Get configuration levels from macro options
		// set limits for mobility degree
		minMonthCalls_int = environment->getInt(MOB_PARAMETER_MINMONTHCALLS_IN, MOB_PARAMETER_MINMONTHCALLS_IN_DEFAULT);
		minMonthCalls_nat = environment->getInt(MOB_PARAMETER_MINMONTHCALLS_NAT_HOME, MOB_PARAMETER_MINMONTHCALLS_NAT_HOME_DEFAULT);
		minMonthCalls_sta = environment->getInt(MOB_PARAMETER_MINMONTHCALLS_STA, MOB_PARAMETER_MINMONTHCALLS_STA_DEFAULT);
		minMonthCalls_lac = environment->getInt(MOB_PARAMETER_MINMONTHCALLS_LAC, MOB_PARAMETER_MINMONTHCALLS_LAC_DEFAULT);
		minPercLacStaCalls = environment->getInt(MOB_PARAMETER_MINPERLACSTACALLS, MOB_PARAMETER_MINPERLACSTACALLS_DEFAULT);
		// set limits for home place
		numDaysMin_cell_home = environment->getInt(MOB_PARAMETER_NUMDAYSMIN_CELL_HOME, MOB_PARAMETER_NUMDAYSMIN_CELL_HOME_DEFAULT);
		freqMin_cell_home = environment->getInt(MOB_PARAMETER_FREQMIN_CELL_HOME, MOB_PARAMETER_FREQMIN_CELL_HOME_DEFAULT);
		numDaysMin_bts_home = environment->getInt(MOB_PARAMETER_NUMDAYSMIN_BTS_HOME, MOB_PARAMETER_NUMDAYSMIN_BTS_HOME_DEFAULT);
		freqMin_bts_home = environment->getInt(MOB_PARAMETER_FREQMIN_BTS_HOME, MOB_PARAMETER_FREQMIN_BTS_HOME_DEFAULT);
		numDaysMin_lac_home = environment->getInt(MOB_PARAMETER_NUMDAYSMIN_LAC_HOME, MOB_PARAMETER_NUMDAYSMIN_LAC_HOME_DEFAULT);
		freqMin_lac_home = environment->getInt(MOB_PARAMETER_FREQMIN_LAC_HOME, MOB_PARAMETER_NUMDAYSMIN_LAC_HOME_DEFAULT);
		numDaysMin_sta_home = environment->getInt(MOB_PARAMETER_NUMDAYSMIN_STA_HOME, MOB_PARAMETER_NUMDAYSMIN_LAC_HOME_DEFAULT);
		freqMin_sta_home = environment->getInt(MOB_PARAMETER_FREQMIN_STA_HOME, MOB_PARAMETER_FREQMIN_STA_HOME_DEFAULT);
		// set limits for work place
		numDaysMin_cell_work = environment->getInt(MOB_PARAMETER_NUMDAYSMIN_CELL_WORK, MOB_PARAMETER_NUMDAYSMIN_CELL_WORK_DEFAULT);
		freqMin_cell_work = environment->getInt(MOB_PARAMETER_FREQMIN_CELL_WORK, MOB_PARAMETER_FREQMIN_CELL_WORK_DEFAULT);
		numDaysMin_bts_work = environment->getInt(MOB_PARAMETER_NUMDAYSMIN_BTS_WORK, MOB_PARAMETER_NUMDAYSMIN_BTS_WORK_DEFAULT);
		freqMin_bts_work = environment->getInt(MOB_PARAMETER_FREQMIN_BTS_WORK, MOB_PARAMETER_FREQMIN_BTS_WORK_DEFAULT);
		numDaysMin_lac_work = environment->getInt(MOB_PARAMETER_NUMDAYSMIN_LAC_WORK, MOB_PARAMETER_NUMDAYSMIN_LAC_WORK_DEFAULT);
		freqMin_lac_work = environment->getInt(MOB_PARAMETER_FREQMIN_LAC_WORK, MOB_PARAMETER_FREQMIN_LAC_WORK_DEFAULT);
		numDaysMin_sta_work = environment->getInt(MOB_PARAMETER_NUMDAYSMIN_STA_WORK, MOB_PARAMETER_NUMDAYSMIN_STA_WORK_DEFAULT);
		freqMin_sta_work = environment->getInt(MOB_PARAMETER_FREQMIN_STA_WORK, MOB_PARAMETER_FREQMIN_STA_WORK_DEFAULT);

		// set timeslots again
		// HOME
		// Mon-Thu from 21:00:00 to 23:59:59
		// Sat-Sun from 08:00:00 to 12:59:59
		// Not in use right now
		//std::string conf_timeslot_home = environment->get(MOB_PARAMETER_CONF_TIMESLOT_HOME, MOB_PARAMETER_CONF_TIMESLOT_HOME_DEFAULT);
		//ctsH.set( conf_timeslot_home );

		// WORK
		// Mon-Fri from 09:00:00 to 14:59:59
		// Not in use right now
		//std::string conf_timeslot_work = environment->get(MOB_PARAMETER_CONF_TIMESLOT_WORK, MOB_PARAMETER_CONF_TIMESLOT_WORK_DEFAULT);
		//ctsW.set( conf_timeslot_work );
	}

	/**
	 * Apply thresholds and compute final mobility results.
	 */
	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		// get phone number
		if( inputs[0].num_kvs > 0 )
		{
			phone.parse( inputs[0].kvs[0]->key );
		}
		else if( inputs[1].num_kvs > 0 )
		{
			phone.parse( inputs[1].kvs[0]->key );
		}
		else if( inputs[2].num_kvs > 0 )
		{
			phone.parse( inputs[2].kvs[0]->key );
		}
		else
		{
			return;
		}

		// mobility degree
		if( inputs[0].num_kvs > 0 )
		{
			md.parse( inputs[0].kvs[0]->value );

			// apply thresholds and compute final mobility degree
			GetMobilityDegree(&md, &results.mobilityDegree);
		}
		else
		{
			results.mobilityDegree.value = MD_UNKNOWN;
		}

		// place of home
		if( inputs[1].num_kvs > 0 )
		{
			place.parse( inputs[1].kvs[0]->value );

			// cell
			if (place.totalDaysWithCalls.value == 0)
			{
				OLM_T(LMT_User06, ("Error, 0 days with calls"));
			}
			results.homeCellFreq.value = (100*place.cellDaysWithCalls.value)/place.totalDaysWithCalls.value;
			//OLM_T(LMT_User06, ("For phone:%lu, homeCellFreq:(%d) = (100*cellDaysWithCalls(%lu)/totalDaysWithCalls(%lu))", place.phone.value, results.homeCellFreq.value, place.cellDaysWithCalls.value, place.totalDaysWithCalls.value));
			if( (place.cellDaysWithCalls.value >= numDaysMin_cell_home) &&
					(results.homeCellFreq.value >= freqMin_cell_home))
			{
				results.homeCellId.value = place.cellId.value;
			}
			else
			{
				results.homeCellId.value = 0;
			}

			// bts

			results.homeBtsFreq.value = (100*place.btsDaysWithCalls.value)/place.totalDaysWithCalls.value;
			if( (place.btsDaysWithCalls.value >= numDaysMin_bts_home) &&
					(results.homeBtsFreq.value >= freqMin_bts_home))
			{
				results.homeBtsId.value = place.btsId.value;
			}
			else
			{
				results.homeBtsId.value = 0;
			}

			// lac
			results.homeLacFreq.value = (100*place.lacDaysWithCalls.value)/place.totalDaysWithCalls.value;
			if( (place.lacDaysWithCalls.value >= numDaysMin_lac_home) &&
					(results.homeLacFreq.value >= freqMin_lac_home))
			{
				results.homeLacId.value = place.lacId.value;
			}
			else
			{
				results.homeLacId.value = 0;
			}

			// state
			results.homeStateFreq.value = (100*place.stateDaysWithCalls.value)/place.totalDaysWithCalls.value;
			if( (place.stateDaysWithCalls.value >= numDaysMin_sta_home) &&
					(results.homeStateFreq.value >= freqMin_sta_home))
			{
				results.homeStateId.value = place.stateId.value;
			}
			else
			{
				results.homeStateId.value = 0;
			}
		}
		else
		{
			results.homeCellId.value = 0;
			results.homeCellFreq.value = 0;
			results.homeBtsId.value = 0;
			results.homeBtsFreq.value = 0;
			results.homeLacId.value = 0;
			results.homeLacFreq.value = 0;
			results.homeStateId.value = 0;
			results.homeStateFreq.value = 0;
		}

		// place of work
		if( inputs[2].num_kvs > 0 )
		{
			place.parse( inputs[2].kvs[0]->value );

			// cell
			results.workCellFreq.value = (100*place.cellDaysWithCalls.value)/place.totalDaysWithCalls.value;
			if( (place.cellDaysWithCalls.value >= numDaysMin_cell_work) &&
					(results.workCellFreq.value >= freqMin_cell_work))
			{
				results.workCellId.value = place.cellId.value;
			}
			else
			{
				results.workCellId.value = 0;
			}

			// bts
			results.workBtsFreq.value = (100*place.btsDaysWithCalls.value)/place.totalDaysWithCalls.value;
			if( (place.btsDaysWithCalls.value >= numDaysMin_bts_work) &&
					(results.workBtsFreq.value >= freqMin_bts_work))
			{
				results.workBtsId.value = place.btsId.value;
			}
			else
			{
				results.workBtsId.value = 0;
			}

			// lac
			results.workLacFreq.value = (100*place.lacDaysWithCalls.value)/place.totalDaysWithCalls.value;
			if( (place.lacDaysWithCalls.value >= numDaysMin_lac_work) &&
					(results.workLacFreq.value >= freqMin_lac_work))
			{
				results.workLacId.value = place.lacId.value;
			}
			else
			{
				results.workLacId.value = 0;
			}

			// state
			results.workStateFreq.value = (100*place.stateDaysWithCalls.value)/place.totalDaysWithCalls.value;
			if( (place.stateDaysWithCalls.value >= numDaysMin_sta_work) &&
					(results.workStateFreq.value >= freqMin_sta_work))
			{
				results.workStateId.value = place.stateId.value;
			}
			else
			{
				results.workStateId.value = 0;
			}
		}
		else
		{
			results.workCellId.value = 0;
			results.workCellFreq.value = 0;
			results.workBtsId.value = 0;
			results.workBtsFreq.value = 0;
			results.workLacId.value = 0;
			results.workLacFreq.value = 0;
			results.workStateId.value = 0;
			results.workStateFreq.value = 0;
		}

		// emit
		writer->emit(0, &phone, &results );
	}

	void finish(samson::KVWriter *writer )
	{
	}



};


} // end of namespace samson
} // end of namespace mob

#endif
