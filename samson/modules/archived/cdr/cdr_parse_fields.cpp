
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#include <stdint.h>
#include <string.h>
#include <time.h>

#include "cdr_parse_fields.h"
#include "cdr_environment_parameters.h"

//
// MEXICO
//

/**
 * Possible mobility scopes for Mexico:
 * NI - No informado
 * NA - No aplica
 * GE - Genï¿½rico
 * OT - Otro
 * NOROAMI - No roaming
 * RMITRAR - Roaming intrarregional
 * RMITERR - Roaming interregional
 * RMNACIO - Romaing nacional
 * RMITNCL - Roaming internacional
 * RMMUNDI - Roaming mundial
 * RVISITA - Roaming visitante
 */

const char *cdrScopes_MX [] =
{
		"NI",
		"NA",
		"GE",
		"OT",
		"NOROAMI",
		"RVISITA",
		"RMITRAR",
		"RMITERR",
		"RMNACIO",
		"RMITNCL",
		"RMMUNDI"
};


///Function to get next field of a line
///from a source data file.
///
///@param line Pointer to the line being parsed.
///@param pos Pointer to the las position of the former field.
///@param pos_field Pointer to the first position of the next field.
///
void cdrGetNextField(char *line, unsigned int *pos, unsigned int *pos_field){
	*pos_field = *pos;
	while( line[*pos] != CONF_SEP && line[*pos] != '\0' ){
		(*pos)++;
	}

	//new end of line
	line[*pos]='\0';
	//position updated
	(*pos)++;
}


///Function to translate a string cell id
///into an integer cell id.
///
///@param strCellId Pointer to the string cell id.
///@param cellId Pointer to the integer cell id.
void cdrStrCellToInt( char *strCellId, uint32_t *cellId ){
	int _cellLength = 0;
	char *_endptr;

	_cellLength = strlen( strCellId );
	if( _cellLength > CONF_MOB_CELL_LENGTH ){
		*cellId = strtoul( strCellId+(_cellLength-CONF_MOB_CELL_LENGTH), &_endptr, 16 );
	}else{
		*cellId = strtoul( strCellId, &_endptr, 16 );
	}

	if( *_endptr != '\0' ){
		*cellId = 0;
		//OLM_D(("Wrong CellId format: strCellId:'%s' -> celId:%u\n", strCellId, cellId ));
	}
}

///Function to translate a string date
///into a date structure.
///
///@param strDate Pointer to the string date.
///@param date Pointer to the tm structure (only date information will be filled.
///@param old Flag to decide the date format
void cdrStrDateToStructure( char *strDate, struct tm *date , bool old){

	if(old){
		//DD/MM/YYYY
		//01/34/6789
		date->tm_year = 100 + GST_char_to_int( strDate[8] )*10 + GST_char_to_int( strDate[9] );
		date->tm_mon = GST_char_to_int( strDate[3] )*10 + GST_char_to_int( strDate[4] ) - 1;
		date->tm_mday = GST_char_to_int( strDate[0] )*10 + GST_char_to_int( strDate[1] );
	} else {
		//YYYYMMDD
		//01234567
		date->tm_year = 100 + GST_char_to_int( strDate[2] )*10 + GST_char_to_int( strDate[3] );
		date->tm_mon = GST_char_to_int( strDate[4] )*10 + GST_char_to_int( strDate[5] ) - 1;
		date->tm_mday = GST_char_to_int( strDate[6] )*10 + GST_char_to_int( strDate[7] );
	}
}



///Function to translate a string time
///into a time structure.
///
///@param strTime Pointer to the string time.
///@param time Pointer to the tm structure.
void cdrStrTimeToStructure( char *strTime, struct tm *time ){
	time->tm_hour = GST_char_to_int( strTime[0] )*10 + GST_char_to_int( strTime[1] );
	time->tm_min = GST_char_to_int( strTime[3] )*10 + GST_char_to_int( strTime[4] );
	time->tm_sec = GST_char_to_int( strTime[6] )*10 + GST_char_to_int( strTime[7] );
}



///Function to translate a string date time
///into a date structure.
///
///@param strDate Pointer to the string date.
///@param time Pointer to the tm structure
///@param old Flag to decide the date format
void cdrStrDateTimeToStructure( char *strTime, struct tm *time , bool old){

	if(old){
		//DD/MM/YYYY
		//01/34/6789
		time->tm_year = 100 + GST_char_to_int( strTime[8] )*10 + GST_char_to_int( strTime[9] );
		time->tm_mon = GST_char_to_int( strTime[3] )*10 + GST_char_to_int( strTime[4] ) - 1;
		time->tm_mday = GST_char_to_int( strTime[0] )*10 + GST_char_to_int( strTime[1] );

		time->tm_hour = GST_char_to_int( strTime[11] )*10 + GST_char_to_int( strTime[12] );
		time->tm_min = GST_char_to_int( strTime[14] )*10 + GST_char_to_int( strTime[15] );
		time->tm_sec = GST_char_to_int( strTime[17] )*10 + GST_char_to_int( strTime[18] );
	} else {
		//YYYYMMDD
		//01234567
		time->tm_year = 100 + GST_char_to_int( strTime[2] )*10 + GST_char_to_int( strTime[3] );
		time->tm_mon = GST_char_to_int( strTime[4] )*10 + GST_char_to_int( strTime[5] ) - 1;
		time->tm_mday = GST_char_to_int( strTime[6] )*10 + GST_char_to_int( strTime[7] );

		time->tm_hour = GST_char_to_int( strTime[9] )*10 + GST_char_to_int( strTime[10] );
		time->tm_min = GST_char_to_int( strTime[12] )*10 + GST_char_to_int( strTime[13] );
		time->tm_sec = GST_char_to_int( strTime[15] )*10 + GST_char_to_int( strTime[16] );
	}
}



///Function to translate a string phone number
///into an integer phone number.
///
///@param strPhone Pointer to the string phone number.
///@param phone Pointer to the integer phone number.
///@param max_client max_length of the client phone number
void cdrPhoneToNumber (char *line, size_t *phone, int max_client ){
	int _length_client = 0;
	int _pos = 0;
	char *_endptr;

	_length_client = strlen(line);

	if(_length_client > max_client) {
		_pos = _length_client - max_client;
	} else {
		_pos = 0;
	}

	*phone = strtoul( &(line[_pos]), &_endptr, 10 );

	if( *_endptr != '\0' ){
		*phone = 0L;
	}
}


///(TEMM specific)
///Function to translate a string mobility scope
///into an integer mobility scope.
///
///@param strMobScope Pointer to the string mobility scope.
///@param mobScope Pointer to the integer mobility scope.
void cdrStrScopeToInt_MX( char *strMobScope, size_t *mobScope ){
	unsigned int _scope;

	for( _scope=0; _scope<LOC_MOB_SCOPES_NUMBER; _scope++ ){
		if( strcmp( strMobScope, cdrScopes_MX[_scope] ) == 0 ){
			*mobScope = _scope;
			return;
		}
	}
	*mobScope = LOC_NO_INFORMADO;
}

