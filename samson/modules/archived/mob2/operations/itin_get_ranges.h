/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_mob2_itin_get_ranges
#define _H_SAMSON_mob2_itin_get_ranges


#include <samson/module/samson.h>
#include <samson/modules/mob2/ItinMovement.h>
#include <samson/modules/mob2/ItinRange.h>
#include <samson/modules/system/UInt.h>
#include <samson/modules/system/Void.h>



namespace samson{
namespace mob2{


class itin_get_ranges : public samson::Map
{
	// Inputs
	samson::system::UInt node;
	ItinMovement move;
	// Outputs
	ItinRange moveRange;
	samson::system::Double perc_moves;

public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.UInt mob2.ItinMovement
	output: mob2.ItinRange system.Double

	extendedHelp: 		Set ranges of a POIs of a client

#endif // de INFO_COMMENT

	void init(samson::KVWriter *writer )
	{
	}

	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		int diff, hourSrc, hourTgt, minutSrc, minutTgt;
		double dur;

		for(uint64_t i=0; i<inputs[0].num_kvs; i++)
		{
			node.parse(inputs[0].kvs[i]->key);
			move.parse(inputs[0].kvs[i]->value);
			moveRange.node.value = node.value;
			moveRange.poiSrc.value = move.source.bts.value;
			moveRange.poiTgt.value = move.target.bts.value;

			// Calculate portion of moves by hour
			hourSrc = move.source.time.hour.value;
			hourTgt = move.target.time.hour.value;

			if(move.source.date.week_day.value != move.target.date.week_day.value){	hourTgt += 24;}
			diff = (hourTgt - hourSrc);
			if(diff == 0) // Source hour and target hour are the same.
			{
				moveRange.range.value = move.source.time.hour.value;
				moveRange.group.value = move.source.date.week_day.value;
				perc_moves.value = 1.0;
				writer->emit(0, &moveRange,&perc_moves);
			}
			else
			{
				minutSrc = move.source.time.minute.value;
				minutTgt = move.target.time.minute.value;
				dur = (diff * 60) + (minutTgt - minutSrc);
				// Communication in source hour
				moveRange.range.value = move.source.time.hour.value;
				moveRange.group.value = move.source.date.week_day.value;
				perc_moves.value = (60 - minutSrc)/dur;
				writer->emit(0, &moveRange,&perc_moves);
				// Communication in target hour
				moveRange.range.value = move.target.time.hour.value;
				moveRange.group.value = move.target.date.week_day.value;
				perc_moves.value = minutTgt/dur;
				writer->emit(0, &moveRange,&perc_moves);
				// Fill the intermediate hours
				for(int i=1; i<diff; i++)
				{
					moveRange.range.value = move.source.time.hour.value + i;
					moveRange.group.value = move.source.date.week_day.value;
					if(moveRange.range.value > 23)
					{
						moveRange.range.value -= 24;
						moveRange.group.value ++;
					}
					perc_moves.value = 60/dur;
					writer->emit(0, &moveRange,&perc_moves);
				}
			}
			/*
        			moveRange.range = move.source.time.hour / 2;
        			moveRange.range = move.source.time.hour;
        			writer[0]->emit(&moveRange,&mr_void);
			 */
		}

	}

	void finish(samson::KVWriter *writer )
	{
	}



};


} // end of namespace mob2
} // end of namespace samson

#endif
