/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_mob2_repbts_spread_nodebts
#define _H_SAMSON_mob2_repbts_spread_nodebts


#include <samson/module/samson.h>
#include <samson/modules/mob2/NodeMx_Counter.h>
#include <samson/modules/mob2/Node_Bts_Day.h>
#include <samson/modules/system/UInt.h>

#define DEBUG_FILES
#ifdef DEBUG_FILES
#include <iostream>
#include <fstream>
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES


namespace samson{
namespace mob2{


class repbts_spread_nodebts : public samson::Map
{
	// Inputs
	samson::system::UInt nodeId;
	NodeMx_Counter counter;
	// Outputs
	Node_Bts_Day outputkey;
	samson::system::UInt ncalls;

public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.UInt mob2.NodeMx_Counter
	output: mob2.Node_Bts_Day system.UInt

	extendedHelp: 		Spread client counters by node and bts

#endif // de INFO_COMMENT

	void init(samson::KVWriter *writer )
	{
	}

	////////
	// Spread array of counters by node and bts
	////////

	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		outputkey.workday.value = 0;
		outputkey.count.value = 0; // It is not use in this step

#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
				std::string filename = "/tmp/repbts_spread_nodebts.log";
				std::ofstream fs(filename.c_str(), std::ios::app);
				fs << "inputs[0].num_kvs:" << inputs[0].num_kvs << std::endl;
				fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

		for(uint64_t i=0; i<inputs[0].num_kvs; i++)
		{
			nodeId.parse(inputs[0].kvs[i]->key);
			counter.parse(inputs[0].kvs[i]->value);

			outputkey.node.value = nodeId.value;

			for(int j=0; j<counter.bts_length; j++)
			{
				outputkey.bts.value = counter.bts[j].bts.value;
				ncalls.value = counter.bts[j].count.value;
				writer->emit(0, &outputkey,&ncalls);
			}
		}
	}

	void finish(samson::KVWriter *writer )
	{
	}



};


} // end of namespace mob2
} // end of namespace samson

#endif
