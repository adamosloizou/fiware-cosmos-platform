/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_shop_reduce_by_user_state
#define _H_SAMSON_shop_reduce_by_user_state


#include <samson/module/samson.h>
#include <samson/modules/shop/VectorProducts.h>
#include <samson/modules/system/UInt.h>

// For the operation traces
#include "samson_system/Value.h"

#include "au/string/StringUtilities.h"
#include <stdint.h>

namespace samson{
namespace shop{


	class reduce_by_user_state : public samson::Reduce
	{

	public:


//  INFO_MODULE
// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
// Please, do not remove this comments, as it will be used to check consistency on module declaration
//
//  input: system.UInt system.UInt  
//  input: system.UInt shop.VectorProducts  
//  output: system.UInt shop.VectorProducts
//  
// helpLine: Reduce example; from key-values groups the list of products by user, working in streaming with a user state
//  END_INFO_MODULE

		void init( samson::KVWriter *writer )
		{
		}

		void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
	        // Variables used to read content from the input
	        samson::system::UInt user;
	        samson::system::UInt input_product;

	        // Variables used to keep the user profile
	        samson::shop::VectorProducts products;

	        // For the traces
	        samson::system::Value trace;
	        samson::system::Value value_void;

	        value_void.SetAsVoid();

	        if (inputs[1].num_kvs == 0)
	        {
	            // No previous state for the user
	            user.parse(inputs[0].kvs[0]->key);
	            products.init();

	            // operation traces
	            trace.SetString(au::str("No profile for user:%lu", user.value).c_str());
	            writer->emit( -1 , &trace , &value_void );

	            // platform logs
	            LM_W(("No profile for user:%lu", user.value));
	        }
	        else
	        {
	            user.parse(inputs[1].kvs[0]->key);
	            // Previous state
	            // We only consider one profile of products
	            products.parse(inputs[1].kvs[0]->value);

	            if (inputs[1].num_kvs > 1)
	            {
	                // operation traces
	                trace.SetString(au::str("Multiple profiles(%lu) for user:%lu", inputs[1].num_kvs, user.value).c_str());
	                writer->emit( -1 , &trace , &value_void );

	                // platform logs
	                LM_W(("Multiple profiles(%lu) for user:%lu", inputs[1].num_kvs, user.value));
	            }
	        }

	        for (uint64_t i = 0; (i < inputs[0].num_kvs); i++)
	        {

	            input_product.parse(inputs[0].kvs[i]->value);

	            // operation traces
	            trace.SetString(au::str("Processing product %lu for user:%lu", input_product.value, user.value).c_str());
	            writer->emit( -1 , &trace , &value_void );

	            // platform logs
	            LM_M(("Processing product %lu for user:%lu", input_product.value, user.value));

	            // Just add the product to the user profile
	            // It could also be checked to have every product only once in the profile, keeping the count
	            products.productsAdd()->copyFrom(&input_product);

	        }

	        writer->emit( 0 , &user, &products);
		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace shop
} // end of namespace samson

#endif
