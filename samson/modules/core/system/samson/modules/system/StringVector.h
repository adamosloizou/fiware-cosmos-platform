/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this data
 */

#ifndef _H_SAMSON_system_StringVector
#define _H_SAMSON_system_StringVector

#include "logMsg/logMsg.h"
#include <samson/modules/system/StringVector_base.h>


namespace samson{
namespace system{


class StringVector : public StringVector_base
{

public:
	//		String& find(String strElement)
	//		{
	//			for (int i = 0; (i < values_length); i++)
	//			{
	//				if (strElement.value.compare(values[i].value))
	//				{
	//					return(values[i]);
	//				}
	//			}
	//			return(NULL);
	//		}

	int findIndex(String &strElement)
	{
		for (int i = 0; (i < values_length); i++)
		{
			if (strElement.value.compare(values[i].value) == 0)
			{
				return(i);
			}
		}
		return(-1);
	}

	int findIndexSorted(String &strElement)
	{
		for (int i = 0; (i < values_length); i++)
		{
			int ret;
			if ((ret = strElement.value.compare(values[i].value)) == 0)
			{
				return(i);
			}
			else if (ret < 0)
			{
				return (-1);
			}
		}
		return(-1);
	}

	int findIndexSortedFromEnd(String &strElement)
	{
		for (int i = values_length-1; (i >= 0); i--)
		{
			int ret;
			if ((ret = strElement.value.compare(values[i].value)) == 0)
			{
				return(i);
			}
			else if (ret < 0)
			{
				return (-1);
			}
		}
		return(-1);
	}

	int valuesAddSorted(String &strElement){
		valuesSetLength( values_length + 1 );
		for (int i = 0; (i < (values_length-1)); i++)
		{
			if (strElement.value.compare(values[i].value) <= 0)
			{
				//LM_M(("string:'%s', detected at indexInsert:%d with values_length:%d\n", strElement.value.c_str(), i, values_length));

				for (int j = (values_length-1); (j > i); j--)
				{
					values[j] = values[j-1];
				}
				values[i] = strElement;
				return i;
			}
		}
		values[values_length-1] = strElement;
		return (values_length-1);
	}

	int valuesAddSortedFromEnd(String &strElement){
		int length_orig = values_length;
		valuesSetLength( values_length + 1 );
		if ((length_orig == 0) || (strElement.value.compare(values[length_orig-1].value) >= 0))
		{
//			LM_M(("string:'%s', detected at indexInsert:%d with values_length:%d (compared to '%s')\n", strElement.value.c_str(), length_orig, values_length, values[length_orig-1].value.c_str()));

			values[length_orig] = strElement;
			return (length_orig);
		}
		for (int i = length_orig-1; (i >= 0); i--)
		{
			int ret;
			if ((ret = strElement.value.compare(values[i].value)) >= 0)
			{
				//LM_M(("string:'%s', detected at indexInsert:%d with values_length:%d with ret:%d (compared to '%s')\n", strElement.value.c_str(), i, values_length, ret, values[i].value.c_str()));

				for (int j = (length_orig); (j > i); j--)
				{
					values[j] = values[j-1];
				}
				values[i] = strElement;
				return i;
			}
			else
			{
				//LM_M(("string:'%s', compared with values[%d]:'%s' with ret:%d\n", strElement.value.c_str(), i, values[i].value.c_str(), ret));
			}
		}
		//LM_M(("string:'%s', detected at indexInsert:%d with values_length:%d\n", strElement.value.c_str(), 0, values_length));
		for (int j = (length_orig); (j > 0); j--)
		{
			values[j] = values[j-1];
		}
		values[0] = strElement;
		return (0);
	}

	int valuesAddAtIndex(String &strElement, int index){
		if (index > values_length)
		{
			return (-1);
		}
		valuesSetLength( values_length + 1 );

		for (int j = (values_length-1); (j > index); j--)
		{
			values[j] = values[j-1];
		}
		values[index] = strElement;
		return index;
	}

};


} // end of namespace samson
} // end of namespace system

#endif
