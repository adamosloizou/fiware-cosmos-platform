/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */
/**
 * File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_system_parse
#define _H_SAMSON_system_parse

#include <samson/module/samson.h>

#include "samson_system/Filter.h"
#include "samson_system/Value.h"

namespace samson {
namespace system {
class parse : public samson::Parser {
  samson::system::ValueContainer keyContainer;
  samson::system::ValueContainer valueContainer;

  // Collection of filters to execute for every key-value
  FilterCollection filters_collection;

  // Internal buffer to store line
  char *line;

public:

  //  INFO_MODULE
  // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
  // Please, do not remove this comments, as it will be used to check consistency on module declaration
  //
  //  output: system.Value system.Value
  //
  // helpLine: Parse lines with fields separated by a single char tab , space , coma , ...
  //  END_INFO_MODULE

  void init(samson::KVWriter *writer) {
    // Alloc space for the lines...
    line = (char *)malloc(20000);

    // By default, value is 1
    valueContainer.value->SetDouble(1);

    // Setup the process chain...
    std::string command = environment->get("command", "");
    au::ErrorManager error;
    filters_collection.AddFilters(command, writer, NULL, &error);

    // Error defined by user
    if (error.HasErrors()) {
      tracer->setUserError(error.GetLastError());
    }
  }

  void run(char *data, size_t length, samson::KVWriter *writer) {
    size_t offset = 0;

    while (offset < length) {
      // Parse a line
      size_t line_pos = 0;
      while ((offset < length) && data[offset] != '\n') {
        if (line_pos < (20000 - 2)) { // Limit for parsed lines
          line[line_pos++] = data[offset];
        }
        offset++;
      }
      offset++;   // Skip the '\n'
      line[line_pos] = '\0';

      // Set the key with the new string
      keyContainer.value->SetString(line);

      if (filters_collection.GetNumFilters() > 0) {
        KeyValue kv(keyContainer.value, valueContainer.value);
        filters_collection.run(kv);
      } else {
        // Emit the parsed key value
        writer->emit(0, keyContainer.value, valueContainer.value);
      }
    }
  }

  void finish(samson::KVWriter *writer) {
    free(line);
  }
};
}  // end of namespace system
}  // end of namespace samson

#endif // ifndef _H_SAMSON_system_parse
