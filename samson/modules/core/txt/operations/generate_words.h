/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_txt_generate_words
#define _H_SAMSON_txt_generate_words


#include <samson/module/samson.h>


namespace samson{
namespace txt{


	class generate_words : public samson::Generator
	{

	  // Random word generated
	  char word[1024];

	  system::String key;
	  system::UInt value;

	  // Values taken from enviroment variables
	  size_t num_samples;   // Total num samples
	  int line_length;

	  size_t worker_num_samples;  // Number of samples for this worker
	  size_t local_num_samples;   // Number of samples to be generated in this instance


	  // Information for debuggin
	  int _worker;
	  int _num_workers;
	  int _process;
          int _num_processes;

	public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

output: system.String system.UInt

helpLine: Generate 'txt.num_samples' random words. By default it generates 1M walues
#endif // de INFO_COMMENT

		void init( samson::KVWriter *writer )
		{
		  // Output keys are always value 1
		  value.value = 1;

		  num_samples = environment->getSizeT( "txt.num_samples" ,  1000000 );
		  line_length = environment->getSizeT( "txt.word_length" ,  6  );

		  if ( line_length > 1023 )
		    line_length = 1023;

		  worker_num_samples = 0;
		  local_num_samples = 0;
		}

	        void setup( int worker , int num_workers, int process , int num_processes )
		{
		  _worker = worker;
		  _num_workers = num_workers;
		  _process = process;
		  _num_processes = num_processes;

		  worker_num_samples = num_samples /  num_workers;

		  // The first worker compensates if the number of samples is not divisible by the number of workers		  
		  if( worker == 0 )
		    worker_num_samples = num_samples - ( ( num_samples / num_workers )*(num_workers -1 ));

		  local_num_samples = worker_num_samples / num_processes;

		  if ( process == 0 )
		    local_num_samples = worker_num_samples - ( (worker_num_samples / num_processes)*(num_processes-1));


		}

	  
	  

		void run( samson::KVWriter *writer )
		{

		  OLM_M(("Running generator Worker %d/%d  Process %d/%d  Samples %lu" , _worker , _num_workers , _process , _num_processes , local_num_samples ));

		  for ( size_t i = 0 ; i < local_num_samples ; i++)
		  {
		    // Generate a new random word
		    for (int c = 0 ; c < line_length ; c++ )
		      word[c] = 97 + rand()%20;
		    word[line_length]='\0';		    

		    // Get the value in the "key" variable
		    key.value = word;

		    writer->emit( 0 , &key , &value );

		  }

		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace txt
} // end of namespace samson

#endif
