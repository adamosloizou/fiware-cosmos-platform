Module txt
{
	title	"Basic txt manipulation"
	author	"Andreu Urruela"
	version "0.2"
}

data Collocation
{
	system.String w1;
	system.String w2;
}

data PairInts
{
	system.UInt i1;
	system.UInt i2;
}


data CountData
{
	system.String word;
	system.UInt count;
}

data Stripe
{
	vector txt.CountData colList;
}


parser parser_words
{
	out system.String system.UInt
	helpLine "Parse a txt files emitting words at the output (value is always one)"
}

simpleParser parser_words_alpha
{
	out system.String system.UInt
	helpLine "Parse text generating all words separated by any non-alphanumeric character"
}

map filter_words_with_numbers_and_letters
{
	in system.String system.UInt
	out system.String system.UInt

	helpLine "Filter words containing only numbers and letter (filter out words with non-printable ascii chars)"
}

map convert_to_lower_case
{
	in system.String system.UInt
	out system.String system.UInt

	helpLine "Convert to lower case. Also filter words with non-printable chars"
}

map number_letters
{
	in system.String system.Void
	out system.UInt system.Void

	helpLine "Emit the number of letters contained at each word"
}

#
# Generic parser where each line is translated into a system.String key and value is a system.UInt with value=1
#

parser parser_lines
{
	out system.String system.UInt

	helpLine "Parse a txt file emitting every line as an independent string ( return character not included )"
}

#
# Simple generator to create "txt.num_samples" random strings at the output
#

generator generate_words
{
	out system.String system.UInt

	helpLine "Generate 'txt.num_samples' random words with 'txt.word_length' chars. By default it generates 1M words with 6 letters"
}


parser parser_collocations_pairs
{
	out txt.Collocation system.UInt

	helpLine "Parse a txt file emitting collocations at the output (value is always one)"
}

parser parser_collocations_stripes
{
	out system.String txt.Stripe

	helpLine "Parse a txt file emitting words as key with a vector of collocations at the output"
}

script demo
{
    code
    {
        add_stream_operation p txt.parser_words -input input -output words;
        add_stream_operation c txt.word_count2 -input 'words state' -output state;
    }

}

reduce word_count
{
	in system.String system.UInt
	out system.String system.UInt

	helpLine "Classical example to count the words. It basically accumulates the number of times a word appear in a txt file"
}

reduce word_count2
{
	in system.String system.UInt
	in system.String system.UInt
	out system.String system.UInt

	helpLine "Reduce operation for stream processing of work_count"
}

reduce collocation_count
{
	in txt.Collocation system.UInt
	out txt.Collocation system.UInt

	helpLine "Classical example to count words collocations. It basically accumulates the number of times a collocation appears in a txt file"
}

reduce collocation_count_stripes
{
	in system.String txt.Stripe
	out system.String txt.Stripe

	helpLine "Classical example to count words collocations by stripes. It basically accumulates the number of times a collocation appears in a txt file"
}

reduce word_count_accumulate
{
	in system.String system.UInt	# Incomming data
	in system.String system.UInt	# State
	out system.String system.UInt	# Future State

	helpLine "Accumulation function of work count."
}

#
# Simple parserOut to export strings contained as "key" and it companion number as value
#

parserOut export_words
{
	in system.String system.UInt

	helpLine "Export words"
}

parserOut export_collocations
{
	in txt.Collocation system.UInt

	helpLine "Export collocations and counter"	
}

parserOut export_collocations_stripes
{
	in system.String txt.Stripe

	helpLine "Export collocations and counter with stripe strategy"	

}
