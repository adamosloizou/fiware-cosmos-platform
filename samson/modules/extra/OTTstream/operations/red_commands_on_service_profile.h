
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_OTTstream_red_commands_on_service_profile
#define _H_SAMSON_OTTstream_red_commands_on_service_profile


#include <samson/module/samson.h>
#include <samson/modules/OTTstream/ActivityByService.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/UInt.h>

#include "logMsg/logMsg.h"


namespace samson{
namespace OTTstream{


class red_commands_on_service_profile : public samson::Reduce
{

    samson::OTTstream::ActivityByService activity;
    samson::system::UInt serviceId;
    samson::system::String command;


public:


    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: system.UInt system.String
    //  input: system.UInt OTTstream.ActivityByService
    //  output: system.UInt OTTstream.UserActivity
    //
    // helpLine: Update the latest user profile
    //  END_INFO_MODULE

    void init( samson::KVWriter *writer )
    {
    }

    void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
    {
        if (inputs[0].num_kvs == 0)
        {
            // No command
            if (inputs[1].num_kvs > 0)
            {
                serviceId.parse( inputs[1].kvs[0]->key );
                LM_W(("No command to process on serviceId:%lu", serviceId.value));
            }
            else
            {
                LM_W(("No command to process"));
            }

            return;
        }

        if (inputs[1].num_kvs == 0)
        {
            // No service activity
            if (inputs[0].num_kvs > 0)
            {
                serviceId.parse( inputs[0].kvs[0]->key );
                LM_W(("No state to process command on serviceId:%lu", serviceId.value));
            }
            else
            {
                LM_W(("No state to process command"));
            }
            return;
        }

        activity.parse( inputs[1].kvs[0]->value ); // We only consider one state
        serviceId.parse( inputs[1].kvs[0]->key );

        // First, we estimate the "now" time with the newest activity
        time_t newest_time = 0;
        if (inputs[0].num_kvs > 0)
        {
            for (int j = 0; (j < activity.user_activity_length); j++)
            {
                if (activity.user_activity[j].last_timestamp.value > newest_time)
                {
                    newest_time = activity.user_activity[j].last_timestamp.value;
                }
            }
            samson::system::TimeUnix tprint;
            tprint.value = newest_time;
            LM_M(("From state, newest_time:%s", tprint.str().c_str()));
        }

        LM_M(("Processing %lu commands on service:%lu, newest_time:'%s'", inputs[0].num_kvs, serviceId.value, ctime(&newest_time)));
        for (uint64_t i = 0; (i < inputs[0].num_kvs); i++)
        {
            command.parse(inputs[0].kvs[i]->value);

            LM_M(("Command:'%s' on service:%lu", command.value.c_str(), serviceId.value));

            char command_name[256];
            int time_window = 0;
            int min_count = 0;
            int clusterId=-1;

            if (sscanf(command.value.c_str(), "%s time_window=%d min_count=%d clusterId=%d", command_name, &time_window, &min_count, &clusterId) != 4)
            {
                if ((sscanf(command.value.c_str(), "%s time_window=%d min_count=%d", command_name, &time_window, &min_count) != 3) && (sscanf(command.value.c_str(), "%s time_window=%d  clusterId=%d", command_name, &time_window, &clusterId) != 3))
                {
                    if (sscanf(command.value.c_str(), "%s time_window=%d", command_name, &time_window) != 2)
                    {
                        LM_W(("Ignoring command with wrong format:'%s'", command.value.c_str()));
                        continue;
                    }
                }
            }

            LM_M(("Detected command:'%s, with time_window:%d, min_count:%d and clusterId:%d on serviceId:%li", command_name, time_window, min_count, clusterId, serviceId.value));

            //LM_M(("Checking command for serviceId:%lu with %d entries", serviceId.value, activity.user_activity_length));
            for (int j = 0; (j < activity.user_activity_length); j++)
            {
                if (strcmp(command_name, "NEWER") == 0)
                {
                    LM_M(("Checking NEWER for user:%lu with timestamp:%lu, (newest_time - time_window):%lu", activity.user_activity[j].user.userId.value, activity.user_activity[j].last_timestamp.value, (newest_time - time_window)));
                    if ((activity.user_activity[j].last_timestamp.value > (newest_time - time_window)) && (activity.user_activity[j].count.value > static_cast<unsigned long>(min_count)) && ((clusterId == -1) || (clusterId == static_cast<int>(activity.user_activity[j].user.clusterId.value))))
                    {
                        LM_M(("Emit service:%lu userId:%lu", serviceId.value, activity.user_activity[j].user.userId.value));
                        writer->emit(0, &serviceId, &(activity.user_activity[j]));
                    }
                }
                else if (strcmp(command_name, "OLDER") == 0)
                {
                    LM_M(("Checking OLDER for user:%lu with timestamp:%lu, (newest_time - time_window):%lu", activity.user_activity[j].user.userId.value, activity.user_activity[j].last_timestamp.value, (newest_time - time_window)));
                    if ((activity.user_activity[j].last_timestamp.value < (newest_time - time_window)) && (activity.user_activity[j].count.value > static_cast<unsigned long>(min_count)) && ((clusterId == -1) || (clusterId == static_cast<int>(activity.user_activity[j].user.clusterId.value))))
                    {
                        LM_M(("Emit serviceId:%lu userId:%lu", serviceId.value, activity.user_activity[j].user.userId.value));
                        writer->emit(0, &serviceId, &(activity.user_activity[j]));
                    }
                }
                else
                {
                    LM_E(("Unknown command:'%s' for serviceId:%lu", command_name, serviceId.value));
                    break;
                }
            }
        }
        //LM_M(("Ended processing %lu commands on service:%lu", inputs[0].num_kvs, serviceId.value));
    }

    void finish( samson::KVWriter *writer )
    {
    }



};


} // end of namespace OTTstream
} // end of namespace samson

#endif
