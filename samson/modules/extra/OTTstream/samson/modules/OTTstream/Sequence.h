
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this data
*/

#ifndef _H_SAMSON_OTTstream_Sequence
#define _H_SAMSON_OTTstream_Sequence


#include <samson/modules/OTTstream/Sequence_base.h>


namespace samson{
namespace OTTstream{


	class Sequence : public Sequence_base
	{

public:
	    enum  { CLONE_NEVER = 0, CLONE_DISABLED, CLONE_ENABLED };

	    void Init(int seqId, const char *seq_name, unsigned long time_window_par, const char *events_str, int strict_par)
	    {
            sequenceId.value = seqId;
            sequence_name.value = seq_name;
            time_window.value = time_window_par;
            strict.value = strict_par;
            cloned.value = 0;
            clonable.value = CLONE_DISABLED;
            next_event_to_fulfill.value = 0;
            eventsSetLength(0);
            char *p_events = strdup(events_str);
            char *p_next_event = p_events;
            char *p_sep = NULL;
            while ((p_sep = strchr(p_next_event, ',')) != NULL)
            {
                *p_sep = '\0';
                samson::OTTstream::SeqComponent *event = eventsAdd();
                event->expected_serviceId.value = atoi(p_next_event);
                event->timestamp.value = 0;
                event->fulfilled.value = 0;
                p_next_event = p_sep+1;
            }
            samson::OTTstream::SeqComponent *event = eventsAdd();
            event->expected_serviceId.value = atoi(p_next_event);
            event->timestamp.value = 0;
            event->fulfilled.value = 0;
            free(p_events);
	    }

	    void Clone(samson::OTTstream::Sequence *ref_sequence)
	    {
	        LM_M(("Cloning sequence with ref_sequence->events_length:%d", ref_sequence->events_length));
            sequenceId.value = ref_sequence->sequenceId.value;
            sequence_name.value = ref_sequence->sequence_name.value;
            time_window.value = ref_sequence->time_window.value;
            cloned.value = 1;
            strict.value = ref_sequence->strict.value;
            clonable.value = CLONE_NEVER;
            next_event_to_fulfill.value = 0;
            eventsSetLength(0);
            for (int k = 0; (k < ref_sequence->events_length); k++)
            {
                samson::OTTstream::SeqComponent *event = eventsAdd();
                event->expected_serviceId.value = ref_sequence->events[k].expected_serviceId.value;
                event->timestamp.value = 0;
                event->fulfilled.value = 0;
                LM_M(("Cloned event %d of %d, with serviceId:%lu", k, ref_sequence->events_length, event->expected_serviceId.value));
            }
            LM_M(("Cloning sequence with ref_sequence->events_length:%d and events_length:%d", ref_sequence->events_length, events_length));
	    }

	    void Reset()
	    {
	        clonable.value = CLONE_DISABLED;
	        next_event_to_fulfill.value = 0;
            for (int k = 0; (k < events_length); k++)
            {
                events[k].fulfilled.value = 0;
                events[k].timestamp.value = 0;
            }
	    }


bool CheckEventInSequence(samson::OTTstream::ServiceHit *hit)
{

    return true;
}
	};


} // end of namespace samson
} // end of namespace OTTstream

#endif
