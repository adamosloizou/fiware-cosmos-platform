
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_c4_process
#define _H_SAMSON_c4_process
#include "logMsg/logMsg.h"

#include <samson/module/samson.h>
#include <samson/modules/c4/Board.h>
#include <samson/modules/c4/Info.h>
#include <samson/modules/c4/Message.h>


namespace samson{
namespace c4{


	class process : public samson::Reduce
	{

	   samson::c4::Board board; 		   // SAMSON Board data
	   samson::c4::Info info;              // Information about this board

	   au::c4::Board current_board;        // Analysis of the current board
	   au::c4::Board next_boards[7];       // Vector of possible movements
	   size_t next_boards_size;
	public:


//  INFO_MODULE
// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
// Please, do not remove this comments, as it will be used to check consistency on module declaration
//
//  input: c4.Board c4.Message  
//  input: c4.Board c4.Info  
//  output: c4.Board c4.Message
//  output: c4.Board c4.Info
// 
//  END_INFO_MODULE

		void init( samson::KVWriter *writer )
		{
		}

		void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
		   //printf("Processing key-values %lu %lu\n" , inputs[0].num_kvs , inputs[1].num_kvs );

		   // ------------------------------------------------------------------
		   // Get Board
		   // ------------------------------------------------------------------

		   if( inputs[1].num_kvs > 0 )
              board.parse( inputs[1].kvs[0]->key );
            else
              board.parse( inputs[0].kvs[0]->key );

		   // Internal structure to analyse better current board
		   current_board.SetBoard( board.white.value , board.black.value );

		   // Get future boards with all movements
		   next_boards_size = current_board.GetNextBoards( board.turn.value , next_boards );

		   // ------------------------------------------------------------------
		   // Get previous info or analyse board
		   // ------------------------------------------------------------------
 
		   if( inputs[1].num_kvs > 0 ){
			  info.parse( inputs[1].kvs[0]->value ); 			  // There is a previous board here
		   }
		   else
		   {
			  // New info structure
			  info.reset();

			  // Check for direct winners
			  for ( size_t i = 0 ; i < next_boards_size ; i++ )
				 info.movement[i].value = next_boards[i].GetWinner();

			  // Compute final result based on particals
			  review( );

			  // If the result is unknown, I sent forward message to new boards
			  if( info.winner.value == C4_NONE )
			  {
				 for ( size_t i = 0 ; i < next_boards_size ; i++ )
				 {
					samson::c4::Board forward_board;
					forward_board.white.value = next_boards[i].white_value();
					forward_board.black.value = next_boards[i].black_value();
					forward_board.turn.value = -board.turn.value; // It is the other turn

					samson::c4::Message message;
					message.type.value = 1; // Forward message
					message.board.copyFrom( &board );

					writer->emit( 0 , &forward_board , &message );												

				 }
			  }

		   }

		   // Process messages
		   samson::c4::Message message;
		   for ( size_t i = 0 ; i < inputs[0].num_kvs ; i++ )
		   {
			  message.parse( inputs[0].kvs[i]->value );

			  if( message.type.value == 1 )
			  {
				 // Forward message: another board is requesting our solution
				 // add to the vector of boards to be answered
				 samson::c4::Board* tmp_board = info.boardsAdd();
				 tmp_board->copyFrom( &message.board );
			  }
			  else if( message.type.value == 2 )
			  {
				 // Response message: another board is answering our demand of solution
				 for ( int i = 0 ; i < (int)next_boards_size ; i++ )
				 {
					if( next_boards[i].white_value() != message.board.white.value )
					   continue;
					if( next_boards[i].black_value() != message.board.black.value )
					   continue;

					// Set the solution 
					info.movement[ i ] = message.winner;
					break;
				 }
			  }
		   }		

		   // Review board ( based on new information, if any... )
		   review();

		   // If board is revolved, send message back to pending boards and remove them
		   if( info.winner.value != C4_NONE )
		   {
			  for ( int i = 0 ; i < info.boards_length ; i++ )
			  {
				 samson::c4::Message message;
				 message.type.value = 2;                       // Response message
				 message.winner.value = info.winner.value;     // Winner of this board
				 message.board.copyFrom( &board );             // this board
				 
				 writer->emit( 0 , &info.boards[i] , &message );
			  }
			  info.boardsSetLength(0); // Remove vector of pending boards
		   }

		   // Emit current state (always) at the output
		   writer->emit(1,&board,&info);

		}

		void review(  )
		{
		   // If one movement is winner, I win
		   for (size_t i = 0 ; i < next_boards_size  ; i++ )
			  if( info.movement[i].value == board.turn.value )
			  {
				 info.winner.value = board.turn.value; // me
				 return;
			  }

		   // If Any is unknown, still unknown ( there is hope... )
		   for (size_t i = 0 ; i < next_boards_size  ; i++ )
			  if( info.movement[i].value == C4_NONE )
			  {
				 info.winner.value = C4_NONE;
				 return;
			  }

		   // If any is DRAW, it is DRAW ( best possibiliy for us now... )
		   for (size_t i = 0 ; i < next_boards_size  ; i++ )
			  if( info.movement[i].value == C4_DRAW )
			  {
				 info.winner.value = C4_DRAW;
				 return;
			  }

		   // I have no option, so I lost
		   info.winner.value = -board.turn.value;
		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace c4
} // end of namespace samson

#endif
