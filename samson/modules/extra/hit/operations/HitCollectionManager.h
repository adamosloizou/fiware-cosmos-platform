/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_HitCollectionManager
#define _H_SAMSON_HitCollectionManager


#include <samson/module/samson.h>
#include <samson/modules/hit/common.h>
#include <samson/modules/hit/Hit.h>
#include <samson/modules/hit/HitCollection.h>
#include <samson/modules/system/String.h>


namespace samson{
namespace hit{


   class HitCollectionManager
   {

   public:

	  std::string concept;	  
	  samson::hit::Hit** top_hits;

	  time_t reference_time_stamp;
	  size_t time_span;
	  double forgetting_factor;    //computable from time_span, but stored for efficiency
	  
	  HitCollectionManager( std::string _concept , size_t _time_span, double _forgetting_factor )
	  {
		 concept = _concept;
		 time_span = _time_span;

		 reference_time_stamp = 0; // Init with 0 to make sure it is updated the first time
		 forgetting_factor = _forgetting_factor;
		 top_hits = (samson::hit::Hit**) malloc( sizeof(samson::hit::Hit*) * NUM_TOP_ITEMS );
		 
		 for( int i = 0 ; i < NUM_TOP_ITEMS ; i++ )
		 {
			top_hits[i] = new samson::hit::Hit();	   
			top_hits[i]->init(  );
		 }
		 
	  }
	  
	   ~HitCollectionManager()
	   {
		  for( int i = 0 ; i < NUM_TOP_ITEMS ; i++ )
             delete top_hits[i];
		  free( top_hits );
	   }


	   void setTime( time_t new_reference_time_stamp  )
	   {
		  for( int i = 0 ; i < NUM_TOP_ITEMS ; i++ )
			 top_hits[i]->setTime( new_reference_time_stamp, forgetting_factor );

		  reference_time_stamp = new_reference_time_stamp;
	   }

	   void add( samson::hit::Hit *hit  )
	   {
		  
		  // Adjust time
		  if ( hit->time.value > reference_time_stamp )
			 setTime( hit->time.value );
		  else
			 hit->setTime( reference_time_stamp, forgetting_factor );


		  if( hit->count.value < top_hits[NUM_TOP_ITEMS-1]->count.value )
			 return;

		  // Check if we had this concept before, so just update the total accumulated
		  for (int i = 0 ; i < NUM_TOP_ITEMS ; i++ )
			 if( top_hits[i]->concept.value == hit->concept.value )
			 {				
    		     top_hits[i]->count.value = hit->count.value;				

				 // Reorder if necessary
				 while( ( i > 0 ) && ( top_hits[i]->count.value > top_hits[i-1]->count.value ) )
				 {
		 			 samson::hit::Hit* tmp_hit = top_hits[i];
	    			 top_hits[i] =  top_hits[i-1];
					 top_hits[i-1] =  tmp_hit;

					 i--;
				 }

				 while( ( i <= (NUM_TOP_ITEMS-2) ) && ( top_hits[i]->count.value < top_hits[i+1]->count.value ) )
				 {
		 			 samson::hit::Hit* tmp_hit = top_hits[i];
	    			 top_hits[i] =  top_hits[i+1];
					 top_hits[i+1] =  tmp_hit;

					 i++;
				 }

		  		 return;
			 }

		  // Just look for the right place to update
		  int pos = 0;
		  while( ( pos < NUM_TOP_ITEMS ) && (top_hits[pos]->count.value > hit->count.value ) )
			 pos++;

		  if ( pos < NUM_TOP_ITEMS )
		  {
			 // Reserve the last one
			 samson::hit::Hit* tmp_hit = top_hits[ NUM_TOP_ITEMS - 1 ];

			 // Move necessary elements
			 for( int i = NUM_TOP_ITEMS-1 ; i >= pos ; i-- )
				top_hits[i] =  top_hits[i-1];
			 
			 // Put in place with updated values
			 top_hits[pos] = tmp_hit;
			 top_hits[pos]->copyFrom( hit );

		  }


	   }

	   
	   void emit_hits( samson::KVWriter* writer )
	   {
		  samson::system::String top_concept;
		  top_concept.value = concept;

		  for (int i = 0 ; i < NUM_TOP_ITEMS ; i++ )
			 if( top_hits[i]->count.value > 0 )
			 {
				top_concept.value = concept;
				writer->emit( 0 , &top_concept , top_hits[i] );
			 }
	   }

   };


   class MultiHitCollectionManager
   {

	  std::vector<HitCollectionManager*> managers;
	  size_t time_span;
	  double forgetting_factor;    //computable from time_span, but stored for efficiency

   public:

	  MultiHitCollectionManager()
	  {
		 time_span = 300; // Default value
		 forgetting_factor = ((double)(time_span - 1)) / ((double) time_span);
	  }

	  void setTimeSpan( size_t _time_span, double _forgetting_factor )
	  {
		 time_span = _time_span;
		 forgetting_factor = _forgetting_factor;
	  }

	  void add( samson::hit::Hit *hit )
	  {
		 std::string category = hit->getCategory();
		 add( category.c_str() , hit ); 
	  }

	  void add( const char * concept , Hit* hit )
	  {

          // Just look for the rigth collection
		 for ( size_t i = 0 ; i < managers.size() ; i++ )
		 {
			if( managers[i]->concept == concept )
			{
			   managers[i]->add( hit );
			   return;
			}
		 }

		 // Create a new one at the end
		 HitCollectionManager*manager = new HitCollectionManager( concept , time_span, forgetting_factor );
		 manager->add( hit  );
		 managers.push_back( manager );

	  }

	  void emit_hits( samson::KVWriter* writer )
	  {
		 for ( size_t i = 0 ; i < managers.size() ; i++ )
			managers[i]->emit_hits( writer );
	  }

	  

   };
 

} // end of namespace hit
} // end of namespace samson

#endif
