
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_webp_map_comscore_lookup
#define _H_SAMSON_webp_map_comscore_lookup


#include <samson/module/samson.h>
#include <samson/modules/system/String.h>
#include <samson/modules/webp/Log.h>
#include "samson_system/Value.h"
#include "comscore/SamsonComscoreDictionary.h"


namespace samson{
namespace webp{


	class map_comscore_lookup : public samson::Map
	{
        samson::system::String trace;
        samson::system::Void value_void;

        samson::system::Value key;
        samson::system::Value value;
        
        samson::comscore::SamsonComscoreDictionary samson_comscore_dictionary;

	public:


//  INFO_MODULE
// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
// Please, do not remove this comments, as it will be used to check consistency on module declaration
//
//  input: system.Value system.Value  
//  output: system.Value system.Value
//  
//  extendedHelp: 		Lookup url agains the conscore_dictionary. Input is suppoused to be a map with url property as a string. categories property set at the output
// 
//  END_INFO_MODULE

		void init( samson::KVWriter *writer )
		{
            samson_comscore_dictionary.read( "/var/comscore/samson_comscore_dictionary.bin" );
		}

		void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
		   for ( size_t i = 0 ; i < inputs[0].num_kvs ; i++ )
		   {
			  key.parse( inputs[0].kvs[i]->key );
			  value.parse( inputs[0].kvs[i]->value );
               
               
               if ( !key.isMap() )
               {
                   trace.value = "Key is not a map";
                   writer->emit( -1 , &trace , &value_void );
                   continue;
               }

               samson::system::Value* url = key.get_value_from_map( "url" );
               if( !url )
               {
                   trace.value = "url is not present in the key ( a map )";
                   writer->emit( -1 , &trace , &value_void );
                   continue;
               }

               if( !url->isString() )
               {
                   trace.value = "url is not a string";
                   writer->emit( -1 , &trace , &value_void );
                   continue;
               }
               
               // Get categories
               std::vector<uint> categories_ids = samson_comscore_dictionary.getCategories( url->get_string().c_str() );

               if( categories_ids.size() > 0 )
               {
                   // For each category
                   samson::system::Value* categories = key.add_value_to_map( "categories" );
                   categories->set_as_vector();
                   
                   for ( size_t i = 0 ; i < categories_ids.size() ; i++ )
                   {
                       std::string name = samson_comscore_dictionary.getCategoryName( categories_ids[i] );
                       
                       // Create a element [ id name ]
                       samson::system::Value * cat = categories->add_value_to_vector();
                       cat->set_as_vector();
                       
                       cat->add_value_to_vector()->set_double( categories_ids[i] );
                       cat->add_value_to_vector()->set_string( name );
                   }
               }
               
               writer->emit( 0 , &key , &value );
               
		   }

		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace webp
} // end of namespace samson

#endif
