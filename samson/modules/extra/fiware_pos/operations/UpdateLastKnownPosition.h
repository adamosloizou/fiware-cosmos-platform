/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_fiware_pos_UpdateLastKnownPosition
#define _H_SAMSON_fiware_pos_UpdateLastKnownPosition

#include <samson/module/samson.h>
#include <samson/modules/fiware_pos/Sensor.h>
#include <samson/modules/fiware_pos/SensorTick.h>
#include <samson/modules/fiware_pos/UserTick.h>
#include <samson/modules/system/UInt.h>

#include "logMsg/logMsg.h"

namespace samson {
namespace fiware_pos {

class UpdateLastKnownPosition : public samson::Reduce {

  public:

    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: system.UInt fiware_pos.SensorTick
    //  input: system.UInt fiware_pos.SensorTick
    //  output: system.UInt fiware_pos.PosAndUserTick
    //  output: system.UInt fiware_pos.SensorTick
    //
    // helpLine: Reduce with state to keep the last known position per user
    //  END_INFO_MODULE

    void init(samson::KVWriter *writer) {
    }

    void run(samson::KVSetStruct* inputs, samson::KVWriter *writer) {
      bool first_position = false;
      if (inputs[1].num_kvs == 0) {
        user_id_.parse(inputs[0].kvs[0]->key);
        first_position = true;
      } else {
        user_id_.parse(inputs[1].kvs[0]->key);
        // Previous state
        last_sensor_.parse(inputs[1].kvs[0]->value); // We only consider one state

        if (inputs[1].num_kvs > 1) {
          LM_W(("Multiple last position(%lu) for user_id:%lu", inputs[1].num_kvs, user_id_.value));
        }
      }

      // If we could be sure that values are sorted, we could force them
      // to be sorted by timestamp

      for (uint64_t i = 0; i < inputs[0].num_kvs; ++i) {
        sensor_tick_.parse(inputs[0].kvs[i]->value);
        pos_user_tick_.user_tick.user_id.value = user_id_.value;
        pos_user_tick_.user_tick.timestamp.value = sensor_tick_.timestamp.value;
        pos_user_tick_.position.copyFrom(&(sensor_tick_.sensor.position));

        if (first_position) {
          first_position = false;
          pos_user_tick_.user_tick.incoming.value = 1;
          writer->emit(0, &(sensor_tick_.sensor.id), &pos_user_tick_);
          //LM_M(("Emit user_id:%lu incoming:%d to sensor:%lu", pos_user_tick_.user_tick.user_id.value, pos_user_tick_.user_tick.incoming.value, sensor_tick_.sensor.id.value));
          last_sensor_.copyFrom(&sensor_tick_);
        } else if (sensor_tick_.timestamp.value > last_sensor_.timestamp.value) {
          if (sensor_tick_.sensor.id.value == last_sensor_.sensor.id.value) {
            pos_user_tick_.user_tick.incoming.value = 1;
            writer->emit(0, &(sensor_tick_.sensor.id), &pos_user_tick_);
            //LM_M(("Emit user_id:%lu incoming:%d to sensor:%lu", pos_user_tick_.user_tick.user_id.value, pos_user_tick_.user_tick.incoming.value, sensor_tick_.sensor.id.value));
            last_sensor_.timestamp.value = pos_user_tick_.user_tick.timestamp.value;
          } else {
            // We know position is wrong for sensor leaving ticks, but we won't use it
            pos_user_tick_.user_tick.incoming.value = 0;
            writer->emit(0, &(last_sensor_.sensor.id), &pos_user_tick_);
            //LM_M(("Emit user_id:%lu incoming:%d to sensor:%lu", pos_user_tick_.user_tick.user_id.value, pos_user_tick_.user_tick.incoming.value, last_sensor_.sensor.id.value));
            last_sensor_.copyFrom(&sensor_tick_);
            pos_user_tick_.user_tick.incoming.value = 1;
            writer->emit(0, &(last_sensor_.sensor.id), &pos_user_tick_);
            //LM_M(("Emit user_id:%lu incoming:%d to sensor:%lu", pos_user_tick_.user_tick.user_id.value, pos_user_tick_.user_tick.incoming.value, last_sensor_.sensor.id.value));
          }
        }
      }

      writer->emit(1, &user_id_, &last_sensor_);
    }

    void finish(samson::KVWriter *writer) {
    }

  private:
    samson::system::UInt user_id_;
    samson::fiware_pos::PosAndUserTick pos_user_tick_;
    samson::fiware_pos::SensorTick sensor_tick_;
    samson::fiware_pos::SensorTick last_sensor_;
};

} // end of namespace fiware_pos
} // end of namespace samson

#endif
