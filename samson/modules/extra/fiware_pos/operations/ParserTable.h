/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_fiware_pos_ParserTable
#define _H_SAMSON_fiware_pos_ParserTable

#include <samson/module/samson.h>
#include <samson/modules/fiware_pos/Position.h>
#include <samson/modules/system/SimpleParser.h>
#include <samson/modules/system/UInt.h>

#include "logMsg/logMsg.h"

namespace samson {
namespace fiware_pos {

class ParserTable : public samson::system::SimpleParser {

  public:

    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  output: system.UInt fiware_pos.Position
    //
    // helpLine: Parse table of sensor positions as 'sensorId|posX,posY' and emits position per sensorId
    //  END_INFO_MODULE

    void init(samson::KVWriter *writer) {
      sep_ = '|';
      sep_pos_ = ',';
    }

    void parseLine(char * line, samson::KVWriter *writer) {
      split_in_words(line, fields_, sep_);

      if (fields_.size() != 2) {
        LM_W(("Wrong number of fields(%lu) != (%d) in line:'%s'", fields_.size(), 3, line));
        return;
      }

      char *endptr;
      sensor_id_.value = strtoul(fields_[0], &endptr, 10 );
      if (*endptr != '\0') {
        LM_W(("Wrong sensor_id:'%s'", fields_[0]));
        return;
      }

      split_in_words(fields_[1], fields_pos_, sep_pos_);
      if (fields_pos_.size() != 2) {
        LM_W(("Wrong number of position fields(%lu) != (%d) in line:'%s'", fields_pos_.size(), 2, fields_[1]));
        return;
      }

      sensor_position_.posX.value = strtoul(fields_pos_[0], &endptr, 10 );
      if (*endptr != '\0') {
        LM_W(("Wrong posX:'%s'", fields_pos_[0]));
        return;
      }
      sensor_position_.posY.value = strtoul(fields_pos_[1], &endptr, 10 );
      if (*endptr != '\0') {
        LM_W(("Wrong posY:'%s'", fields_pos_[1]));
        return;
      }
      writer->emit(0, &sensor_id_, &sensor_position_);
    }

    void finish(samson::KVWriter *writer) {
    }

  private:
    samson::fiware_pos::Position sensor_position_;
    samson::system::UInt sensor_id_;

    std::vector<char*> fields_;
    char sep_;
    std::vector<char*> fields_pos_;
    char sep_pos_;
};

} // end of namespace fiware_pos
} // end of namespace samson

#endif
