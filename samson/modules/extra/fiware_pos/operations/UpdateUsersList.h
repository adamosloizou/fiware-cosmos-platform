/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_fiware_pos_UpdateUsersList
#define _H_SAMSON_fiware_pos_UpdateUsersList

#include <samson/module/samson.h>
#include <samson/modules/fiware_pos/Sensor.h>
#include <samson/modules/fiware_pos/SensorTick.h>
#include <samson/modules/fiware_pos/Users.h>
#include <samson/modules/fiware_pos/UserTick.h>
#include <samson/modules/system/UInt.h>

#include "logMsg/logMsg.h"

namespace samson {
namespace fiware_pos {

class UpdateUsersList : public samson::Reduce {

  public:

    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: system.UInt fiware_pos.PosAndUserTick
    //  input: system.UInt fiware_pos.PosAndUsers
    //  output: fiware_pos.TimeSensor fiware_pos.PosAndUsers
    //  output: system.UInt fiware_pos.PosAndUsers
    //
    // helpLine: Reduce with state to keep the list of users per sensor
    //  END_INFO_MODULE

    void init(samson::KVWriter *writer) {
    }

    void run(samson::KVSetStruct* inputs, samson::KVWriter *writer) {
      if (inputs[1].num_kvs == 0) {
        sensor_.parse(inputs[0].kvs[0]->key);
        pos_users_.Init();
      } else {
        sensor_.parse(inputs[1].kvs[0]->key);
        // Previous state
        pos_users_.parse(inputs[1].kvs[0]->value); // We only consider one state

        if (inputs[1].num_kvs > 1) {
          LM_W(("Multiple states(%lu) for sensor:%lu", inputs[1].num_kvs, sensor_.value));
        }
      }

      std::vector<size_t> deleted_users;

      last_timestamp_.value = 0;

      for (uint64_t i = 0; i < inputs[0].num_kvs; ++i) {
        pos_user_tick_.parse(inputs[0].kvs[i]->value);
        pos_users_.position.copyFrom(&(pos_user_tick_.position));
        bool skip_user_tick = false;

        if (pos_user_tick_.user_tick.timestamp.value > last_timestamp_.value)
        {
          last_timestamp_.value = pos_user_tick_.user_tick.timestamp.value;
        }

        for (uint64_t j = 0; ((j < deleted_users.size()) && !skip_user_tick); ++j) {
          if ((pos_user_tick_.user_tick.incoming.value == 1) && (pos_user_tick_.user_tick.user_id.value == deleted_users[j])) {
            deleted_users.erase(deleted_users.begin()+j);
            skip_user_tick = true;
          }
        }
        if (skip_user_tick) {
          continue;
        }

        bool user_found = false;
        for (int j = 0; ((j < pos_users_.users.user_ticks_length) && !user_found); ++j) {
          if (pos_user_tick_.user_tick.user_id.value == pos_users_.users.user_ticks[j].user_id.value) {
            if (pos_user_tick_.user_tick.timestamp.value > pos_users_.users.user_ticks[j].timestamp.value) {
              if (pos_user_tick_.user_tick.incoming.value == 1) {
                pos_users_.users.user_ticks[j].timestamp.value = pos_user_tick_.user_tick.timestamp.value;
              } else {
                pos_users_.users.RemoveUser(j);
              }
            } else {
              //LM_W(("user_id:%lu with timestamp(%lu) < last(%lu) and incoming:%d", pos_user_tick_.user_tick.user_id.value, pos_user_tick_.user_tick.timestamp.value, pos_users_.users.user_ticks[j].timestamp.value, pos_user_tick_.user_tick.incoming.value));
            }
            user_found = true;
          }
        }
        if (!user_found)
        {
          if (pos_user_tick_.user_tick.incoming.value == 1) {
            pos_users_.users.AddUser(pos_user_tick_.user_tick);
          } else {
            deleted_users.push_back(pos_user_tick_.user_tick.user_id.value);
          }
        }
      }

      if (deleted_users.size() != 0) {
        for (uint64_t j = 0; (j < deleted_users.size()); ++j) {
          LM_E(("Error. Missing preposterous incomings for user_id:%lu for sensor:%lu", deleted_users[j], sensor_.value));
        }
      }

      // Emit kv pairs for the export to mongo operation
      time_sensor_.sensor_id.value = sensor_.value;
      time_sensor_.time.value = last_timestamp_.value;
      writer->emit(0, &time_sensor_, &pos_users_);

      // Update the state
      writer->emit(1, &sensor_, &pos_users_);
    }

    void finish(samson::KVWriter *writer) {
    }

  private:
    samson::fiware_pos::PosAndUserTick pos_user_tick_;
    samson::system::UInt sensor_;
    samson::fiware_pos::PosAndUsers pos_users_;
    samson::system::TimeUnix last_timestamp_;
    samson::fiware_pos::TimeSensor time_sensor_;
};

} // end of namespace fiware_pos
} // end of namespace samson

#endif
