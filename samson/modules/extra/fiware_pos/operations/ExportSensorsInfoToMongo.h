/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_fiware_pos_ExportSensorsInfoToMongo
#define _H_SAMSON_fiware_pos_ExportSensorsInfoToMongo

#include <samson/module/samson.h>
#include <samson/modules/fiware_pos/PosAndUsers.h>
#include <samson/modules/system/UInt.h>

#include <mongo/client/dbclient.h>
#include <mongo/client/dbclientcursor.h>

#include "logMsg/logMsg.h"

static int grandTotalInserts = 0;

namespace samson {
namespace fiware_pos {

class ExportSensorsInfoToMongo : public samson::Map {
    std::string mongo_ip;
    std::string mongo_db;
    std::string mongo_collection;

    int mongo_history;
    int mongo_lkl_fill;
    int mongo_bulksize;

    std::string mongo_db_path;
    mongo::DBClientConnection* mdbConnection;

    std::vector<mongo::BSONObj>  dataVec;
    int inserts;

    int records;
    int runs;

    samson::fiware_pos::TimeSensor key;
    samson::fiware_pos::PosAndUsers value;

  public:

    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: fiware_pos.TimeSensor fiware_pos.PosAndUsers
    //
    // helpLine: Export the list of users per sensor to mongoDB
    //  END_INFO_MODULE

    void init(samson::KVWriter *writer) {
      std::string bulksize;
      std::string history;
      std::string lkl_fill;

      mdbConnection = NULL;

      bulksize = environment->get("mongo.bulksize", "5000");
      lkl_fill = environment->get("mongo.lkl_fill", "0");

      mongo_ip = environment->get("mongo.ip", "no-mongo-ip");
      mongo_db = environment->get("mongo.db", "no-mongo-db");
      mongo_collection = environment->get("mongo.collection", "no-mongo-collection");

      mongo_bulksize = atoi(bulksize.c_str());

      LM_M(("Operation [START] "));

      if (mongo_ip == "no-mongo-ip") {
        tracer->setUserError("No mongo ip specified. Please specify it with 'mongo.ip' environment variable");
        return;
      }

      if (mongo_db == "no-mongo-db") {
        tracer->setUserError("No db specified. Please specify mongo database name with 'mongo.db' environment variable");
        return;
      }

      if (mongo_collection == "no-mongo-collection") {
        tracer->setUserError("No collection specified. Please specify mongo collection name with 'mongo.collection' environment variable");
        return;
      }

      //
      // Adding 'time' to collection name
      // The collections are predefined in mongo as the collection must be configured to use sharding ...
      //
      //      now = time(NULL);
      //      gmtime_r(&now, &tmP);
      //      strftime(timeLine, sizeof(timeLine), "%Y%m%d_%H%M%S", &tmP);
      //      mongo_collection += std::string("_") + timeLine;

      mdbConnection = new mongo::DBClientConnection();
      LM_M(("Connect to mongo at '%s'", mongo_ip.c_str()));

      bool connected = false;
      for (int tries = 1; tries < 10; tries++) {
        std::string errorString;

        errorString = "";

        try {
          LM_M(("Connecting [START] to mongo"));
          bool conn = mdbConnection->connect(mongo_ip, errorString);
          if (conn == true) {
            LM_M(("Connecting [DONE] to mongo"));
            connected = true;
            break;
          } else
            LM_M(("Connecting [ERROR] mongo connection error: %s", errorString.c_str()));
        } catch (mongo::ConnectException &e) {
          LM_E(("Error connecting to mongo at '%s': %s", mongo_ip.c_str(), errorString.c_str()));
          usleep(5000);
        }
      }

      if (connected == false) {
        delete mdbConnection;
        mdbConnection = NULL;
        tracer->setUserError("error connecting to MongoDB at " + mongo_ip);
        LM_E(("Sorry, cannot connect to mongo ..."));
        return;
      }

      mongo_db_path = mongo_db + "." + mongo_collection;
      inserts = 0;
      records = 0;
      runs = 0;
    }

    void run(samson::KVSetStruct* inputs, samson::KVWriter *writer) {
      if (inputs[0].num_kvs == 0) {
        tracer->setUserError("Zero input key values ...");
        return;
      }

      if (mdbConnection == NULL) {
        tracer->setUserError("Not connected to MongoDB - please check the parameters to this operation");
        return;
      }
      ++runs;

      records += inputs[0].num_kvs;

      for (size_t i = 0; i < inputs[0].num_kvs; ++i) {
        mongo::BSONObjBuilder bb;

        key.parse(inputs[0].kvs[i]->key);
        value.parse(inputs[0].kvs[i]->value);

        bb.append("S", static_cast<long long>(key.sensor_id.value));
        bb.append("T", static_cast<long long>(key.time.value));
        bb.append("X", static_cast<long long>(value.position.posX.value));
        bb.append("Y", static_cast<long long>(value.position.posY.value));
        bb.append("N", static_cast<long long>(value.users.num_users.value));

        for (int j = 0; (j < value.users.user_ticks_length); ++j) {
#define MAXLENKEY 20
          char user_index[MAXLENKEY];
          char time_index[MAXLENKEY];
          snprintf(user_index, MAXLENKEY, "U[%d]", j);
          snprintf(time_index, MAXLENKEY, "T[%d]", j);
          bb.append(user_index, static_cast<long long>(value.users.user_ticks[j].user_id.value));
          bb.append(time_index, static_cast<long long>(value.users.user_ticks[j].timestamp.value));
        }

        mongo::BSONObj record = bb.obj();

        dataVec.push_back(record);

        ++inserts;
        ++grandTotalInserts;

        if ((inserts != 0) && ((inserts % mongo_bulksize) == 0)) {
          //LM_M(("Inserting [START] bulk of %d records (bulksize: %d), grandTotalInserts:%d", inserts, mongo_bulksize, grandTotalInserts));
          mdbConnection->insert(mongo_db_path, dataVec);
          //LM_M(("Inserting [DONE]  bulk of %d records (bulksize: %d), grandTotalInserts:%d", inserts, mongo_bulksize, grandTotalInserts));

          dataVec.clear();
          inserts = 0;
        }

      }

      if ((inserts != 0) && ((inserts % mongo_bulksize) == 0)) {
        //LM_M(("Run[out-of-loop]: Inserting bulk of %d records (bulksize: %d)", inserts, mongo_bulksize));
        mdbConnection->insert(mongo_db_path, dataVec);
        dataVec.clear();
        inserts = 0;
      }

      // mdbConnection->ensureIndex(mongo_db_path, fromjson("{I:1}"));
    }

    void finish(samson::KVWriter *writer) {
      if (inserts != 0) {
        LM_M(("Finish: Inserting bulk of %d records (bulksize: %d)", inserts, mongo_bulksize));
        mdbConnection->insert(mongo_db_path, dataVec);
        dataVec.clear();
      }
      LM_M(("Operation [END] Finish: Grand total: %d inserts, %d records inserted, %d calls to run", grandTotalInserts, records, runs));
      delete mdbConnection;
    }
};

} // end of namespace fiware_pos
} // end of namespace samson

#endif
