/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_level_update_gouped_levels
#define _H_SAMSON_level_update_gouped_levels

#include <samson/module/samson.h>
#include <samson/modules/level/GroupItems.h>
#include <samson/modules/level/Item.h>
#include <samson/modules/system/Int32.h>
#include <samson/modules/system/String.h>

namespace samson
{
namespace level
{

class update_gouped_levels: public samson::Reduce
{

  samson::system::String key;
  samson::level::Item item;
  samson::level::GroupItems group;

public:

//  INFO_MODULE
// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
// Please, do not remove this comments, as it will be used to check consistency on module declaration
//
//  input: system.String level.Item  
//  input: system.String level.GroupItems  
//  output: system.String system.Int32
//  output: system.String level.GroupItems
//  
// helpLine: Update Level with incomming values. Accumulated value is emitted at two outputs
//  END_INFO_MODULE

  void init(samson::KVWriter *writer)
  {
  }

  void run(samson::KVSetStruct* inputs, samson::KVWriter *writer)
  {
    samson::system::Int32 tmp;
    samson::system::Int32 value;

    if (inputs[1].num_kvs == 0)
    {
      // New user state
      group.items_length = 0;
      key.parse(inputs[0].kvs[0]->key);
    }
    else
    {
      // Previous state
      group.parse(inputs[1].kvs[0]->value); // We only consider one state
      key.parse(inputs[1].kvs[0]->key);
      if (inputs[1].num_kvs > 1)
      {
        LM_M(("Multiple states(%lu) for key:%s", inputs[1].num_kvs, key.value.c_str()));
      }
    }

    for (uint64_t i = 0; i < inputs[0].num_kvs; i++)
    {
      bool itemFound = false;
      item.parse(inputs[0].kvs[i]->value);

      //LM_M(("Check for userId:%lu serviceId:%lu", userId.value, hit.serviceId.value));
      for (int j = 0; (j < group.items_length); j++)
      {
        if (item.item.value == group.items[j].item.value)
        {
          itemFound = true;
          group.items[j].count.value += item.count.value;
          group.items[j].t.value = item.t.value;
        }
      }

      if (itemFound == false)
      {
        group.addItem(item.item, item.count, item.t);
      }
    }

    for (int j = 0; (j < group.items_length); j++)
    {
      writer->emit(0, &(group.items[j].item), &(group.items[j].count));
    }
    writer->emit(1, &key, &group);
  }

  void finish(samson::KVWriter *writer)
  {
  }

};

} // end of namespace level
} // end of namespace samson

#endif
