/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_wiki_reduce_inverted_index
#define _H_SAMSON_wiki_reduce_inverted_index

#include "logMsg/logMsg.h"
#include <samson/module/samson.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/StringVector.h>
#include <stdint.h>


namespace samson{
namespace wiki{


class reduce_inverted_index : public samson::Reduce
{
	// Input
	samson::system::String word;
	samson::system::String page;

	// State
	samson::wiki::WordInfo wordInfo;

public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.String system.String
	input: system.String wiki.WordInfo
	output: system.String wiki.WordInfo

	helpLine: Builds an inverted index (words or links)
#endif // de INFO_COMMENT

	void init(samson::KVWriter *writer )
	{
	}

	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		samson::system::String prevPage;
		samson::system::UInt prevCount;
		int index;

		//LM_M(("inputs[1].num_kvs:%lu", inputs[1].num_kvs));
		if (inputs[1].num_kvs > 0)
		{
			// There is an entry in the state
			word.parse(inputs[1].kvs[0]->key);
			wordInfo.parse(inputs[1].kvs[0]->value);
		}
		else
		{
			// First appearance of key
			word.parse(inputs[0].kvs[0]->key);
			wordInfo.page.valuesSetLength(0);
			wordInfo.count.valuesSetLength(0);
			wordInfo.totalCount.value = 0;
		}

		if (inputs[0].num_kvs > 0)
		{
			prevPage.parse(inputs[0].kvs[0]->value);
			prevCount.value = 1;

			for (uint64_t i = 1; (i < inputs[0].num_kvs); i++)
			{
				page.parse(inputs[0].kvs[i]->value);

				if (prevPage.value.compare(page.value) == 0)
				{
					prevCount.value++;
				}
				else
				{
					if ((index = wordInfo.page.findIndexSortedFromEnd(prevPage)) == -1)
					{
						//wordInfo.page.valuesAdd()->copyFrom(&prevPage);
						//wordInfo.count.valuesAdd()->copyFrom(&prevCount);
						int indexInsert = wordInfo.page.valuesAddSortedFromEnd(prevPage);
						wordInfo.count.valuesAddAtIndex(prevCount, indexInsert);
					}
					else
					{
						wordInfo.totalCount.value -= wordInfo.count.values[index].value;
						wordInfo.count.values[index].value = prevCount.value;
					}
					wordInfo.totalCount += prevCount.value;
					prevPage = page;
					prevCount.value = 1;
				}
			}
			if ((index = wordInfo.page.findIndexSortedFromEnd(prevPage)) == -1)
			{
				//wordInfo.page.valuesAdd()->copyFrom(&prevPage);
				//wordInfo.count.valuesAdd()->copyFrom(&prevCount);
				int indexInsert = wordInfo.page.valuesAddSortedFromEnd(prevPage);
				wordInfo.count.valuesAddAtIndex(prevCount, indexInsert);
			}
			else
			{
				wordInfo.totalCount.value -= wordInfo.count.values[index].value;
				wordInfo.count.values[index].value = prevCount.value;
			}
			wordInfo.totalCount.value += prevCount.value;
		}

		writer->emit(0, &word, &wordInfo);
	}

	void finish(samson::KVWriter *writer )
	{
	}



};


} // end of namespace wiki
} // end of namespace samson

#endif
