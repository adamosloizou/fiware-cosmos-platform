/*
 * Telefónica Digital - Product Development and Innovation
 *
 * THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
 * EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 *
 * Copyright (c) Telefónica Investigación y Desarrollo S.A.U.
 * All rights reserved.
 */

/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_passive_location_reduce_user_msisdn_by_imsi
#define _H_SAMSON_passive_location_reduce_user_msisdn_by_imsi


#include <samson/module/samson.h>
#include <samson/modules/passive_location/Record.h>
#include <samson/modules/passive_location/User.h>
#include <samson/modules/system/UInt.h>


namespace samson{
namespace passive_location{


	class reduce_user_msisdn_by_imsi : public samson::Reduce
	{
	    samson::system::UInt imsi_key;                // Input key
	    samson::passive_location::Record record;      // Input & Output record
	    samson::passive_location::User userInfo;      // Information about cell

	public:


//  INFO_MODULE
// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
// Please, do not remove this comments, as it will be used to check consistency on module declaration
//
//  input: system.UInt passive_location.Record  
//  input: system.UInt passive_location.User  
//  output: system.UInt passive_location.Record
//  output: system.UInt passive_location.Record
//  
// helpLine: Extract msisdn info from user table, based on imsi
//  END_INFO_MODULE

		void init( samson::KVWriter *writer )
		{
		}

		void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
	        if (inputs[0].num_kvs == 0)
	        {
	            return;
	        }

	        if( inputs[1].num_kvs == 0)
	        {
	            imsi_key.parse(inputs[0].kvs[0]->key);
	            //LM_W(("No userInfo for imsi:%lu (%lu records)", imsi_key.value, inputs[0].num_kvs));

	            // Non existing user... forward input to output 1
	            for ( uint64_t i = 0 ; i< inputs[0].num_kvs ; i++)
	            {
	                record.parse( inputs[0].kvs[i]->value );
	                // Emitted by imei, in order to try later a second option
	                // Actually, this option is not working, there is no improvement
	                // in detection by using IMEI
	                if (record.imei.value != 0)
	                {
	                    writer->emit( 1 , &record.imei , &record );
	                }
	            }
	            return;
	        }

	        imsi_key.parse(inputs[1].kvs[0]->key);
//
//	        if (imsi_key.value == 0)
//	        {
//	            LM_W (("Records with imsi == 0, inputs[0].num_kvs:%lu, inputs[1].num_kvs:%lu", inputs[0].num_kvs, inputs[1].num_kvs));
//	        }

	        if (inputs[1].num_kvs > 1)
	        {
	            LM_W(("More than one user description for imsi:%lu (%lu infos)", imsi_key.value, inputs[1].num_kvs));
	            // We should look for the newest info...
	            // But easiest if we are sure we only have one
	        }

	        userInfo.parse( inputs[1].kvs[0]->value );

	        //LM_M(("Emitting %lu records for imsi:%lu", inputs[0].num_kvs, imsi_key.value));

	        for ( uint64_t i = 0 ; i< inputs[0].num_kvs; i++)
	        {
	            record.parse( inputs[0].kvs[i]->value );

	            // Complete the complete record
	            record.msisdn.value = userInfo.msisdn.value;

                if (record.msisdn.value == 0)
                {
                    LM_W(("Found msisdn:%lu == 0 (imsi:%lu), with record.imei:%lu from userInfo.imei:%lu", record.msisdn.value, record.imsi.value, record.imei.value, userInfo.imei.value));
                }

//	            if (record.imei.value != userInfo.imei.value)
//	            {
//	                LM_W(("For user msisdn:%lu (imsi:%lu), different record.imei:%lu from userInfo.imei:%lu", record.msisdn.value, record.imsi.value, record.imei.value, userInfo.imei.value));
//	            }

	            writer->emit( 0 , &record.msisdn , &record );
	        }
	        return;

		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace passive_location
} // end of namespace samson

#endif
