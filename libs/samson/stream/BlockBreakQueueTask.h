

#ifndef _H_STREAM_BLOCK_BREAK_TASK
#define _H_STREAM_BLOCK_BREAK_TASK

#include <sstream>
#include <string>

#include "au/map.h"                             // au::map
#include "au/string.h"                          // au::Format
#include "au/ErrorManager.h"

#include "engine/Buffer.h"                      // engine::Buffer
#include "engine/Object.h"                      // engine::Object
#include "engine/ProcessItem.h"                 // engine::ProcessItem


#include "samson/common/coding.h"               // KVRange
#include "samson/common/samson.pb.h"            // network::...
#include "samson/stream/QueueTaskManager.h"     // samson::stream::QueueTaskManager
#include "samson/stream/SystemQueueTask.h"      // samson::stream::SystemQueueTask
#include "engine/Object.h"                      // engine::Object

namespace samson {
    
    namespace stream
    {
        /**
         Task to break a set of blocks
         */
        
        class BlockBreakQueueTask : public SystemQueueTask
        {
            friend class QueueTaskManager;
            friend class StreamManager;

            size_t block_id;                // Identifier of the original block we are breaking
            
            int num_divisions;              // Number of divisions
            
            std::vector<engine::Buffer*> outputBuffers;  // Ouput buffers generated by this operation
            
        public:
            
            BlockBreakQueueTask( size_t _id , Block * block , int _num_divisions  );
            
            void run();
            
            // Function executed just before task is deleted in the main thread
            void finalize( StreamManager* streamManager );
            
        private:
            
            int num_blocks;     // Number of blocks ( used only in "run" )
            KVFile *files;      // Pointer to all the info inside included blocks
            
            void createBlock( KVRange range , int file_begin , int file_end );
            
        };  
    }
}

#endif