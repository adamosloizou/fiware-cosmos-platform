/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_system_PROCESS
#define _H_SAMSON_system_PROCESS


#include "au/containers/map.h"
#include <samson/module/samson.h>
#include <samson_system/Value.h>
#include "samson/module/KVWriter.h"

namespace samson{
    namespace system{
        
        // Item 
        class ProcessItem
        {
            samson::system::Value trace_key;
            samson::system::Value trace_value;
            
        protected:
            
            // General writer to emit key-values at the output
            samson::KVWriter *writer;
            
            // Current key being processed
            Value* key;
            
            // Current state ( void if no previos state )
            Value* state;
            
        public:
            
            ProcessItem( )
            {
            }
            
            virtual ~ProcessItem()
            {
            }
            
            // Init with a new key , state ( void if no previous state ) , and writer to emit
            void init( Value* _key , Value* _state , samson::KVWriter * _writer  )
            {
                key = _key;
                state = _state;
                writer = _writer;

                // Internal call to init
                init();

            }
            
            virtual void init()=0;                        // Called everytime we have a new key and state pair
            virtual void process( Value* value )=0;       // Called for any income value ( input channel )
            virtual void finish(  )=0;                    // Called after all input key-values are processed

            virtual void flush( )=0;                      // Called once before finishing everything
          
            
            void trace( std::string message )
            {
                trace_key.set_string(message);
                trace_value.set_as_void();
                writer->emit( -1 , &trace_key , &trace_value );
            }
            
        };
        
        
        
        class Accumulate : public ProcessItem
        {
            
            Value * value_count;  // Value in state containing counter
            Value * value_ts;     // Value in state containing ts
            
        public:
            
            // Constructor
            Accumulate(  ) 
            {
            }
            
            void init()
            {
                trace( "Init accumulate" );
                
                if( !state->isMap() )
                    state->set_as_map();
                    
                // Get the current count
                value_count = state->get_or_add_value_from_map("count");
                value_ts    = state->get_or_add_value_from_map("ts");

                if( !value_count->is_number() )
                    value_count->set_double(0);

                // Update count from time-stamp
                // ?
                
                // New time stamp in state
                value_ts->set_double( time(NULL) );
            }
            
            void process( Value* value )
            {
                trace( "Accumulate: Processing value" );
                
                // Only accepting map values
                if( value->isMap() )
                {
                    // Update count
                    value_count->add_double( value->get_double_from_map("count",0) );
                    
                    // Get next element to sent something extra
                    
                }
            }
            
            void finish(  )
            {
                // Nothing in this case since state is updates continuously
                
            }
            
            void flush( )
            {
                // nothing else has to be sent
                
            }

        };
        
        
        
        
        // Process to controll all the process
        class Process
        {
            
            // Items to process key-valuyes
            au::map<std::string , ProcessItem > items;

            // Pointer to the current service ( based on app field in the key )
            ProcessItem * item;
            
        public:
            
            Process(  )
            {                
                // Add process items
                std::string name = "accumulate";
                items.insertInMap( name , new Accumulate( ) );
            }
            
            void init( Value* key , Value* state ,  samson::KVWriter *writer )
            {
                // Default NULL
                item = NULL;
                
                if( !key->isMap() )
                    return;
                
                Value* value_app = key->get_value_from_map( "app" );
                if( !value_app )
                    return;
                
                // Find the required service
                std::string app_name = value_app->get_string();
                item = items.findInMap( app_name );
                
                if( item )
                    item->init( key, state , writer );
            }
            
            void process( Value* value )
            {
                if( item )
                    item->process( value );
            }
            
            void finish()
            {
                if( item )
                    item->finish();
            }
            
            void flush()
            {
                // Flush pending data to be emitted for all apps
                au::map<std::string , ProcessItem >::iterator it_items;
                for ( it_items = items.begin() ; it_items != items.end() ; it_items++ )
                    it_items->second->flush();
            }
            
            
        };
        
        
    }
}

#endif