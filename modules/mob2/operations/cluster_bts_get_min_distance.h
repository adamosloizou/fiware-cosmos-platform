
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_mob2_cluster_bts_get_min_distance
#define _H_SAMSON_mob2_cluster_bts_get_min_distance


#include <samson/module/samson.h>
#include <samson/modules/mob2/Cluster.h>
#include <samson/modules/mob2/ClusterVector.h>
#include <samson/modules/mob2/Node_Bts.h>
#include <samson/modules/system/UInt.h>



namespace samson{
namespace mob2{


	class cluster_bts_get_min_distance : public samson::Reduce
	{
        // Inputs
        Node_Bts nodbts;
        ClusterVector clusVector;

        // Ouputs
        samson::system::UInt bts;
        Cluster cluster;

	//Reference cluster
	ClusterSet btsClusters;

	public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

input: mob2.Node_Bts mob2.ClusterVector  
output: system.UInt mob2.Cluster

extendedHelp: 		Calculate the euclidean distance between a vector and a cluster.

#endif // de INFO_COMMENT

		void init(samson::KVWriter *writer )
		{
			//TODO: Load the reference clusters from MongoDB
			btsClusters.clusterSetLength(0);
		}

		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
        // Intermediate
        double mindist, dist;
        double com, ccom;
        int clusId = -1;

        for(uint64_t i=0; i<inputs[0].num_kvs; i++)
        {
                nodbts.parse(inputs[0].kvs[i]->key);
                clusVector.parse(inputs[0].kvs[i]->value);
                cluster.coords.copyFrom(&clusVector);
                mindist = 1000;

                // Calculate min dist - Euclidean distance
                for(int nClus=0; nClus<btsClusters.cluster_length; nClus++)
                {
                        dist = 0;
                        for(int nComs=0; nComs<clusVector.coms_length; nComs++)
                        {
                                ccom = btsClusters.cluster[nClus].coords.coms[nComs].value;
                                com = clusVector.coms[nComs].value;
                                dist += ((ccom - com) * (ccom - com));
                        }
                        if(dist < mindist)
                        {
                                mindist = dist;
                                clusId = nClus;
                        }
                }
                mindist = sqrt(mindist);

                bts.value = nodbts.bts.value;

                // Filter bts without clusterization
        /*      if(mindist > btsClusters.cluster[clusId].distance)
                {
                        cluster.label = 0;
                        cluster.labelgroup = 0;
                }
                else
                {*/
                        cluster.label.value = btsClusters.cluster[clusId].label.value;
                        cluster.labelgroup.value = btsClusters.cluster[clusId].labelgroup.value;
                //}

                cluster.distance.value = mindist;
                cluster.mean.value = 0;
                //cluster.coords.comsSetLength(0);
                writer->emit(0, &bts,&cluster);
        }

		}

		void finish(samson::KVWriter *writer )
		{
		}



	};


} // end of namespace mob2
} // end of namespace samson

#endif
