
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_mob2_cluster_client_get_min_distance
#define _H_SAMSON_mob2_cluster_client_get_min_distance


#include <samson/module/samson.h>
#include <samson/modules/mob2/Cluster.h>
#include <samson/modules/mob2/ClusterVector.h>
#include <samson/modules/mob2/Node_Bts.h>
#include <samson/modules/system/UInt.h>
#include "mongo/client/dbclient.h"
#include "mongo/client/dbclientcursor.h"



namespace samson{
namespace mob2{


	class cluster_client_get_min_distance : public samson::Map
	{
        // Inputs
        Node_Bts nodbts;
        ClusterVector clusVector;
        // Ouputs
        samson::system::UInt node;
        Cluster cluster;

	//reference clusters
	ClusterSet clientClusters;

	// MongoDB variables
        std::string          mongo_ip;
        std::string          mongo_db;
        std::string          mongo_collection;
        std::string          mongo_db_path;
        DBClientConnection*  mdbConnection;

	// Temporal variables
	samson::system::Double coord;
	Cluster clusterInfo;


	public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

input: mob2.Node_Bts mob2.ClusterVector  
output: system.UInt mob2.Cluster

extendedHelp: 		Calculate the euclidean distance between a vector and a cluster

#endif // de INFO_COMMENT

		void init(samson::KVWriter *writer )
		{
			clientClusters.clusterSetLength(0);
        mongo_ip           = environment->get("mongo.ip",    "no-mongo-ip");
        mongo_db           = environment->get("mongo.db",    "no-mongo-db");
        mongo_collection   = environment->get("mongo.collection", "no-mongo-collection");

        if (mongo_ip == "no-mongo-ip")
        {
                tracer->setUserError("No mongo ip is specified. Please specify mongo ip with 'mongo.ip' environment variable");
                return;
        }

        if (mongo_db == "no-mongo-db")
        {
                tracer->setUserError("No db specified. Please specify mongo database db name with 'mongo.db' environment variable");
                return;
        }

        if (mongo_collection == "no-mongo-collection")
        {
                tracer->setUserError("No collection is specified. Please specify mongo collection with 'mongo.collection' environment variable");
                return;
        }

        mongo_db_path = mongo_db + "." + mongo_collection;

        mdbConnection = new DBClientConnection();
        mdbConnection->connect(mongo_ip);

	BSONObj                 bo;



	auto_ptr<DBClientCursor> cursor = mdbConnection->query(mongo_db_path);

	while (cursor->more())
	{
		bo       = cursor->next();
		clusterInfo.label.value = bo.getField("clusterInfo.label").Long();
		clusterInfo.labelgroup.value = bo.getField("clusterInfo.labelgroup").Long();
		clusterInfo.mean.value = bo.getField("clusterInfo.mean").Double();
		clusterInfo.distance.value = bo.getField("clusterInfo.distance").Double();
		for(int j=0; j<96; j++)
		{
			coord.value = bo.getField("coord").Double();
			clusterInfo.coords.comsAdd()->copyFrom(&coord);
		}
		clientClusters.clusterAdd()->copyFrom(&clusterInfo);
	}

	delete mdbConnection;

		}

		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
        // Intermediate
        double mindist, dist;
        double com, ccom;
        int clusId = -1;

        for(uint64_t i=0; i<inputs[0].num_kvs; i++)
        {
                nodbts.parse(inputs[0].kvs[i]->key);
                clusVector.parse(inputs[0].kvs[i]->value);
                cluster.coords.copyFrom(&clusVector);
                mindist = 1000;

                // Calculate min dist - Euclidean distance
                for(int nClus=0; nClus<clientClusters.cluster_length; nClus++)
                {
                        dist = 0;
                        for(int nComs=0; nComs<clusVector.coms_length; nComs++)
                        {
                                ccom = clientClusters.cluster[nClus].coords.coms[nComs].value;
                                com = clusVector.coms[nComs].value;
                                dist += ((ccom - com) * (ccom - com));
                        }
                        if(dist < mindist)
                        {
                                mindist = dist;
                                clusId = nClus;
                        }
                }
                mindist = sqrt(mindist);

                node.value = nodbts.phone.value;
                if(mindist > clientClusters.cluster[clusId].distance.value) // High to cluster level
                {
                        cluster.label.value = 0;
                        cluster.labelgroup.value = 0;
                }
                else
                {
                        cluster.label.value = clientClusters.cluster[clusId].label.value;
                        cluster.labelgroup.value = clientClusters.cluster[clusId].labelgroup.value;
                }
                cluster.distance.value = mindist;
                cluster.mean.value = 0;

                writer->emit(0, &node,&cluster);
        }

		}

		void finish(samson::KVWriter *writer )
		{
		}



	};


} // end of namespace mob2
} // end of namespace samson

#endif
