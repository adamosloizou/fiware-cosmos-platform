
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_passive_location_parse_tek_drs
#define _H_SAMSON_passive_location_parse_tek_drs


#include <samson/module/samson.h>
#include <samson/modules/passive_location/Record.h>
#include <samson/modules/system/UInt.h>


namespace samson{
namespace passive_location{


	class parse_tek_drs : public samson::Parser
	{

        samson::system::UInt32 equip_id;            // Used as key at the output
        samson::passive_location::Record record;    // Used as value at the output

	public:


//  INFO_MODULE
// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
// Please, do not remove this comments, as it will be used to check consistency on module declaration
//
//  output: system.UInt32 passive_location.Record
//  
// helpLine: Parse input binary OHDRs from Tektroniks platform (probes). Note that output key is cellid
//  END_INFO_MODULE

		void init( samson::KVWriter *writer )
		{
		}

		bool parse_OHDR_header(char **p_ohdr, uint32_t *sizeOHDR, int *numDRs)
		{
		    *numDRs = 0;

#define OHDR_HEADER_SIZE 12
		    *sizeOHDR = *((uint32_t *)*p_ohdr) + sizeof(uint32_t);
		    if (int(*(*p_ohdr+sizeof(uint32_t))) != 130)
		    {
		        OLM_M(("OHDR is not a data message type (%d != expected 130)", int(*(*p_ohdr+sizeof(uint32_t)))));
		        *p_ohdr += OHDR_HEADER_SIZE;
		        return false;
		    }
		    *numDRs = int(*(*p_ohdr+ 2*sizeof(uint32_t)));
		    *p_ohdr += OHDR_HEADER_SIZE;
		    return true;
		}


		bool parse_DR(char **p_dr, uint32_t *sizeDR, int *typeDR, int *timestamp, int *imsi, int *imei, int *probeId)
		{

		    *typeDR = 0;
		    *timestamp = 0;
		    *imsi = 0;
		    *imei = 0;
		    *probeId = 0;

#define DR_HEADER_SIZE 4
		    *sizeDR = *((uint16_t *)*p_dr) * sizeof(uint32_t);

		    char bitmask = *(*p_dr+sizeof(uint16_t));
		    if (bitmask == 0)
		    {
		        *p_dr += *sizeDR;
		        return false;
		    }
#define TYPE_gsmA 2
#define TYPE_UMTS 5
		    *typeDR = int(bitmask & 0x07);

#define DR_WORDSECTION_SIZE_gsmA 44
#define DR_WORDSECTION_SIZE_UMTS 52

#define DR_SHORTSECTION_SIZE_gsmA 28
#define DR_SHORTSECTION_SIZE_UMTS 24

            int num_elementIDs = 0;
            int fixed_length_word_section = 0;
            int fixed_length_short_section = 0;
            int desp_probeId = 0;
            int bit_imsi = 0;
            int bit_imei = 0;

            int varSize = 0;

            if (*typeDR == TYPE_gsmA)
            {
                int num_elementIDs = int((bitmask >> 3) & 0x03);
                int fixed_length_word_section = DR_WORDSECTION_SIZE_gsmA;
                int fixed_length_short_section = DR_SHORTSECTION_SIZE_gsmA;
                int desp_probeId = 0;
                int bit_imsi = 0;
                bit_imei = 2;
            }
            else if (*typeDR == TYPE_UMTS)
            {
                num_elementIDs = int((bitmask >> 3) & 0x07);
                fixed_length_word_section = DR_WORDSECTION_SIZE_UMTS;
                fixed_length_short_section = DR_SHORTSECTION_SIZE_UMTS;
                desp_probeId = 1;
                bit_imsi = 0;
                bit_imei = 8;
            }
            else
            {
                OLM_M(("Error, unknown type %d, (gsmA:%d, UMTS:%d)", *typeDR, TYPE_gsmA, TYPE_UMTS));
                *p_dr += *sizeDR;
                return false;
            }
            int total_lengh_elementIDs = int(*(*p_dr+3)) * sizeof(uint32_t);

		    char *p_elementsID_mask = *p_dr + DR_HEADER_SIZE;

		    for (int i = 0; (i < num_elementIDs); i++)
		    {
	            uint32_t elementMask = *((uint32_t *)p_elementsID_mask);
	            if (((elementMask >> 29) & 0x07) == 0)
	            {
	                if ((elementMask >> 1) & 0x01)
	                {
	                    *timestamp = *((uint32_t *)p_elementsID_mask + 2*sizeof(uint32_t));
	                }

	                p_elementsID_mask += fixed_length_word_section;
	            }
	            else if (((elementMask >> 29) & 0x07) == 1)
	            {
	                if ((elementMask >> desp_probeId) & 0x01)
	                 {
	                     *probeId = *((uint16_t *)p_elementsID_mask + (sizeof(uint32_t) + sizeof(uint32_t)*desp_probeId));
	                 }

	                p_elementsID_mask += fixed_length_short_section;
	            }
	            else if (((elementMask >> 29) & 0x07) == 2)
	            {
	                char *p_ini_varElements = p_elementsID_mask + sizeof(uint32_t);
	                for (int j = 0; (j < 28); j++)
	                {
	                    if ((elementMask >> j) & 0x01)
	                    {
	                        varSize = int(*p_ini_varElements++);
	                        if ((j == bit_imsi) || (j == bit_imei))
	                        {
	                            uint64_t bufferLong = 0;
	                            char *p_buffer = (char *)&bufferLong;
	                            for (int k = 0; (k < varSize); k++)
	                            {
	                                *p_buffer++ = *p_ini_varElements++;
	                            }

	                            if (varSize > 4)
	                            {
	                                OLM_M(("Error, field %d larger(%d) than int(%d), for IMEI or IMSI", j, varSize, sizeof(int)));
	                            }

	                            if (j == bit_imsi)
	                            {
	                                *imsi = bufferLong;
	                            }
	                            else
	                            {
	                                *imei = bufferLong;
	                            }
	                        }
	                        else
	                        {
	                            p_ini_varElements += varSize;
	                        }

	                    }

	                }

	            }
	            else
	            {
                    OLM_M(("Error in elementMask for fixed sections, 0x%0x should be 0, 1 or 2, in bits 32-30", elementMask));
                    *p_dr += *sizeDR;
                    return false;
	            }
		    }

		    char *p_var_section = *p_dr + DR_HEADER_SIZE + total_lengh_elementIDs;

		    int numVarFields = *((uint16_t *)(p_var_section + sizeof(uint16_t)));

		    p_var_section += 4;

		    for (int i = 0; (i < numVarFields); i++)
		    {
		        if ((*(p_var_section + sizeof(uint16_t))) & 0x01)
		        {
		            varSize = int(*(p_var_section + sizeof(uint16_t) + 1));
		            p_var_section += sizeof(uint16_t) + 1 + varSize;
		            *timestamp = *(uint32_t *)p_var_section;
		            break;
		        }
		        else if ((*(p_var_section + sizeof(uint16_t))) & 0x02)
                {
                    varSize = int(*(p_var_section + sizeof(uint16_t) + 1));
                    p_var_section += sizeof(uint16_t) + 1 + varSize + sizeof(uint32_t);
                }
		        else
		        {
                    varSize = int(*(p_var_section + sizeof(uint16_t) + 1));
                    p_var_section += sizeof(uint16_t) + 1 + varSize;
		        }
		    }

            *p_dr += *sizeDR;
            return true;

		}

		void run( char *data , size_t length , samson::KVWriter *writer )
		{
            size_t offset = 0;

            char *p_blob = data;
            char *p_end_blob = data + length;

            char *p_init_ohdr;
            char *p_end_ohdr;

            unsigned int sizeOHDR = 0;
            int numDRs = 0;

            unsigned int sizeDR = 0;
            int typeDR = 0;
            int timestamp = 0;
            int imsi = 0;
            int imei = 0;
            int probeId = 0;

            while( p_blob < p_end_blob )
            {
                p_init_ohdr = p_blob;
                if (parse_OHDR_header(&p_blob, &sizeOHDR, &numDRs))
                {
                    p_end_ohdr = p_init_ohdr + sizeOHDR;
                    for (int i = 0; ((i < numDRs) && (p_blob < p_end_ohdr)); i++)
                    {
                        if (parse_DR(&p_blob, &sizeDR, &typeDR, &timestamp, &imsi, &imei, &probeId))
                        {
                            equip_id.value = probeId;

                            record.imsi.value = imsi;
                            record.imei.value = imei;
                            record.timestamp.value = timestamp;
                            record.cell_id.value = probeId;

                            // Emit the record at the output
                            writer->emit(0, &equip_id, &record);
                        }
                    }
                    if (p_blob != p_end_ohdr)
                    {
                        OLM_M(("Alignment failed in a OHDR of % DRs", numDRs));
                    }
                }
                else
                {
                    OLM_M(("OHDR ignored because not valid header"));
                }
            }
		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace passive_location
} // end of namespace samson

#endif
