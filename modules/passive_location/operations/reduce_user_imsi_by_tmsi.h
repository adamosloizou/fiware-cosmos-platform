
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_passive_location_reduce_user_imsi_by_tmsi
#define _H_SAMSON_passive_location_reduce_user_imsi_by_tmsi


#include <samson/module/samson.h>
#include <samson/modules/passive_location/CompleteTMSI.h>
#include <samson/modules/passive_location/Record.h>
#include <samson/modules/system/UInt.h>


namespace samson{
namespace passive_location{


	class reduce_user_imsi_by_tmsi : public samson::Reduce
	{

	    samson::passive_location::CompleteTMSI completeTMSI;    // Input key
	    samson::passive_location::Record record;                // Input value
	    samson::system::UInt imsi;                              // Input value of the translation table


	public:


//  INFO_MODULE
// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
// Please, do not remove this comments, as it will be used to check consistency on module declaration
//
//  input: passive_location.CompleteTMSI passive_location.Record  
//  input: passive_location.CompleteTMSI system.UInt  
//  output: system.UInt passive_location.Record
//  output: system.UInt passive_location.Record
//  
// helpLine: Extract imsi info from tmsi_imsi table, based on previous records
//  END_INFO_MODULE

		void init( samson::KVWriter *writer )
		{
		}

		void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
            if (inputs[0].num_kvs == 0)
            {
                return;
            }

            if( inputs[1].num_kvs == 0)
            {
                completeTMSI.parse(inputs[0].kvs[0]->key);
                LM_W(("No userInfo for tmsi:%lu,%u (%lu records)", completeTMSI.tmsi.value, completeTMSI.LAC.value, inputs[0].num_kvs));

                // Non existing user... forward input to output 1
                for ( uint64_t i = 0 ; i< inputs[0].num_kvs ; i++)
                {
                    record.parse( inputs[0].kvs[i]->value );
                    // Emitted by imei, in order to try later a second option
                    if (record.imei.value != 0)
                    {
                        writer->emit( 1 , &record.imei , &record );
                    }
                }
                return;
            }

            completeTMSI.parse(inputs[1].kvs[0]->key);

            if (completeTMSI.tmsi.value == 0)
            {
                LM_W (("Records with tmsi == 0, inputs[0].num_kvs:%lu, inputs[1].num_kvs:%lu", inputs[0].num_kvs, inputs[1].num_kvs));
            }

            if (inputs[1].num_kvs > 1)
            {
                LM_W(("More than one user description for tmsi:%lu,%u (%lu infos)", completeTMSI.tmsi.value, completeTMSI.LAC.value, inputs[1].num_kvs));
                // We should look for the newest info...
                // But easiest if we are sure we only have one
            }

            imsi.parse( inputs[1].kvs[inputs[1].num_kvs-1]->value );

            //LM_M(("Emitting %lu records for imsi:%lu", inputs[0].num_kvs, imsi_key.value));

            for ( uint64_t i = 0 ; i< inputs[0].num_kvs; i++)
            {
                record.parse( inputs[0].kvs[i]->value );

                // Complete the complete record
                record.imsi.value = imsi.value;

                if (record.imsi.value == 0)
                {
                    LM_W(("Found imsi:%lu == 0 (tmsi:%lu,%u)", completeTMSI.tmsi.value, completeTMSI.LAC.value));
                }

                writer->emit( 0 , &record.msisdn , &record );
            }
            return;

		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace passive_location
} // end of namespace samson

#endif
