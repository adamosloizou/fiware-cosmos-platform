
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_sna_calculate_links_temporal_weighting
#define _H_SAMSON_sna_calculate_links_temporal_weighting


#include <samson/module/samson.h>
#include "sna_environment_parameters.h"



namespace samson{
namespace sna{


	class calculate_links_temporal_weighting : public samson::Reduce
	{
		int min_weighted_link_weight;

	public:
		void init()
		{
			min_weighted_link_weight = environment->getInt(SNA_PARAMETER_MIN_WEIGHTED_LINK_WEIGH, SNA_PARAMETER_MIN_WEIGHTED_LINK_WEIGH_DEFAULT);
		}


		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
			samson::sna::Link_Edges link_key;
			samson::sna::Link link_value;

#define NUM_INPUTS 6 // In MACRO, the number of inputs was received as an argument, But as there was also an assert(num_inputs == 6), we can assume this

			uint w[NUM_INPUTS];
			uint d[NUM_INPUTS];

			//double w_out;
			//double w_out;
			uint d_out = 0;
			uint w_out = 0;

			//Outputs
			samson::system::UInt id;
			samson::sna::Link link_out;

			for (int i=0 ; i < NUM_INPUTS; i++) {
				w[i] = 0;
				d[i] = 0;
			}

			for (int i=0; i < NUM_INPUTS; i++) {
				if ( inputs[i].num_kvs > 0){
					link_key.parse(inputs[i].kvs[0]->key);
					link_value.parse(inputs[i].kvs[0]->value);

					w[i] = link_value.weight.value;
					d[i] = link_value.dir.value;
				}
			}

			uint w2_out = (uint) (w[0]*0.7 +  w[1]*0.3);
			uint d2_out = 0;

			if (w2_out > 0 ) {
				d2_out = (uint) ((d[0]*w[0]*0.7 + d[1]*w[1]*0.3)/w2_out);
			}

			if ((w2_out > 0) && ( (w[2]+w[3]+w[4]+w[5]) > 0 )){
				id.value = link_key.phoneA.value;
				link_out.id = link_key.phoneB;

				link_out.weight.value = (uint) roundl(w2_out);
				link_out.dir.value = (uint) roundl(d2_out);

				writer->emit(1, &id, &link_out);
			}

			if(w[0]>1000 && w[2]==0 && w[3]==0 && w[4]==0 && w[5]==0 ){
				w[0] = 1000;
			}

			if(w[1]>1000 && w[3]==0 && w[4]==0 && w[5]==0 && (w[0]==0 || w[2]==0) ){
				w[1] = 1000;
			}

			if(w[2]>1000 && w[0]==0 && w[4]==0 && w[5]==0 && (w[1]==0 || w[3]==0) ){
				w[2] = 1000;
			}

			if(w[3]>1000 && w[0]==0 && w[1]==0 && w[5]==0 && (w[2]==0 || w[4]==0) ){
				w[3] = 1000;
			}

			if(w[4]>1000 && w[0]==0 && w[1]==0 && w[2]==0 && (w[3]==0 || w[5]==0) ){
				w[4] = 1000;
			}

			if(w[5]>1000 && w[0]==0 && w[1]==0 && w[2]==0 && w[3]==0 ){
				w[5] = 1000;
			}

			//OLM_T(LMT_User01 , ("VECTOR peso (%lu,%lu,%lu,%lu,%lu,%lu)\n", w[0], w[1], w[2], w[3], w[4], w[5]));
			//OLM_T(LMT_User01 , ("VECTOR dir  (%lu,%lu,%lu,%lu,%lu,%lu)\n", d[0], d[1], d[2], d[3], d[4], d[5]));

			int seq1 =   w[0] - w[1] + w[2] - w[3] + w[4] - w[5];
			int seq2 = - w[0] - w[1] + w[2] + w[3] - w[4] + w[5];
			int seq3 = - w[0] - w[1] - w[2] - w[3] + w[4] + 3 * w[5];

			if( abs(seq1) >= abs(seq3)/1.53 || abs(seq2) >= abs(seq3)/1.53 ){
				w_out = (uint) (w[0]*0.0571 + w[1]*0.0816 + w[2]*0.1166 + w[3]*0.1666 + w[4]*0.2380 + w[5]*0.3401);
				if( w_out > 0 ) {
					d_out = (uint) (( d[0]*w[0]*0.0571 + d[1]*w[1]*0.0816 + d[2]*w[2]*0.1166 + d[3]*w[3]*0.1666 + d[4]*w[4]*0.2380 + d[5]*w[5]*0.3401)/w_out);
				}
			} else {
				w_out = (uint) (w[0]*0.0022 + w[1]*0.0158 + w[2]*0.0897 + w[3]*0.2437 + w[4]*0.3175 + w[5]*0.3311);
				if( w_out > 0 ) {
					d_out = (uint) (( d[0]*w[0]*0.0022 + d[1]*w[1]*0.0158 + d[2]*w[2]*0.0897 + d[3]*w[3]*0.2437 + d[4]*w[4]*0.3175 + d[5]*w[5]*0.3311)/w_out);
				}
			}

			if ( (uint) roundl(w_out) > min_weighted_link_weight )
			{
				id = link_key.phoneA;
				link_out.id = link_key.phoneB;

				link_out.weight.value = (uint) roundl(w_out);
				link_out.dir.value = (uint) roundl(d_out);

				writer->emit(0, &id, &link_out);
			}

#undef NUM_INPUTS

		}
	};


} // end of namespace samson
} // end of namespace sna

#endif
