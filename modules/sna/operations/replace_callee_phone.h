
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_sna_replace_callee_phone
#define _H_SAMSON_sna_replace_callee_phone


#include <samson/Operation.h>
#include <samson/Log.h>


namespace ss{
namespace sna{


	class replace_callee_phone : public ss::Reduce
	{
		ss::system::UInt calleeNumber, key ;
		int users, repetitions ;
		CDR cdr ;
		User user ;

	public:


		void run(  ss::KVSetStruct* inputs , ss::KVWriter *writer )
		{


			ss::system::UInt destination;

			  users=0;
			  repetitions=0;
			  for (int i=0  ; i< inputs[0].num_kvs ;i++)
			  {
			    cdr.parse(inputs[0].kvs[i]->value);
			    calleeNumber.parse(inputs[0].kvs[i]->key);

			    //The key will be the caller member ID
			    key = cdr.node;

			    //If there are customers with that phone number
			    if (inputs[1].num_kvs > 0)
			    {
			      if (inputs[1].num_kvs > 1)
			      {
			        users++;
			        repetitions += inputs[1].num_kvs -1;
			      }
			      //For each user, emit a CDR. Normally only one user should appear
			      //but if more do, it's not an error, it's a number that belongs to several users
			      //Meaning: if the callee number belongs to more than one customer, it is assumed all those
			      //customer were called, since there is no way at the moment to tell the customer that was called.

			      for (int j=0  ; j< inputs[1].num_kvs ;j++)
			      {
			        //Replace the node in the cdr with the callee memberID
			        user.parse(inputs[1].kvs[j]->value);
			        cdr.node = user.id;
			        writer->emit(0, &key, &cdr);
			      }
			    //Otherwise the phone number doesn't belong to any customer. Don't replace
			    //Simply put the the callee number in the node of the CDR
			    }else{
			      cdr.node = calleeNumber.value;
			      writer->emit(0, &key, &cdr);
			    }
			  }
			  if (users>0)
			  {
			    OLM_T(LMT_User01, ("The CDR emmisions had %d cdrs which adding %d extra rows for calle phone %d\n", users, repetitions, cdr.node.value));
			  }
		}


	};


} // end of namespace ss
} // end of namespace sna

#endif
