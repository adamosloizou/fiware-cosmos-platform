
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_sna_fake_graph
#define _H_SAMSON_sna_fake_graph


#include <samson/module/samson.h>
#include "sna_environment_parameters.h"


namespace samson{
namespace sna{


	class fake_graph : public samson::Generator
	{
		int num_example;

	public:

		void init(samson::KVWriter *writer)
		{
		  num_example = environment->getInt(SNA_PARAMETER_NUM_EXAMPLE_FAKE_GENERATOR, SNA_PARAMETER_NUM_EXAMPLE_FAKE_GENERATOR_DEFAULT);
		}

		void generateNodes(int *nodes_s , int length, samson::KVWriter *writer )
		{
		  int node;
		  bool extern_node;
		  int links[1000];
		  int weights[1000];
		  int dirs[1000];
		  int pos=-1;

		  for (int i = 0 ; i < length ; i++)
		  {
		    //fprintf(stderr, "Element %d -> %d (pos %d)\n", i , nodes_s[i], pos );

		    if (pos == -1)  //new node...
		    {
		      if ( nodes_s[i] > 0 )
		      {
		        node = nodes_s[i];
		        extern_node = false;
		      }
		      else
		      {
		        node = -nodes_s[i];
		        extern_node = true;
		      }

		      if (node == 0)
		      {
		    	  OLM_E(("Error: (node == 0)"));
		    	  exit(1);
		      }
		      pos++;
		    } else if ( nodes_s[i] == 0)  //End of a node
		    {
		      //Emit node
		      if (pos>0)
		      {
		        //fprintf(stderr, "Emiting %d len%d\n", node , pos);
		        generateNode(node, extern_node,  links, weights, dirs, pos, writer );
		      }
		      pos=-1;
		    } else
		    {
		      //Normal contact
		      if ( nodes_s[i] < 0)
		      {
		        //Soft link
		        links[pos] = -nodes_s[i];
		        weights[pos] = samson::sna::Link::double_2_intScaled(0.5);
		        dirs[pos] = samson::sna::Link::double_2_intScaled(0.5);
		        pos++;
		      }
		      else
		      {
		        //Strong link
		        links[pos] = nodes_s[i];
		        weights[pos] = samson::sna::Link::double_2_intScaled(1.0);
		        dirs[pos] = samson::sna::Link::double_2_intScaled(0.5);
		        pos++;
		      }
		    }

		  }
		}

		void generateNode( int id , bool extern_node,  int* links, int* weight, int* dir, int num, samson::KVWriter *writer)
		{
		  ss:system::UInt node_id;
		  Node node;

		  node_id.value = id;
		  node.id     = id;

		  if( extern_node )
		    node.flags.value    = Node::NODE_FLAG_EXTERN;
		  else
		    node.flags.value    = Node::NODE_FLAG_NONE;

		  node.linksSetLength(num);
		  for (int i = 0 ; i < num ; i++)
		  {
		    node.links[i].id    = links[i];
		    node.links[i].weight  = weight[i];
		    node.links[i].dir  = dir[i];
		  }

		  writer->emit(0, &node_id, &node);

		}

		void run( samson::KVWriter *writer )
		{
			  switch (num_example) {
			    case 1:
			    {
			      /*
			       Nodes of telefonica 1,2,3,4
			       All strongly connected except 1-4 with no-connection
			       */

			      int nodes_s[] = {
			        1,  2,3,    0,
			        2,  1,3,4,    0,
			        3,  1,2,4,    0,
			        4,  2,3,    0,
			      };
			      generateNodes( nodes_s , LENGTH(nodes_s), writer );
			      break;
			    }
			    case 2:
			    {

			      /*
			       Nodes of telefonica 1,2,3,4
			       All strongly connected except 1-4 with soft-connection
			       */

			      int nodes_s[] = {
			        1,   2,3,-4,    0,
			        2,   1,3, 4,    0,
			        3,   1,2, 4,    0,
			        4,  -1,2, 3,    0,
			      };
			      generateNodes( nodes_s , LENGTH(nodes_s), writer );
			      break;
			    }
			    case 3:
			    {

			      /*
			       Nodes of telefonica 2,3
			       Nodes extern    1,4
			       All strongly connected except 1-4 with soft-connection
			       */

			      int nodes_s[] = {
			        -1, 2,3,    0,
			        2,  1,3,4,    0,
			        3,  1,2,4,    0,
			        -4, 2,3,    0,
			      };
			      generateNodes( nodes_s , LENGTH(nodes_s), writer );
			      break;
			    }

			    case 4:
			    {
			      int nodes_s[] = {
			        1,   2, 3,-4,   0,
			        2,   1, 3,      0,
			        3,   1, 2, 4, 5,  0,
			        4,  -1, 3, 5,   0,
			        5,   3, 4,      0,
			      };
			      generateNodes( nodes_s , LENGTH(nodes_s), writer );
			      break;
			    }

			    case 5:
			    {
			      int nodes_s[] = {
			        1,   2, 3,-4,-5,  0,
			        2,   1, 3,-4,     0,
			        3,   1, 2, 4, 5,  0,
			        4,  -1,-2, 3, 5,  0,
			        5,  -1, 3, 4,   0,
			      };
			      generateNodes( nodes_s , LENGTH(nodes_s), writer );
			      break;
			    }


			    case 6:
			    {
			      int nodes_s[] = {
			        1,   2,             0,
			        2,   1, 3,-4,     0,
			        3,   1, 2, 4, 5,  0,
			        4,  -1,-2, 3, 5,  0,
			        5,  -1, 3, 4,   0,
			      };
			      generateNodes( nodes_s , LENGTH(nodes_s), writer );
			      break;
			    }

			    case 7:
			    {
			      int nodes_s[] = {
			        1,  -2,-3,-4, 0,
			        2,  -1,3,4,   0,
			        3,  -1,2,4,   0,
			        4,  -1,2,3,   0,
			      };
			      generateNodes( nodes_s , LENGTH(nodes_s), writer );
			      break;
			    }

			    case 8:
			    {

			      /*
			       Nodes of telefonica 1,2,3,4
			       Nodes 1,2,3 strongly connected to form a clique
			       Node 4 softly connected to all of them to be an associated
			       */
			      int nodes_s[] = {
			        1,  2,3,-4,   0,
			        2,  1,3,-4,   0,
			        3,  1,2,-4,   0,
			        4,  -1,-2,-3, 0,
			      };
			      generateNodes( nodes_s , LENGTH(nodes_s), writer );

			      break;
			    }

			    case 100: //Special for "perfect nodes"
			    {
			      int nodes_s[] = {
			        1,         3, 4, 5, 6, 7, 0,
			        2,         3, 4, 5, 6, 7, 0,
			        3,   1, 2,    4, 5, 6, 7, 0,
			        4,   1, 2, 3,    5, 6, 7, 0,
			        5,   1, 2, 3, 4,    6, 7, 0,
			        6,   1, 2, 3, 4, 5,    7, 0,
			        7,   1, 2, 3, 4, 5, 6,    0,
			      };
			      generateNodes( nodes_s , LENGTH(nodes_s), writer );
			      break;
			    }


			    default:
			      break;
			  }

		}


	};


} // end of namespace samson
} // end of namespace sna

#endif
