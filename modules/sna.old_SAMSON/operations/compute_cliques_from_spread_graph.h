
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_sna_compute_cliques_from_spread_graph
#define _H_SAMSON_sna_compute_cliques_from_spread_graph


#include <samson/Operation.h>
#include "CliquesSolver.h"							// CliquesSolver
#include <samson/modules/system/UInt.h>				// ss::system::UInt
#include <samson/modules/system/Void.h>				// ss::system::Void
#include <samson/modules/graph/Node.h>				// ss::graph::Node
#include <samson/modules/graph/VectorNode.h>		// ss::graph::VectorNode
#include "samson/modules/sna/VectorClique.h"		// ss::sna::VectorClique
#include <iostream>
#include <fstream>


namespace ss{
namespace sna{


	class compute_cliques_from_spread_graph : public ss::Reduce
	{

		CliquesSolver cliquesSolver ;
		ss::system::UInt node_id ;
		
		ss::graph::Node node ;
		ss::graph::VectorNode neighbours ;
		ss::sna::VectorClique cliques ;
		
		ss::system::Void void_data ;
		
		
	public:


		void run(  ss::KVSetStruct* inputs , ss::KVWriter *writer )
		{
			
			// Get the nodeId of the node we are processing (key value)
			ss::system::UInt node_id;		 
			node_id.parse( inputs[0].kvs[0]->key );  
			
			//Get all the values that are the neighbours nodes (if we receive the keynode, we store in a separate element "node")
			neighbours.itemsSetLength(inputs[0].num_kvs);	
		       {
		       std::string filename = "/tmp/compute_cliques_from_spread_graph.log";
		       std::ofstream fs(filename.c_str(), std::ios::app);
		       fs << "neighbours length: " << inputs[0].num_kvs << std::endl;
		       fs.close();
		       }

			size_t pos_neighbours = 0;
			for (size_t i = 0 ; i < inputs[0].num_kvs ; i++)
			{
				neighbours.items[pos_neighbours].parse( inputs[0].kvs[i]->value );
				
				//Recover pointer to the keyNode!
				if ( neighbours.items[pos_neighbours].id == node_id.value )
					node.copyFrom(&neighbours.items[pos_neighbours]);
				else
					pos_neighbours++;
				
			}
			//Make sure we have the correct number of nodes in this vector
			// As we are also emitted in the map, there is one less neighbour than kvs
			assert( pos_neighbours == (inputs[0].num_kvs-1));
			
			
			// Only emmit cliques of "Telefonica" contacts
			//if( node.isExtern() )
			//	return;	
			
			//Get the connection matrix to solve cliques with the rest of elements ( keyNode not included )
			cliquesSolver.clearConnectionsMatrix( inputs[0].num_kvs-1 );
			for (size_t i = 0 ; i < (inputs[0].num_kvs-1) ; i++)
				for (size_t j = i+1 ; j < (inputs[0].num_kvs-1) ; j++)
					if (neighbours.items[i].weightOfLinkWithId( neighbours.items[j].id.value ) >= 1.0 )
						cliquesSolver.setConnection( i , j );
			
			
			//Solve the cliques
			cliquesSolver.solveCliques();
		       {
		       std::string filename = "/tmp/compute_cliques_from_spread_graph.log";
		       std::ofstream fs(filename.c_str(), std::ios::app);
		       fs << "cliquesSolver.num_solutions: " << cliquesSolver.num_solutions << std::endl;
		       fs.close();
		       }
			
			// For each solution, emit the output only if we are the smallest element
			for (int i = 0 ; i  < cliquesSolver.num_solutions ; i++)
			{
				
				// Check if we have to publish ( only if we are the smallest element)
				int pos_first = cliquesSolver.solutions[i].nodes[0];
				size_t first_element = neighbours.items[pos_first].id.value;
				
				
				if( node.id < first_element )	// If you are smaller than the first sub-clique, you should publish it
				{
					
					ss::sna::Clique clique;
					clique.nodesSetLength( cliquesSolver.solutions[i].num_nodes+1 );
					
					//Add the key-node
					clique.nodes[0] = node.id;
					
					for (int j = 0 ; j < cliquesSolver.solutions[i].num_nodes ; j++)
					{
						int pos = cliquesSolver.solutions[i].nodes[j];
						clique.nodes[1+j] = neighbours.items[pos].id;
					}
					
					//Emit the clique
					writer->emit(0,&clique, &void_data);
					
				}
				
			}			
			
		}


	};


} // end of namespace ss
} // end of namespace sna

#endif
