
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_mob_reduce_cdrs_clients
#define _H_SAMSON_mob_reduce_cdrs_clients


#include <samson/module/samson.h>
#include <samson/modules/system/Date.h>
#include <samson/modules/cdr/mobCdr.h>


namespace samson{
namespace mob{


class reduce_cdrs_clients : public samson::Reduce
{

public:
	/**
	 * Sequential number to balance files when the
	 * CDR doesn't bring cell information.
	 */
	size_t seqFakeCellId;
	/**
	 * Month being processed.
	 */
	samson::system::Date mob_month;
	bool hasMonth;

	samson::system::Void void_data;

	/**
	 * Function to reset the fake cell id.
	 */
	void ResetFakeCellId()
	{
		OLM_T(LMT_User06, ("ResetFakeCellId"));
		seqFakeCellId = 0;
	}

	/**
	 * Function to compute a fake cell id,
	 * only useful to balance the size of
	 * the MACRO files.
	 *
	 * @param cellId Pointer to the fake cell id.
	 */
	void GetFakeCellId( samson::system::UInt *cellId )
	{
		seqFakeCellId++;
#define CONF_mob_CELLID_MIN	 100
		if( seqFakeCellId >= CONF_mob_CELLID_MIN )
		{
			seqFakeCellId = 0;
		}
		cellId->value = seqFakeCellId;
	}



#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.UInt64 system.Void
	input: system.UInt64 cdr.mobCdr
	output: system.UInt cdr.mobCdr
	output: system.Time system.Void

	helpLine: Extract only CDRs where the TEF phone is in the client sample.
	extendedHelp: 		Extract only CDRs where the TEF phone is in the client sample.

#endif // de INFO_COMMENT

	/**
	 * Setup function before reducing CDR's.
	 * It calls the function to reset the
	 * value of the "fake" cell id.
	 */
	void init(samson::KVWriter *writer )
	{
		ResetFakeCellId();
		hasMonth = false;
	}

	/**
	 * Reduce CDR's with the clients sample.
	 * Keep only those CDR's where the first phone
	 * belongs to the clients sample. Month being
	 * processed is also emitted for further use.
	 */
	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		samson::cdr::mobCdr cdr;
		samson::system::UInt cellId;

		if( inputs[0].num_kvs > 0 )
		{
			for( int i=0; i<inputs[1].num_kvs; i++ )
			{
				cdr.parse( inputs[1].kvs[i]->value );
				// cellId.value = cdr.cellId;
				// we create fake cell ids in order to balance
				// the size of the files; otherwise, the
				// file_00000 would be too large, since
				// it would store all CDR's that do not
				// have cell info
				if( cdr.cellId.value == 0 )
				{
					GetFakeCellId( &(cellId) );
					OLM_T(LMT_User06, ("For cdr.phone:%lu cdr without cellId, assigns cellId:%lu", cdr.phone.value, cellId.value));
				}
				else
				{
					cellId.value = cdr.cellId.value;
				}
				// get month being processed
				//if( mob_month.month == 0 )
				if(!hasMonth)
				{
					struct tm tm;

					cdr.timeUnix.getCalendarFromTimeUTC(&tm);

					mob_month.unassignAllOptionals();
					mob_month.year.value = tm.tm_year;
					mob_month.month.value = tm.tm_mon;
					mob_month.day.value = 1;

					OLM_T( LMT_User06, ("Month being processed: '%s'\n", mob_month.str().c_str() ));
					// save month for further occasions
					writer->emit(1, &mob_month, &void_data );
					hasMonth = true;
				}
				//OLM_T(LMT_User06, ("For cdr.phone:%lu emits cdr with cellId:%lu", cdr.phone.value, cellId.value));
				writer->emit(0, &cellId, &cdr );
			}
		}
	}

	void finish(samson::KVWriter *writer )
	{
	}



};


} // end of namespace samson
} // end of namespace mob

#endif
