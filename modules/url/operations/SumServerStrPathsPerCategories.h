
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_url_SumServerStrPathsPerCategories
#define _H_SAMSON_url_SumServerStrPathsPerCategories


#include <samson/module/samson.h>

/*************************************************************************************
reduce SumServerStrPathsPerCategories
{
	in system.UInt url.ServerStrPath             # Category(id) - ServerStrPath
	out system.UInt url.ServerStrPathVector      # Category(id) - ServerStrPath

	helpLine "Accumulate the serverStrPath information for the key category, and create a vector"
}
**************************************************************************************/

namespace samson{
namespace url{


	class SumServerStrPathsPerCategories : public samson::Reduce
	{

		samson::system::String serverStr;
		samson::system::UInt catId;
		ServerStrPath serverStrPath;
		ServerStrPath serverStrPathPrev;


	public:


		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
			catId.parse(inputs[0].kvs[0]->key);

			bool first = true;
			size_t n_items = 0;
			ServerStrPathVector paths;

			for (int i = 0; (i < inputs[0].num_kvs); i++)
			{
				serverStrPath.parse(inputs[0].kvs[i]->value);

				if (first || ((!serverStrPath.server.value.compare(serverStrPathPrev.server.value)) && (!serverStrPath.path.value.compare(serverStrPathPrev.path.value))))
				{
					n_items++;
					first = false;
				}
				else
				{
					paths.serverStrPathAdd()->copyFrom(&serverStrPath);
					serverStrPathPrev = serverStrPath;
					n_items = 1;
				}
			}
			paths.serverStrPathAdd()->copyFrom(&serverStrPath);
			paths.countRef = inputs[0].num_kvs;
			writer->emit(0, &catId, &paths);
		}


	};


} // end of namespace samson
} // end of namespace url

#endif
