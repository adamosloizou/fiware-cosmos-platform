
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_url_SumServerStrPathsPerCategories
#define _H_SAMSON_url_SumServerStrPathsPerCategories


#include <samson/samson.h>

/*************************************************************************************
reduce SumServerStrPathsPerCategories
{
	in system.UInt url.ServerStrPath             # Category(id) - ServerStrPath
	out system.UInt url.ServerStrPathVector      # Category(id) - ServerStrPath

	helpLine "Accumulate the serverStrPath information for the key category, and create a vector"
}
**************************************************************************************/

namespace ss{
namespace url{


	class SumServerStrPathsPerCategories : public ss::Reduce
	{

		ss::system::String serverStr;
		ss::system::UInt catId;
		ServerStrPath serverStrPath;
		ServerStrPath serverStrPathPrev;


	public:


		void run(  ss::KVSetStruct* inputs , ss::KVWriter *writer )
		{
			catId.parse(inputs[0].kvs[0]->key);

			bool first = true;
			size_t n_items = 0;
			ServerStrPathVector paths;

			for (int i = 0; (i < inputs[0].num_kvs); i++)
			{
				serverStrPath.parse(inputs[0].kvs[i]->value);

				if (first || ((!serverStrPath.server.value.compare(serverStrPathPrev.server.value)) && (!serverStrPath.path.value.compare(serverStrPathPrev.path.value))))
				{
					n_items++;
					first = false;
				}
				else
				{
					paths.serverStrPathAdd()->copyFrom(&serverStrPath);
					serverStrPathPrev = serverStrPath;
					n_items = 1;
				}
			}
			paths.serverStrPathAdd()->copyFrom(&serverStrPath);
			paths.countRef = inputs[0].num_kvs;
			writer->emit(0, &catId, &paths);
		}


	};


} // end of namespace ss
} // end of namespace url

#endif
