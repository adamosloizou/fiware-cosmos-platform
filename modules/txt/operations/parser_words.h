
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_txt_parser_words
#define _H_SAMSON_txt_parser_words


#include <samson/Operation.h>
#include <samson/Operation.h>
#include <samson/modules/system/SimpleParser.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/UInt.h>
#include <iostream>

namespace ss{
namespace txt{


	class parser_words : public ss::system::SimpleParser
	{
		ss::system::String key;
		ss::system::UInt value;

	public:

		parser_words()
		{
			value.value = 1; // the counter  is always 1
			
		}
		
		void parseLine( char *data , ss::KVWriter *writer )
		{
			

			int pos_begin=0;
			int pos_end;

			while( true )
			{
				while( (data[pos_begin]!='\0') && ((data[pos_begin]==' ') || (data[pos_begin]=='\r') || (data[pos_begin]=='\n')))
				pos_begin++;

				
				if( data[pos_begin] == '\0')
				return;

				pos_end = pos_begin+1;

				while( (data[pos_end]!='\0') && (data[pos_end]!=' ') && (data[pos_end]!='\r') && (data[pos_end]!='\n'))
				pos_end++;

				if( data[pos_end] == '\0' )
				{
					key.value = &data[pos_begin];
					if( key.value.length() > 0 )
						writer->emit( 0 , &key, &value);
					return;
				}
				else
				{
					data[pos_end]='\0';
					key.value = &data[pos_begin];
					if( key.value.length() > 0 )
						writer->emit( 0 , &key, &value);
				}

				pos_begin = pos_end+1;
			}
		}

	};


} // end of namespace ss
} // end of namespace system

#endif
