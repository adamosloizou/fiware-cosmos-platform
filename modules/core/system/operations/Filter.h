
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_SYSTEM_FILTER
#define _H_SAMSON_SYSTEM_FILTER

#include "au/string.h"
#include "au/vector.h"

#include <samson/module/samson.h>
#include <samson/modules/system/Value.h>


namespace samson{
    namespace system{
        
        
        
        class KeyValue
        {
            public:
            
            samson::system::Value* key;
            samson::system::Value* value;
            
            KeyValue( samson::system::Value* _key , samson::system::Value* _value )
            {
                key = _key;
                value = _value;
            }
        };
        
        class Filter
        {
            
        public:
            
            Filter* next; // Pointer to the next filter
            
            
            Filter( )
            {
                next = NULL;
            }
            
            virtual void run( KeyValue kv )=0;
            virtual std::string str()=0;
        };
        
        // --------------------------------------------------------
        // FilterEmit
        // --------------------------------------------------------
        
        class FilterEmit : public Filter
        {
            int channel;
            samson::KVWriter *writer;
            
        public:
            
            FilterEmit( int _channel , samson::KVWriter *_writer )
            {
                writer = _writer;
                channel = _channel;
            }
            
            virtual void run( KeyValue kv )
            {
                //printf("Running emit with '%s'-'%s'\n" , key->str().c_str() , value->str().c_str() );
                writer->emit(channel, kv.key, kv.value );
            }
            
            std::string str()
            {
                return au::str("Emit to channel %d" , channel );
            }
            
            
        };
        
        
        // | select  key:0,key:1  |
        
        class FilterSelectSource
        {
            
        public:
            
            typedef enum
            {
                source_key,              // Selecting key
                source_value,            // Selecting value

                source_key_vector,       // Selecting something in the key   ( assuming it is a vector )
                source_value_vector,     // Selecting something in the value ( assuming it is a vector )

                source_key_map,          // Selecting something in the key   ( assuming it is a map )
                source_value_map,        // Selecting something in the value ( assuming it is a map )
                 
                source_constant,         // Constant value
                
            } Source;
            
            // Used in direct selections
            Source source;
            
            // Used in vector-based selection
            std::vector<FilterSelectSource*> vector_filter_select_source;
            
            // Used in constant value
            samson::system::Value value_constant;      // Used in constant experesions
            FilterSelectSource * select_value_index;   // Used when indexing over a vector or map
            
            // ----------------------------------------------------------------------------
            // FilterSelectSource definitions
            // ----------------------------------------------------------------------------
            
            // "Constants"
            
            // key
            // value
            
            // key[1]
            // value["3"]
            
            // key:[user]
            // value:["user"]
            
            // ----------------------------------------------------------------------------

            FilterSelectSource( std::string constant )
            {
                source = source_constant;
                value_constant.set_constant( constant.c_str() );
            }

            FilterSelectSource( Source _source )
            {
                source = _source;
                select_value_index = NULL;
            }
            
            FilterSelectSource( Source _source , FilterSelectSource* index  )
            {
                source = _source;
                select_value_index = index;
            }
            
            
            static FilterSelectSource* new_source( std::string description )
            {
                printf("FilterSelect source '%s'\n" , description.c_str() );
                                
                if( description.length() == 0)
                    return NULL;
                
                // --------------------------------------------------------------------
                // Constant
                // --------------------------------------------------------------------
                
                if( au::string_begins( description , "'" ) )
                {
                    if( !au::string_ends( description , "'" ) )
                        return NULL;

                    // Get internal description
                    std::string internal_description = au::substring_without_prefix_and_posfix(description, "\"", "\"");
                    
                    return new FilterSelectSource( internal_description );
                }            
                
                // --------------------------------------------------------------------
                // Key selector
                // --------------------------------------------------------------------
                
                if( au::string_begins( description , "key" ) )
                {
                    if( description == "key" )
                        return new FilterSelectSource( source_key ); // Pure key selector
                    
                    if( au::string_begins_and_ends( description, "key[", "]") )
                    {
                        // Vector selector
                        std::string internal_description = au::substring_without_prefix_and_posfix(description, "key[", "]");
                        FilterSelectSource * filter = new_source( internal_description );
                        if( !filter )
                            return NULL;
                        
                        return new FilterSelectSource( source_key_vector , filter );
                    }

                    if( au::string_begins_and_ends( description, "key:[", "]") )
                    {
                        // Vector selector
                        std::string internal_description = au::substring_without_prefix_and_posfix(description, "key:[", "]");
                        FilterSelectSource * filter = new_source( internal_description );
                        if( !filter )
                            return NULL;
                        
                        return new FilterSelectSource( source_key_map , filter );
                    }
                    
                    // Error in format
                    return NULL;
                }

                // --------------------------------------------------------------------
                // value selector
                // --------------------------------------------------------------------
                
                if( au::string_begins( description , "value" ) )
                {
                    if( description == "value" )
                        return new FilterSelectSource( source_key ); // Pure key selector
                    
                    if( au::string_begins_and_ends( description, "value[", "]") )
                    {
                        // Vector selector
                        std::string internal_description = au::substring_without_prefix_and_posfix(description, "key[", "]");
                        FilterSelectSource * filter = new_source( internal_description );
                        if( !filter )
                            return NULL;
                        
                        return new FilterSelectSource( source_key_vector , filter );
                    }
                    
                    if( au::string_begins_and_ends( description, "value:[", "]") )
                    {
                        // Vector selector
                        std::string internal_description = au::substring_without_prefix_and_posfix(description, "value:[", "]");
                        FilterSelectSource * filter = new_source( internal_description );
                        if( !filter )
                            return NULL;
                        
                        return new FilterSelectSource( source_key_map , filter );
                    }
                    
                    // Error in format
                    return NULL;
                }                
                
                // --------------------------------------------------------------------
                // Implicit constant values selector
                // --------------------------------------------------------------------
                
                return new FilterSelectSource( description );
            }
            
            std::string str()
            {
                switch (source) 
                {
                        
                    case source_constant:
                        return value_constant.str();
                        break;
                    case source_key:
                        return "Key";
                    case source_value:
                        return "Value";
                    case source_key_vector:
                        return au::str("Key[%s]" , select_value_index->str().c_str() );
                    case source_value_vector:
                        return au::str("Value[%s]" , select_value_index->str().c_str() );
                    case source_key_map:
                        return au::str("Key:[%s]" , select_value_index->str().c_str() );
                    case source_value_map:
                        return au::str("Value:[%s]" , select_value_index->str().c_str() );
                }
                return "Error";
            }
            
            samson::system::Value* get( KeyValue kv )
            {
                switch ( source ) 
                {
                    case source_constant:
                        return &value_constant;
                        break;
                        
                    case source_key:
                        return kv.key;
                        break;
                        
                    case source_value:
                        return kv.value;
                        break;
                        
                    case source_key_vector:
                    {
                        Value* value_index = select_value_index->get(kv);
                        if (!value_index )
                            return NULL;
                        return kv.key->get_value_from_vector( (size_t)value_index->getDouble() );
                    }
                        
                    case source_value_vector:
                    {
                        Value* value_index = select_value_index->get(kv);
                        if (!value_index )
                            return NULL;
                        return kv.value->get_value_from_vector( (size_t)value_index->getDouble() );
                    }
                        
                    case source_key_map:
                    case source_value_map:
                        LM_X(1, ("Unimplemented"));
                }
                
                LM_X(1, ("Internal error"));
                return NULL;
                
            }
        };
        
        typedef enum
        {
            equal,
            greater_than,
            less_than,
            greater_or_equal_than,
            less_or_equal_than
        } Comparisson;
        
        const char* str_Comparisson( Comparisson c );
        
        class FilterCondition : public Filter
        {
            
            Comparisson c;                        // Type of comparisson
            FilterSelectSource* select_source;    // Left Source 
            FilterSelectSource* select_value;     // Rigth source
            
            double value_reference;
            
        public:
            
            // filter key:2 = 4.56
            FilterCondition( FilterSelectSource* _select_source , Comparisson _c , FilterSelectSource* _select_value  )
            {
                select_source = _select_source;
                c = _c;
                select_value = _select_value;
            }
            
            bool test( KeyValue kv )
            {
                Value * v1 = select_source->get(kv);
                Value * v2 = select_value->get(kv);
                
                if( !v1 || !v2 )
                    return  false; // Not possible to get one of the values
                
                double v1_value = v1->getDouble();
                double v2_value = v2->getDouble();
                
                //printf("Comparing %f - %f\n" , tmp_value , value_reference );
                
                switch (c) 
                {
                    case equal:                 return ( v1_value == v2_value );
                    case greater_than:          return ( v1_value >  v2_value );
                    case less_than:             return ( v1_value <  v2_value );
                    case greater_or_equal_than: return ( v1_value >= v2_value );
                    case less_or_equal_than:    return ( v1_value <= v2_value );
                }
                
                LM_X(1, ("Internal error"));
                return  false;
                
            }
            
            void run( KeyValue kv )
            {
                if( test(kv) )
                    if( next )
                        next->run( kv );
            }
            
            std::string str()
            {
                return au::str("FilterCondition %s %s %s"  , select_source->str().c_str() , str_Comparisson(c) , select_value->str().c_str() );
            }
            
        };
        
        class FilterSelect : public Filter
        {
            
            au::vector<FilterSelectSource> sources_for_key;
            au::vector<FilterSelectSource> sources_for_value;
            
            samson::system::Value _key;
            samson::system::Value _value;

        public:
            
            typedef enum
            {
                vector,        // Multiple components are selected by creating a vector
                join           // Multiple components are selected by joining strings
            } Type;
            

            Type type;
            // | select key:0 key:1 , value:6 |
            
            FilterSelect( Type _type )
            {
                type = _type;
            }
            
            ~FilterSelect()
            {
                sources_for_key.clearVector();
                sources_for_value.clearVector();
            }

            void addComponentForKey( FilterSelectSource* source_for_key )
            {
                sources_for_key.push_back( source_for_key );
            }

            void addComponentForValue( FilterSelectSource* source_for_value )
            {
                sources_for_value.push_back( source_for_value );
            }
            
            std::string str()
            {
                std::ostringstream output;
                output << "Filter select [ ";
                for ( size_t i = 0 ; i < sources_for_key.size() ; i++ )
                    output << sources_for_key[i]->str() << " ";
                output << ", ";
                for ( size_t i = 0 ; i < sources_for_value.size() ; i++ )
                    output << sources_for_value[i]->str() << " ";
                output << "]";
                
                return output.str();
            }
            
            
            void run_individual( Value* v , au::vector<FilterSelectSource>& sources , KeyValue kv )
            {
                
                if( sources.size() == 0)
                {
                    v->set_as_void();
                    return;
                }
                
                if ( sources.size() == 1 )
                {
                    Value* value_source = sources[0]->get(kv);
                    if ( value_source )
                        v->copyFrom( value_source );
                    else
                        v->set_as_void();
                    return;
                }
                

                if( type == vector )
                {
                    // Vector kind of 
                    v->set_as_vector();
                    for( size_t i = 0 ; i < sources.size() ; i++ )
                    {
                        Value* value_source = sources[i]->get(kv);
                        
                        if( value_source )
                            v->add_value_to_vector()->copyFrom( value_source );
                        else
                            v->add_value_to_vector()->set_as_void();
                    }
                }
                else if( type == join )
                {
                    v->set_as_void(); // Nothing
                    for( size_t i = 0 ; i < sources.size() ; i++ )
                    {
                        Value* value_source = sources[i]->get(kv);
                        if( value_source )
                            v->append_string( value_source );
                    }

                    
                }
                
                
                
            }
            
            void run( KeyValue kv )
            {
                // Create new key & value components
                run_individual( &_key   , sources_for_key  , kv );
                run_individual( &_value , sources_for_value  , kv );
                
                if( next )
                {
                    KeyValue kv2( &_key , &_value );
                    next->run(kv2);
                }
            }
        };
        
        /*
         Collections of filter - chains to be executed
         */
        
        class FilterCollection
        {
            
        public:
            
            au::vector<Filter> filters;
            
            ~FilterCollection()
            {
                // Remove defined filters
                filters.clearVector();
            }
            
            std::string str()
            {
                std::ostringstream output;
                for( size_t i = 0 ; i < filters.size() ; i++ )
                    output << filters[i]->str();
                return output.str();
            }
            
            Filter* getFilter( std::string command , samson::KVWriter *writer , au::ErrorManager* error )
            {
                
                au::CommandLine cmdLine;
                cmdLine.parse( command );
                
                // Get the main command
                std::string main_command = cmdLine.get_argument(0);
                
                if ( au::string_begins(main_command, "select") )
                {
                    FilterSelect * filter;
                    
                    if( main_command == "select_join" )
                        filter = new FilterSelect( FilterSelect::join );
                    else if( main_command == "select" )
                        filter = new FilterSelect( FilterSelect::vector );
                    else
                        return NULL;
                    
                    bool selecting_for_key = true;

                    for( int i = 1 ; i < cmdLine.get_num_arguments() ; i++ )
                    {
                        std::string component = cmdLine.get_argument(i);
                        
                        if( component == "," )
                        {
                            selecting_for_key = false;
                            continue;
                        }
                        
                        FilterSelectSource * filter_source = FilterSelectSource::new_source( component );
                        
                        if( filter_source )
                        {
                            
                            if( selecting_for_key )
                                filter->addComponentForKey( filter_source );
                            else
                                filter->addComponentForValue( filter_source );
                        }
                        
                    }

                    // Return created filter
                    return filter;
                }
                else if( main_command == "emit" )
                {
                    if ( cmdLine.get_num_arguments() > 1 )
                        return new FilterEmit( atoi( cmdLine.get_argument(1).c_str() ) , writer );
                    else
                        return new FilterEmit( 0 , writer ); // Default channel "0"
                }
                else if ( main_command == "filter" )
                {
                    if( cmdLine.get_num_arguments() != 4 )
                    {
                        error->set("filter clause with wrong number of arguments");
                        return  NULL;
                    }
                    
                    FilterSelectSource* left_source = FilterSelectSource::new_source( cmdLine.get_argument(1) );
                    if( !left_source )
                    {
                        error->set( au::str("Non valid selector %s" , cmdLine.get_argument(1).c_str() ));
                        return NULL;
                    }
                    
                    FilterSelectSource* rigth_source = FilterSelectSource::new_source( cmdLine.get_argument(3) );
                    if( !rigth_source )
                    {
                        error->set( au::str("Non valid selector %s" , cmdLine.get_argument(3).c_str() ));
                        return NULL;
                    }
                    std::string s = cmdLine.get_argument(2);
                    
                    Comparisson c = equal;
                    if( s == "=" )
                        c = equal;
                    else if( s == "<" )
                        c = less_than;
                    else if( s == ">" )
                        c = greater_than;
                    else if( s == ">=" )
                        c = greater_or_equal_than;
                    else if( s == "<=" )
                        c = less_or_equal_than;
                    else
                    {
                        error->set("filter clause with unknown comparison selector");
                        delete left_source;
                        delete rigth_source;
                        return NULL;
                    }
                    
                    return new FilterCondition( left_source , c , rigth_source );
                }
                
                return NULL;
                
            }
            
            
            // filter key = 67 | select key:1,value | emit 0 / filter key = 56 | select key:1,value | emit 1

            void addFilter( std::string command  , samson::KVWriter *writer , au::ErrorManager* error )
            {
                //printf("adding filter '%s'\n" , command.c_str() );
                
                // Line of filters for this command...
                au::vector<Filter> tmp_filters;
                
                std::vector<std::string> components = au::split(command, '|' );
                for( size_t i = 0 ; i < components.size() ; i++ )
                {
                    Filter * filter = getFilter( components[i] , writer , error );

                    
                    if( !filter )
                    {
                        tmp_filters.clearVector();
                        return; // Error in the filter creation...
                    }
                    else
                        tmp_filters.push_back(filter);
                    
                }
                
                if( tmp_filters.size() == 0 )
                    return;
                
                // Link the filters
                for ( size_t i = 0 ; i < (tmp_filters.size()-1) ; i++ )
                    tmp_filters[i]->next = tmp_filters[i+1];

                // Add the filter line
                filters.push_back( tmp_filters[0] );                
            }
            
            
            void addFilters( std::string command  , samson::KVWriter *writer , au::ErrorManager* error )
            { 
                std::vector<std::string> commands = au::split(command, '#' );
                for( size_t i = 0 ; i < commands.size() ; i++ )
                    addFilter( commands[i] , writer , error );

            }
            
        };
        
    }
}

#endif
