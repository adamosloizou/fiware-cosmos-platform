
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this data
 */

#ifndef _H_SAMSON_system_String
#define _H_SAMSON_system_String

#include <iostream>
#include <sstream>

#ifdef DEBUG_FILES
#include <fstream>
#endif /* de DEBUG_FILES */




namespace samson{
namespace system{


class String : public samson::DataInstance{

public:

    std::string value;

    String() : samson::DataInstance(){

    }

    ~String() {

    }

    std::string getName()
    {
        return "system.String";
    }

    int parse(char *data){
        int pos = 0;
        while( data[pos] != '\0' )
            pos++;
        value = data;
        return pos+1;
    }

    int serialize(char *data){
        int  l = value.length();
        memcpy(data, value.c_str(), l);
        data[l] = '\0';
        return l+1;
    }

    int hash(int max_num_partitions)
    {
        static const size_t InitialFNV = 2166136261U;
        static const size_t FNVMultiple = 16777619;

        size_t hash = InitialFNV;
        for(size_t i = 0; i < value.length(); i++)
        {
            hash = hash ^ (value[i]);       /* xor  the low 8 bits */
            hash = hash * FNVMultiple;      /* multiply by the magic number */
        }
        return hash%max_num_partitions;
    }

    static int size(char *data){
        int pos = 0;
        while( data[pos] != '\0')
            pos++;
        return pos+1;
    }

    inline static int compare(char * data1 , char *data2 , size_t *offset1 , size_t *offset2 )
    {
        char *data1_orig = data1+*offset1;
        char *data2_orig = data2+*offset2;
        int pos1 = 0;

#ifdef DEBUG_FILES
        {
            std::string filename = "/tmp/String_compare.log";
            std::ofstream fs(filename.c_str(), std::ios::app);
            fs << "Compare: (" << data1_orig << ", " << data2_orig << ") offset1: " << *offset1 << ", offset2: " << *offset2 << std::endl;
            fs.close();
        }
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

        while( data1_orig[pos1] != '\0')
            pos1++;

        int pos2 = 0;
        while( data2_orig[pos2] != '\0')
            pos2++;

        *offset1 += pos1+1;
        *offset2 += pos2+1;

#ifdef DEBUG_FILES
        {
            std::string filename = "/tmp/String_compare.log";
            std::ofstream fs(filename.c_str(), std::ios::app);
            fs << "update offset1: " << *offset1 << ", offset2: " << *offset2 << std::endl;
            fs.close();
        }
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
        //if( pos1 < pos2 )
        //   return -1;
        //else if( pos1 > pos2 )
        //   return 1;

        // Same length

        // By extending comparison to the last character ('\0'), we don't have to check lengths
        for (int i = 0 ; i <= pos1 ; i++)
        {
            if ( data1_orig[i] < data2_orig[i] )
                return -1;
            else if ( data1_orig[i] > data2_orig[i] )
                return 1;
        }

        // Same content
        return 0;
    }

    inline static int compare( char* data1 , char* data2 )
    {
        size_t offset_1=0;
        size_t offset_2=0;
        return compare( data1 , data2 , &offset_1 , &offset_2 );
    }

    int serial_compare( char* data1 , char* data2 )
    {
        return compare( data1, data2 );
    }

    int *getDataPath(const std::string &dataPathString){
        return(getDataPathStatic(dataPathString));
    }

    static int *getDataPathStatic(const std::string &dataPathString){
        const char *dataPathCharP = dataPathString.c_str();
        int nlevels = 1;
        int *dataPathIntP;

        const char *p_sep = dataPathCharP;
        while ((p_sep = strchr(p_sep, '.')) != NULL)
        {
            nlevels++;
            p_sep++;
        }

        if ((dataPathIntP = (int *)malloc((nlevels + 1)*sizeof(int))) == NULL)
        {
            return ((int *)NULL);
        }

        int retError = getDataPath(dataPathCharP, dataPathIntP);

        if (retError)
        {
            free(dataPathIntP);
            dataPathIntP = NULL;
        }

        return  (dataPathIntP);
    }

    void setFromString(const char *_data)
    {
        char *p_data_decoded = NULL;
        bool inputStringDecoded=false;

        if (strstr(_data, "%20") != NULL)
        {
            inputStringDecoded = true;

            p_data_decoded = strdup(_data);
            char *p_next_data = p_data_decoded;
            char *p_blank;


            while ((p_blank = strstr(p_next_data, "%20")) != NULL)
            {
                *p_blank++ = ' ';
                strcpy(p_blank, p_blank+strlen("%02")-1);
                p_next_data = p_blank;
            }
        }
        else
        {
            p_data_decoded = (char *)_data;
        }

        char *p_item;
        int length;

        p_item = p_data_decoded;

        if (*p_item == '\"')
        {
            p_item++;
            char *p_next_item = p_item;
            char *p_end;
            length = strlen(p_item);
            while ((p_end = strchr(p_next_item, '\"')) != NULL)
            {
                if (*(p_end-1) != '\\')
                {
                    length = p_end - p_item;
                    break;
                }
                p_next_item = p_end+1;
            }
        }
        else
        {
            p_item = (char *)_data;
            length = strlen(p_item);
        }
        value = std::string(p_item, length) ;
        if (inputStringDecoded)
        {
            free(p_data_decoded);
        }
    }

    static int getDataPath(const char * dataPathCharP, int *dataPathIntP){
        if (*dataPathCharP == 0)
        {
            *dataPathIntP = -1;
            return (0);
        }

        if (strcmp(dataPathCharP, "String") == 0)
        {
            *dataPathIntP = -1;
            return (0);
        }

        return -1;
    }

    std::string getTypeFromPath(const std::string &dataPathString){
        const char *dataPathCharP = dataPathString.c_str();
        return(getTypeFromPathStatic(dataPathCharP));
    }

    static std::string getTypeFromPathStatic(const char * dataPathCharP){
        if (*dataPathCharP == 0)
        {
            return ("system.String");
        }
        if (strcmp(dataPathCharP, ".") == 0)
        {
            return ("system.String");
        }

        if (strcmp(dataPathCharP, "String") == 0)
        {
            return ("system.String");
        }
        return("_ERROR_");
    }

    std::string getTypeFromPath(const int *dataPathIntP){
        return(getTypeFromPathStatic(dataPathIntP));
    }

    static std::string getTypeFromPathStatic(const int *dataPathIntP){
        switch(*dataPathIntP)
        {
        case -1:
            return ("system.String");
            break;
        default:
            return ("_ERROR_");
            break;
            break;
        };
        return "_ERROR_";
    }

    static const char *getTypeStatic()
    {
        return ("system.String");
    }

    const char *getType()
    {
        return ("system.String");
    }

    static bool checkTypeStatic(const char *type)
    {
        if (strcmp(type, "system.String") == 0)
        {
            return true;
        }
        return false;
    }

    bool checkType(const char *type)
    {
        if (strcmp(type, "system.String") == 0)
        {
            return true;
        }
        return false;
    }

    static size_t getHashTypeStatic(){
        return(6957788883659133127ULL);
    }

    size_t getHashType(){
        return(6957788883659133127ULL);
    }

    static bool checkHashTypeStatic(size_t valType){
        if (valType == 6957788883659133127ULL)
        {
            return true;
        }		return false;
    }

    bool checkHashType(size_t valType){
        if (valType == 6957788883659133127ULL)
        {
            return true;
        }		return false;
    }

    DataInstance * getDataInstanceFromPath(const int *dataPathIntP){
        switch(*dataPathIntP)
        {
        case -1:
            return (this);
            break;
        default:
            return (NULL);
            break;
        };
        return NULL;
    }

    void copyFrom( String *other ){
        value = other->value;
    };

    std::string str(){
        return ("\""+value+"\"");
    }

    std::string strJSON(){
         std::ostringstream o;
         String strEscaped;
         strEscaped.value = value;;
         strEscaped.findAndReplace("\\", "\\\\");
         strEscaped.findAndReplace("\"", "\\\"");
         //strEscaped.findAndReplace("\/", "\\/");
         strEscaped.findAndReplace("\b", "\\b");
         strEscaped.findAndReplace("\f", "\\f");
         strEscaped.findAndReplace("\n", "\\n");
         strEscaped.findAndReplace("\r", "\\r");
         strEscaped.findAndReplace("\t", "\\t");
         o << "\""  << strEscaped.value << "\"";
         return o.str();
     }


    std::string strXML(){
        std::ostringstream o;
        o << "<![CDATA[" << value << "]]>" << "\n";
        return o.str();
    }

    std::string strHTML(int level_html_heading){
//        std::ostringstream o;
//        o   << str();
        //o << "<h" <<  level_html_heading << ">" << value << "</h" << level_html_heading << ">";
        return str();
    }

    std::string strHTMLTable(std::string _varNameInternal){
        std::ostringstream o;
		o << "<style>#table-5{font-family:\"Lucida Sans Unicode\", \"Lucida Grande\", Sans-Serif;font-size:12px;background:#fff;border-collapse:collapse;text-align:left;margin:20px;}#table-5 th{text-align:center;font-size:14px;font-weight:normal;color:#039;border-bottom:2px solid #6678b1;padding:10px 8px;}#table-5 td{color:#669;padding:9px 8px 0;}#table-5 tbody tr:hover td{color:#009;}</style>";
        o << "<table id=\"table-5\">\n";
		o << "<caption>" <<  _varNameInternal << "</caption>\n";
		o << "<tr>\n";
		o << "<th>" << _varNameInternal << "</th>\n";
		o << "</tr>\n";
		o << "<tr>\n";
		o << "<th>" << getName() << "</th>\n";
		o << "</tr>\n";
		o << "<td>" << str() << "</td>\n";
		o << "</tr>\n";
		o << "</table>\n";
        return o.str();
    }
	
    std::string paint_header(int init_col)
    {
        return "Term";
    }

    std::string paint_header_basic(int init_col)
    {
        return "Term";
    }

    std::string paint_value(int index_row)
    {
        std::ostringstream o;
        if (index_row >= 0)
        {
            o  << "<td>" << str() << "</td>";
        }
        else
        {
            o  << "<td></td>";
        }
        return o.str();
    }

    int num_fields()
    {
        return 1;
    }

    int num_basic_fields()
    {
        return 1;
    }

    int max_depth()
    {
        return 1;
    }

    int max_num_values()
    {
        return 1;
    }

    bool is_terminal()
    {
        return true;
    }
    void operator= (std::string &_value) {
        value = _value;
    }


    void convertToLowerCase()
    {
        for (size_t i = 0 ; i < value.length() ; i++ )
        {
            char c = (char)value[i];

            if( ( c >= 65 ) && (c<=90))
            {
                value[i] = c + 32;
            }
        }
    }

    bool isStandartWord()
    {
        for (size_t i = 0 ; i < value.length() ; i++ )
        {
            char c = (char)value[i];

            if( ( c >= 97 ) && (c<=122))
            {
                // Lower case letter
                continue;
            }

            if( ( c >= 65 ) && (c<=90))
            {
                // Lower case letter
                continue;
            }

            return false;
        }

        return true;
    }

    bool isMail()
    {
        bool arroba_found = false;
        bool point_found_in_domain = false;

        for (size_t i = 0 ; i < value.length() ; i++ )
        {
            char c = (char)value[i];

            if( c == 64 )
            {
                if( i == 0)
                    return false; // Not starting with "@"

                if ( arroba_found )
                    return false;
                else
                    arroba_found = true;
                continue;
            }

            if( ( c >= 97 ) && (c<=122) )
            {
                // Lower case letter
                continue;
            }

            if( c == '.' )
            {
                if( arroba_found )
                    point_found_in_domain = true;
                continue;
            }
            if( c == '-' )
                continue;
            if( c == '_' )
                continue;

            return false;

        }

        if( arroba_found && point_found_in_domain )
            return true;

        return false;

    }

    void set( const char* str )
    {
        value = str;
    }

    void findAndReplace(std::string strToFind, std::string strToReplace)
    {
        // handle error situations/trivial cases

        if (strToFind.length() == 0) {
            // searching for a match to the empty string will result in
            //  an infinite loop
            //  it might make sense to throw an exception for this case
            return;
        }

        if (value.length() == 0) {
            return;  // nothing to match against
        }

        size_t idx = 0;

        for (;;) {
            idx = value.find( strToFind, idx);
            if (idx == std::string::npos)  break;

            value.replace( idx, strToFind.length(), strToReplace);
            idx += strToReplace.length();
        }
    }

};


} // end of namespace samson
} // end of namespace system

#endif
