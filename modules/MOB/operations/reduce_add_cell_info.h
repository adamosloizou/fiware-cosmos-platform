
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_MOB_reduce_add_cell_info
#define _H_SAMSON_MOB_reduce_add_cell_info


#include <samson/module/samson.h>
#include <samson/modules/system/Date.h>
#include <samson/modules/system/Time.h>
#include <samson/modules/system/ComplexTimeSlot.h>

#include "mob_environment_parameters.h"


namespace samson{
namespace MOB{


class reduce_add_cell_info : public samson::Reduce
{

	samson::system::ComplexTimeSlot ctsH;
	samson::system::ComplexTimeSlot ctsW;

	samson::system::UInt key;
	samson::system::UInt64 phone;
	samson::cdr::mobCdr cdr;
	samson::cdr::Cell cell;
	CellCounter cellCounter;

	samson::system::Date lDate;
	samson::system::Time lTime;


public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.UInt cdr.mobCdr
	input: system.UInt cdr.Cell
	output: system.UInt64 cdr.mobCdr
	output: system.UInt64 cdr.Cell
	output: system.UInt64 CellCounter
	output: system.UInt64 CellCounter

	helpLine: Keep only CDRs with known cell id and add cell info from the catalogue.
	extendedHelp: 		Keep only CDRs with known cell id and add cell info from the catalogue.

#endif // de INFO_COMMENT


	/**
	 * Setup function before adding cell info to CDR's.
	 * It initializes the timeslot objects.
	 */
	void init(samson::KVWriter *writer )
	{

		// HOME
		// Mon-Thu from 21:00:00 to 23:59:59
		// Sat-Sun from 08:00:00 to 12:59:59
		std::string conf_timeslot_home = environment->get(MOB_PARAMETER_CONF_TIMESLOT_HOME, MOB_PARAMETER_CONF_TIMESLOT_HOME_DEFAULT);
		ctsH.set( conf_timeslot_home );

		// WORK
		// Mon-Fri from 09:00:00 to 14:59:59
		std::string conf_timeslot_work = environment->get(MOB_PARAMETER_CONF_TIMESLOT_WORK, MOB_PARAMETER_CONF_TIMESLOT_WORK_DEFAULT);
		ctsW.set( conf_timeslot_work );

		OLM_T(LMT_User06, ("init with '%s' and '%s'\n", conf_timeslot_home.c_str(), conf_timeslot_work.c_str()));
	}

	/**
	 * Reduce CDR's with the cell catalogue and add
	 * cell information.
	 */
	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{


		if( inputs[0].num_kvs > 0 )
		{
			if( inputs[1].num_kvs > 0 )
			{
				// CDR has its corresponding cell in the catalogue
				cell.parse( inputs[1].kvs[0]->value );
			}
			else
			{
				// CDR does not have its corresponding cell in the catalogue
				// we assign the null cell
				cell.cellId = 0;
				cell.btsId = 0;
				cell.lacId = 0;
				cell.stateId = 0;
			}

			key.parse(inputs[0].kvs[0]->key);

			//OLM_T(LMT_User06, ("Process key:0x%0x with cell:0x%0x with inputs[0].num_kvs:%lu", key.value, cell.cellId.value, inputs[0].num_kvs))
			for( int i=0; i<inputs[0].num_kvs; i++ )
			{
				cdr.parse( inputs[0].kvs[i]->value );

				// IDEA:
				// At this point, we could discard cdrs that neither
				// have cell information nor have mobility scope
				// information, because they are useless both
				// for mobility degree and place of home and work.
				// Must be studied in detail anyway.

				// fill only cell values
				cdr.cellId.value = cell.cellId.value;
				cdr.btsId.value = cell.btsId.value;
				cdr.lacId.value = cell.lacId.value;
				cdr.stateId.value = cell.stateId.value;

				// get phone number
				phone.value = cdr.phone.value;

#ifdef PARA_LUEGO
				// include also the day of the week and the absolute day
				//cdr.date.computeDayOfTheWeek();
				mobComputeDayOfTheWeek( &cdr.date );
				mobComputeAbsoluteDay( &cdr.date, &cdr.absDay );
#endif // de PARA_LUEGO

				// emit first output to keep complete cdrs
				writer->emit(0, &phone, &cdr );



#ifdef PARA_LUEGO
				phoneLoc.phone.value = phone.value;

				// mobility degree

				// cell level
				// fill structure
				phoneLoc.loc = cdr.cellId;
				// emit output to compute the reference cell
				writer[1]->emit( &phoneLoc, &void_data );

				// bts level
				// fill structure
				phoneLoc.loc = cdr.btsId;
				// emit output to compute the reference cell
				writer[2]->emit( &phoneLoc, &void_data );

				// lac level
				// fill structure
				phoneLoc.loc = cdr.lacId;
				// emit output to compute the reference cell
				writer[3]->emit( &phoneLoc, &void_data );

				// state level
				// fill structure
				phoneLoc.loc = cdr.stateId;
				// emit output to compute the reference cell
				writer[4]->emit( &phoneLoc, &void_data );
#endif // de PARA_LUEGO

				writer->emit(1, &phone, &cell);

				// for place of home and work, we can do nothing if
				// we do not have cell information
				if( cdr.cellId > 0 )
				{

					cellCounter.cell = cell;

					//OLM_T(LMT_User06, ("timeUnix :%s", cdr.timeUnix.str().c_str()));

					cdr.timeUnix.getDateTimeFromTimeUTC(&lDate, &lTime);

					if (lDate.days_2000_GetAssigned() == false)
					{
						lDate.daysFrom2000_01_01();
						//OLM_T(LMT_User06, ("For key:0x%0x computes days_2000", key.value));

					}
					cellCounter.count = lDate.days_2000;


					// emit CDR's for the place of home
					if( ctsH.includes( &lDate, &lTime ) == true )
					{

#ifdef PARA_LUEGO
						phoneLocCounter.phone.value = phone.value;
						phoneLocCounter.count = cdr.absDay;

						// cell level
						phoneLocCounter.loc = cdr.cellId;
						writer[5]->emit( &phoneLocCounter, &void_data );
						// bts level
						phoneLocCounter.loc = cdr.btsId;
						writer[6]->emit( &phoneLocCounter, &void_data );
						// lac level
						phoneLocCounter.loc = cdr.lacId;
						writer[7]->emit( &phoneLocCounter, &void_data );
						// state level
						phoneLocCounter.loc = cdr.stateId;
						writer[8]->emit( &phoneLocCounter, &void_data );
#endif // de PARA_LUEGO
						writer->emit(2, &phone, &cellCounter);
						OLM_T(LMT_User06, ("For key:0x%0x time:'%s' detects home", key.value, cdr.timeUnix.str().c_str()));
					}

					// emit CDR's for the place of work
					if( ctsW.includes( &lDate, &lTime ) == true )
					{
#ifdef PARA_LUEGO
						phoneLocCounter.phone.value = phone.value;
						phoneLocCounter.count = cdr.absDay;

						// cell level
						phoneLocCounter.loc = cdr.cellId;
						writer[9]->emit( &phoneLocCounter, &void_data );
						// bts level
						phoneLocCounter.loc = cdr.btsId;
						writer[10]->emit( &phoneLocCounter, &void_data );
						// lac level
						phoneLocCounter.loc = cdr.lacId;
						writer[11]->emit( &phoneLocCounter, &void_data );
						// state level
						phoneLocCounter.loc = cdr.stateId;
						writer[12]->emit( &phoneLocCounter, &void_data );
#endif // de PARA_LUEGO

						writer->emit(3, &phone, &cellCounter);
						OLM_T(LMT_User06, ("For key:0x%0x time:'%s' detects work", key.value, cdr.timeUnix.str().c_str()));

					}
				}
				else
				{
					//OLM_T(LMT_User06, ("No cell info for key:0x%0x, phone:%lu", key.value, phone.value));
				}
			}
		}
	}

	void finish(samson::KVWriter *writer )
	{
	}



};


} // end of namespace samson
} // end of namespace MOB

#endif
