
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_MOB_reduce_add_cell_info
#define _H_SAMSON_MOB_reduce_add_cell_info


#include <samson/module/samson.h>
#include <samson/modules/system/Date.h>
#include <samson/modules/system/Time.h>
#include <samson/modules/system/ComplexTimeSlot.h>

#include "mob_environment_parameters.h"


namespace samson{
namespace MOB{


class reduce_add_cell_info : public samson::Reduce
{

	samson::system::ComplexTimeSlot ctsH;
	samson::system::ComplexTimeSlot ctsW;
public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.UInt cdr.mobCdr
	input: system.UInt cdr.Cell
	output: system.UInt64 cdr.mobCdr
	output: system.UInt64 cdr.Cell
	output: system.UInt64 CellCounter
	output: system.UInt64 CellCounter

	helpLine: Keep only CDRs with known cell id and add cell info from the catalogue.
	extendedHelp: 		Keep only CDRs with known cell id and add cell info from the catalogue.

#endif // de INFO_COMMENT


	/**
	 * Setup function before adding cell info to CDR's.
	 * It initializes the timeslot objects.
	 */
	void init(samson::KVWriter *writer )
	{

		// HOME
		// Mon-Thu from 21:00:00 to 23:59:59
		// Sat-Sun from 08:00:00 to 12:59:59
		std::string conf_timeslot_home = environment->get(MOB_PARAMETER_CONF_TIMESLOT_HOME, MOB_PARAMETER_CONF_TIMESLOT_HOME_DEFAULT);
		ctsH.set( conf_timeslot_home );

		// WORK
		// Mon-Fri from 09:00:00 to 14:59:59
		std::string conf_timeslot_work = environment->get(MOB_PARAMETER_CONF_TIMESLOT_WORK, MOB_PARAMETER_CONF_TIMESLOT_WORK_DEFAULT);
		ctsW.set( conf_timeslot_work );
	}

	/**
	 * Reduce CDR's with the cell catalogue and add
	 * cell information.
	 */
	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		samson::system::UInt64 phone;
		samson::cdr::mobCdr cdr;
		samson::cdr::Cell cell;
		CellCounter cellCounter;

		if( inputs[0].num_kvs > 0 )
		{
			if( inputs[1].num_kvs > 0 )
			{
				// CDR has its corresponding cell in the catalogue
				cell.parse( inputs[1].kvs[0]->value );
			}
			else
			{
				// CDR does not have its corresponding cell in the catalogue
				// we assign the null cell
				cell.cellId = 0;
				cell.btsId = 0;
				cell.lacId = 0;
				cell.stateId = 0;
			}

			for( int i=0; i<inputs[0].num_kvs; i++ )
			{
				cdr.parse( inputs[0].kvs[i]->value );

				// IDEA:
				// At this point, we could discard cdrs that neither
				// have cell information nor have mobility scope
				// information, because they are useless both
				// for mobility degree and place of home and work.
				// Must be studied in detail anyway.

				// fill only cell values
				cdr.cellId.value = cell.cellId.value;
				cdr.btsId.value = cell.btsId.value;
				cdr.lacId.value = cell.lacId.value;
				cdr.stateId.value = cell.stateId.value;

				// get phone number
				phone.value = cdr.phone.value;

#ifdef PARA_LUEGO
				// include also the day of the week and the absolute day
				//cdr.date.computeDayOfTheWeek();
				mobComputeDayOfTheWeek( &cdr.date );
				mobComputeAbsoluteDay( &cdr.date, &cdr.absDay );
#endif // de PARA_LUEGO

				// emit first output to keep complete cdrs
				writer->emit(0, &phone, &cdr );



#ifdef PARA_LUEGO
				phoneLoc.phone.value = phone.value;

				// mobility degree

				// cell level
				// fill structure
				phoneLoc.loc = cdr.cellId;
				// emit output to compute the reference cell
				writer[1]->emit( &phoneLoc, &void_data );

				// bts level
				// fill structure
				phoneLoc.loc = cdr.btsId;
				// emit output to compute the reference cell
				writer[2]->emit( &phoneLoc, &void_data );

				// lac level
				// fill structure
				phoneLoc.loc = cdr.lacId;
				// emit output to compute the reference cell
				writer[3]->emit( &phoneLoc, &void_data );

				// state level
				// fill structure
				phoneLoc.loc = cdr.stateId;
				// emit output to compute the reference cell
				writer[4]->emit( &phoneLoc, &void_data );
#endif // de PARA_LUEGO

				writer->emit(1, &phone, &cell);


				// for place of home and work, we can do nothing if
				// we do not have cell information
				if( cdr.cellId > 0 )
				{
					samson::system::Date date;
					samson::system::Time time;

					cdr.timeUnix.getDateTimeFromTimeUTC(&date, &time);

					cellCounter.cell = cell;
					if (date.days_2000_GetAssigned() == false)
					{
						date.daysFrom2000_01_01();
					}
					cellCounter.count = date.days_2000;

					// emit CDR's for the place of home
					if( ctsH.includes( &date, &time ) == true )
					{

#ifdef PARA_LUEGO
						phoneLocCounter.phone.value = phone.value;
						phoneLocCounter.count = cdr.absDay;

						// cell level
						phoneLocCounter.loc = cdr.cellId;
						writer[5]->emit( &phoneLocCounter, &void_data );
						// bts level
						phoneLocCounter.loc = cdr.btsId;
						writer[6]->emit( &phoneLocCounter, &void_data );
						// lac level
						phoneLocCounter.loc = cdr.lacId;
						writer[7]->emit( &phoneLocCounter, &void_data );
						// state level
						phoneLocCounter.loc = cdr.stateId;
						writer[8]->emit( &phoneLocCounter, &void_data );
#endif // de PARA_LUEGO
						writer->emit(2, &phone, &cellCounter);
					}

					// emit CDR's for the place of work
					if( ctsW.includes( &date, &time ) == true )
					{
#ifdef PARA_LUEGO
						phoneLocCounter.phone.value = phone.value;
						phoneLocCounter.count = cdr.absDay;

						// cell level
						phoneLocCounter.loc = cdr.cellId;
						writer[9]->emit( &phoneLocCounter, &void_data );
						// bts level
						phoneLocCounter.loc = cdr.btsId;
						writer[10]->emit( &phoneLocCounter, &void_data );
						// lac level
						phoneLocCounter.loc = cdr.lacId;
						writer[11]->emit( &phoneLocCounter, &void_data );
						// state level
						phoneLocCounter.loc = cdr.stateId;
						writer[12]->emit( &phoneLocCounter, &void_data );
#endif // de PARA_LUEGO

						writer->emit(3, &phone, &cellCounter);
					}
				}
			}
		}
	}

	void finish(samson::KVWriter *writer )
	{
	}



};


} // end of namespace samson
} // end of namespace MOB

#endif
