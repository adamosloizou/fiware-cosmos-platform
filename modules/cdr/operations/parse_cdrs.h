
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_cdr_sna_parse_cdrs
#define _H_SAMSON_cdr_sna_parse_cdrs


#include <samson/Operation.h>

#define DEBUG_FILES
#ifdef DEBUG_FILES
#include <iostream>
#include <fstream>
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

namespace ss{
namespace cdr{


	//Macros to parte CDRs
	#define CHAR_TO_INT(v) (v-48)

	#define GET_CDRS_INIT	int pos=0; int pos_field=0;
	#define GET_CDRS_NEXT_FIELD pos_field=pos; while( line[pos] != '|' ) pos++; line[pos]='\0'; pos++;
	#define GET_CDRS_GET_NUMBER		 atoll( &line[pos_field] );
	
bool parseDate_TME (char *dateTxt, Date *date, Time *time)
{

        if (strlen(dateTxt) != 17) return false;

        date->day           = CHAR_TO_INT( dateTxt[0] ) *10 + CHAR_TO_INT( dateTxt[1] );
        date->month         = CHAR_TO_INT( dateTxt[3] ) *10 + CHAR_TO_INT( dateTxt[4] );
        date->year          = CHAR_TO_INT( dateTxt[6] ) *10 + CHAR_TO_INT( dateTxt[7] );

        time->hour          = CHAR_TO_INT( dateTxt[9] ) *10 + CHAR_TO_INT( dateTxt[10] );
        time->minute        = CHAR_TO_INT( dateTxt[12] ) *10 + CHAR_TO_INT( dateTxt[13] );
        time->seconds       = CHAR_TO_INT( dateTxt[15] ) *10 + CHAR_TO_INT( dateTxt[16] );

        return true;
}

bool parseDate_O2UK (char *dateTxt, Date *date, Time *time)
{
        if (strlen(dateTxt) != 14)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
		{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing Date:" << dateTxt << " strlen: " << strlen(dateTxt) << std::endl;
                fs.close();
		}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        const int YEAR_2000 = 2000;

        date->year          = (CHAR_TO_INT( dateTxt[0] ) *1000 + CHAR_TO_INT( dateTxt[1] ) *100 + CHAR_TO_INT( dateTxt[2] ) *10 + CHAR_TO_INT( dateTxt[3] )) - YEAR_2000;
        date->month         = CHAR_TO_INT( dateTxt[4] ) *10 + CHAR_TO_INT( dateTxt[5] );
        date->day           = CHAR_TO_INT( dateTxt[6] ) *10 + CHAR_TO_INT( dateTxt[7] );


        time->hour          = CHAR_TO_INT( dateTxt[8] ) *10 + CHAR_TO_INT( dateTxt[9] );
        time->minute        = CHAR_TO_INT( dateTxt[10] ) *10 + CHAR_TO_INT( dateTxt[11] );
        time->seconds       = CHAR_TO_INT( dateTxt[12] ) *10 + CHAR_TO_INT( dateTxt[13] );
        return true;
}


int daysFrom2000_01_01(Date date)
{
	/* As a side effect, computes and stores the days_2000 and week_day fields */

        int duration_days = int(date.day.value);
        int offsetBisiesto = 0;

#ifdef CALCULO_EXACTO
        if ((date.year.toInt()%4 == 0) && ((date.year.toInt()%100 != 0) || (date.year.toInt()%400 == 0)))
#else
                // OK if we start from 2000 year, and expect to last no more than one 99 years
                if (date.year.toInt()%4 == 0)
#endif // de CALCULO_EXACTO
                {
                        offsetBisiesto = 1;
                }

        switch (date.month.toInt())
        {
        case 1:
                break;
        case 2:
                duration_days += 31;
                break;
        case 3:
                duration_days += 59 + offsetBisiesto;
                break;
        case 4:
                duration_days += 90 + offsetBisiesto;
                break;
        case 5:
                duration_days += 120 + offsetBisiesto;
                break;
        case 6:
                duration_days += 151 + offsetBisiesto;
                break;
        case 7:
                duration_days += 181 + offsetBisiesto;
                break;
        case 8:
                duration_days += 212 + offsetBisiesto;
                break;
        case 9:
                duration_days += 243 + offsetBisiesto;
                break;
        case 10:
                duration_days += 273 + offsetBisiesto;
                break;
        case 11:
                duration_days += 304 + offsetBisiesto;
                break;
        case 12:
                duration_days += 334 + offsetBisiesto;
                break;
        }
        const int YEAR_2000 = 2000;
        const int DAYS_PER_YEAR = 365;
        const int SECS_PER_DAY = 86400;

        duration_days += DAYS_PER_YEAR * (date.year.toInt()) + ((date.year.toInt() - 1) / 4) + 1;
	duration_days--; // In order to not include the present day

	date.days_2000 = duration_days;

	const int DAYS_PER_WEEK = 7;
	const int DAYWEEK_20000101 = 6; // The 01-01-2000 was Saturday; we take Sunday as 0

	date.week_day = (duration_days + DAYWEEK_20000101)%DAYS_PER_WEEK;

#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "WeekDay: " << int(date.week_day.value) << ", for year: " << int(date.year.value) << ", month: " << int(date.month.value) << ", day: " << int(date.day.value) << ", Total: " << int(date.days_2000.value) << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
}

int secsFrom2000_01_01(Date date, Time time)
{
        int duration_secs = time.seconds.toInt()+ 60 * time.minute.toInt() + 3600 * time.hour.toInt();

        int duration_days = daysFrom2000_01_01(date); // As a side effect, computes and stores the days_2000 and week_day fields

        const int SECS_PER_DAY = 86400;

        duration_secs += SECS_PER_DAY * duration_days;
}
	
	bool getCDRFromLine_TME( char *line, ss::system::UInt* node, ss::cdr::CDR * cdr )
	{
		//LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"	
		//Note: multihtread save implementation
		
		GET_CDRS_INIT
		
		GET_CDRS_NEXT_FIELD		
		//First field useless
		
		GET_CDRS_NEXT_FIELD
		*node = (size_t) GET_CDRS_GET_NUMBER;
		
		GET_CDRS_NEXT_FIELD
		cdr->node = (size_t) GET_CDRS_GET_NUMBER;
		
		
		GET_CDRS_NEXT_FIELD
		cdr->date.day		= CHAR_TO_INT( line[pos_field+0] ) *10 + CHAR_TO_INT( line[pos_field+1] );
		cdr->date.month		= CHAR_TO_INT( line[pos_field+3] ) *10 + CHAR_TO_INT( line[pos_field+4] );
		cdr->date.year		= CHAR_TO_INT( line[pos_field+6] ) *10 + CHAR_TO_INT( line[pos_field+7] );
		
		cdr->time.hour		= CHAR_TO_INT( line[pos_field+9] ) *10 + CHAR_TO_INT( line[pos_field+10] );
		cdr->time.minute	= CHAR_TO_INT( line[pos_field+12] ) *10 + CHAR_TO_INT( line[pos_field+13] );
		cdr->time.seconds	= CHAR_TO_INT( line[pos_field+15] ) *10 + CHAR_TO_INT( line[pos_field+16] );
		
		GET_CDRS_NEXT_FIELD
		cdr->duration = (size_t) GET_CDRS_GET_NUMBER;
		
		
		//Global Checking...
		if(cdr->node <= 0)				return false;
		if(node->value <= 0)			return false;
		if(node->value == cdr->node.value)	return false;
		
		return true;
	}
	
bool getCDRFromLine_O2UK_p2p( char *line, ss::system::UInt* node, ss::cdr::CDR * cdr)
{
        //LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
        //Note: multihtread save implementation

        const int nMaxFields=134;
        const int lMaxField=64;
        char field[nMaxFields][lMaxField];
        int nField = 0;
        int nTotalFields = 0;

        char *pField = line;
        char *pSep;

        while((pSep = strchr(pField, '|')) != NULL)
        {
                if (nField >= nMaxFields)
                {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                if ((pSep - pField) > (lMaxField - 1))
                {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; field: " << nField << " longer than lMaxField: " << lMaxField << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                else
                {
                        *pSep = '\0';
                        strcpy(field[nField], pField);
                        nField++;
                        *pSep = '|';
                        pField = pSep+1;
                }
        }
        if (nField >= nMaxFields)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        strcpy(field[nField], pField);
        nTotalFields = nField+1;

        //Fields of interest (for mms type file):
        //18: Calling ID
        //24: Called ID
        //29: Submit Date
        //4: Done Date

        const int CALLING_ID_FIELD = 18;
        const int CALLED_ID_FIELD = 24;
        const int SUBMIT_DATE_FIELD = 29;
        const int DONE_DATE_FIELD = 4;


        *node = (size_t) atoll(field[CALLING_ID_FIELD - 1]);
        cdr->node = (size_t) atoll(field[CALLED_ID_FIELD - 1]);

        char *pDateSubmit = field[SUBMIT_DATE_FIELD - 1];
        char *pDateDone = field[DONE_DATE_FIELD - 1];
        ss::cdr::Date dateDone;
        ss::cdr::Time timeDone;

        if (!parseDate_O2UK(pDateSubmit, &(cdr->date), &(cdr->time)))
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateSubmit" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        if (!parseDate_O2UK(pDateDone, &(dateDone), &(timeDone)))
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateDone" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        int secsSubmit = secsFrom2000_01_01(cdr->date, cdr->time);
        int secsDone = secsFrom2000_01_01(dateDone, timeDone);

        cdr->duration = secsDone - secsSubmit;

        if (cdr->duration < 0)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing duration: " << cdr->duration.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        //Global Checking...
        if(cdr->node <= 0)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing cdr->node: " << cdr->node.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value <= 0)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value == cdr->node.value)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << " == " << cdr->node.value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }

        return true;
}

bool getCDRFromLine_O2UK_smsc( char *line, ss::system::UInt* node, ss::cdr::CDR * cdr)
{
        //LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
        //Note: multihtread save implementation

        const int nMaxFields=134;
        const int lMaxField=64;
        char field[nMaxFields][lMaxField];
        int nField = 0;
        int nTotalFields = 0;

        char *pField = line;
        char *pSep;

        while((pSep = strchr(pField, '|')) != NULL)
        {
                if (nField >= nMaxFields)
                {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                if ((pSep - pField) > (lMaxField - 1))
                {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; field: " << nField << " longer than lMaxField: " << lMaxField << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                else
                {
                        *pSep = '\0';
                        strcpy(field[nField], pField);
                        nField++;
                        *pSep = '|';
                        pField = pSep+1;
                }
        }
        if (nField >= nMaxFields)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        strcpy(field[nField], pField);
        nTotalFields = nField+1;

        //Fields of interest (for mms type file):
        //7: Calling ID
        //8: Called ID
        //15: Submit Date
        //17: Done Date

        const int CALLING_ID_FIELD = 7;
        const int CALLED_ID_FIELD = 8;
        const int SUBMIT_DATE_FIELD = 15;
        const int DONE_DATE_FIELD = 17;


        *node = (size_t) atoll(field[CALLING_ID_FIELD - 1]);
        cdr->node = (size_t) atoll(field[CALLED_ID_FIELD - 1]);

        char *pDateSubmit = field[SUBMIT_DATE_FIELD - 1];
        char *pDateDone = field[DONE_DATE_FIELD - 1];
        ss::cdr::Date dateDone;
        ss::cdr::Time timeDone;

        if (!parseDate_O2UK(pDateSubmit, &(cdr->date), &(cdr->time)))
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateSubmit" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        if (!parseDate_O2UK(pDateDone, &(dateDone), &(timeDone)))
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateDone" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        int secsSubmit = secsFrom2000_01_01(cdr->date, cdr->time);
        int secsDone = secsFrom2000_01_01(dateDone, timeDone);

        cdr->duration = secsDone - secsSubmit;

        if (cdr->duration < 0)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing duration: " << cdr->duration.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        //Global Checking...
        if(cdr->node <= 0)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing cdr->node: " << cdr->node.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value <= 0)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value == cdr->node.value)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << " == " << cdr->node.value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }

        return true;
}
bool getCDRFromLine_O2UK_mms( char *line, ss::system::UInt* node, ss::cdr::CDR * cdr)
{
        //LINE --> "1|689644587|685015313|01/09/08 18:52:44|123|2|2"
        //Note: multihtread save implementation

        const int nMaxFields=134;
        const int lMaxField=64;
        char field[nMaxFields][lMaxField];
        int nField = 0;
        int nTotalFields = 0;

        char *pField = line;
        char *pSep;

        while((pSep = strchr(pField, '|')) != NULL)
        {
                if (nField >= nMaxFields)
                {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                if ((pSep - pField) > (lMaxField - 1))
                {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                        std::string filename = "/tmp/parser_cdrs.log";
                        std::ofstream fs(filename.c_str(), std::ios::app);
                        fs << "Error parsing CDR; field: " << nField << " longer than lMaxField: " << lMaxField << std::endl;
                        fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                        return false;
                }
                else
                {
                        *pSep = '\0';
                        strcpy(field[nField], pField);
                        nField++;
                        *pSep = '|';
                        pField = pSep+1;
                }
        }
        if (nField >= nMaxFields)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing CDR; too many fields. nField:" << nField << " >= nMaxFields: " << nMaxFields << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        strcpy(field[nField], pField);
        nTotalFields = nField+1;

        //Fields of interest (for mms type file):
        //9: Calling ID
        //11: Called ID
        //unknown: Submit Date
        //unknown: Done Date

        const int CALLING_ID_FIELD = 9;
        const int CALLED_ID_FIELD = 11;
        //const int SUBMIT_DATE_FIELD = 29;
        //const int DONE_DATE_FIELD = 4;


        char *psep;
        if ((psep = strchr(field[CALLING_ID_FIELD - 1], '\\')) != NULL)
        {
                *psep = '\0';
        }
        if ((psep = strchr(field[CALLING_ID_FIELD - 1], '\\')) != NULL)
        {
                *psep = '\0';
        }

        *node = (size_t) atoll(field[CALLING_ID_FIELD - 1]);
        cdr->node = (size_t) atoll(field[CALLED_ID_FIELD - 1]);

#ifdef DATES_KNOWN
        char *pDateSubmit = field[SUBMIT_DATE_FIELD - 1];
        char *pDateDone = field[DONE_DATE_FIELD - 1];
        ss::cdr::Date dateDone;
        ss::cdr::Time timeDone;

        if (!parseDate_O2UK(pDateSubmit, &(cdr->date), &(cdr->time)))
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateSubmit" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
        if (!parseDate_O2UK(pDateDone, &(dateDone), &(timeDone)))
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "Error parsing DateDone" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }

        int secsSubmit = secsFrom2000_01_01(cdr->date, cdr->time);
        int secsDone = secsFrom2000_01_01(dateDone, timeDone);

        cdr->duration = secsDone - secsSubmit;

        if (cdr->duration < 0)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing duration: " << cdr->duration.toInt() << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES
                return false;
        }
#endif /* de DATE_KNOWN */
#undef DEBUG_FILES

        //Global Checking...
        if(cdr->node <= 0)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing cdr->node: " << cdr->node.toInt() << "field:'" << field[CALLED_ID_FIELD - 1] << "'" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value <= 0)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << "field:'" << field[CALLING_ID_FIELD - 1] << "'" << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }
        if(node->value == cdr->node.value)
        {
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str(), std::ios::app);
                fs << "ERROR computing node->value: " << node->value << " == " << cdr->node.value << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

                return false;
        }

        return true;
}

	
	class parse_cdrs : public ss::Parser
	{

	public:

		ss::system::UInt node;	// Main telephone number
		ss::cdr::CDR cdr;		// All information related with this
		
		void run( char *data , size_t length , ss::KVWriter *writer )
		{
			
			size_t line_begin = 0;
			size_t offset = 0;
			enum CDRsSources { TME, O2UKsmsc, O2UKmms, O2UKp2p };
			CDRsSources codSource;

			std::string source = environment->get( "cdr.CDRs_source", "TME");
			
#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str());
                fs << "Detected source: " << source << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

			if (!source.compare("TME"))
			{
				codSource = TME;
			}
			else if (!source.compare("O2UKsmsc"))
			{
				codSource = O2UKsmsc;
			}
			else if (!source.compare("O2UKmms"))
			{
				codSource = O2UKmms;
			}
			else if (!source.compare("O2UKp2p"))
			{
				codSource = O2UKp2p;
			}


#define DEBUG_FILES
#ifdef DEBUG_FILES
			{
                std::string filename = "/tmp/parser_cdrs.log";
                std::ofstream fs(filename.c_str());
                fs << "Process length: " << length << std::endl;
                fs.close();
			}
#endif /* de DEBUG_FILES */
#undef DEBUG_FILES

			while( offset < length )
			{
				if( data[offset] == '\n' || data[offset] == '\0' )
				{
					data[offset] = '\0';
					//LM_M(("Process line"));
					
					// Process line
					switch (codSource)
					{
					case TME:
						if( getCDRFromLine_TME( data+line_begin , &node , &cdr ) )
							writer->emit( 0 , &node , &cdr );
						break;
					case O2UKsmsc:
						if( getCDRFromLine_O2UK_smsc( data+line_begin , &node , &cdr ) )
							writer->emit( 0 , &node , &cdr );
						break;
					case O2UKmms:
						if( getCDRFromLine_O2UK_mms( data+line_begin , &node , &cdr ) )
							writer->emit( 0 , &node , &cdr );
						break;
					case O2UKp2p:
						if( getCDRFromLine_O2UK_p2p( data+line_begin , &node , &cdr ) )
							writer->emit( 0 , &node , &cdr );
						break;
					}

					
					line_begin = offset+1;
				}
				
				offset++;
			}
			
			if( line_begin < (length-1) )
			{
				data[length-1] = '\0';
				switch (codSource)
				{
				case TME:
					if( getCDRFromLine_TME( data+line_begin , &node , &cdr ) )
						writer->emit( 0 , &node , &cdr );
					break;
				case O2UKsmsc:
					if( getCDRFromLine_O2UK_smsc( data+line_begin , &node , &cdr ) )
						writer->emit( 0 , &node , &cdr );
					break;
				case O2UKmms:
					if( getCDRFromLine_O2UK_mms( data+line_begin , &node , &cdr ) )
						writer->emit( 0 , &node , &cdr );
					break;
				case O2UKp2p:
					if( getCDRFromLine_O2UK_p2p( data+line_begin , &node , &cdr ) )
						writer->emit( 0 , &node , &cdr );
					break;
				}
				
			}
			
		}
	};

} // end of namespace ss
} // end of namespace cdr

#endif
