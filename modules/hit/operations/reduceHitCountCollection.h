
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_hit_reduceHitCountCollection
#define _H_SAMSON_hit_reduceHitCountCollection


#include <samson/module/samson.h>
#include <samson/modules/hit/common.h> // Common definitions for the module
#include <samson/modules/hit/HitCount.h>
#include <samson/modules/hit/HitCountCollection.h>
#include <samson/modules/system/String.h>


namespace samson{
namespace hit{


   class HitCountList
   {
      // List of elements in this list
	  samson::hit::HitCount** hit_counts;

      // Position in the history to consider
	  int num_samples; 

	  // Mínimum number of samples to be part of the "top" list
	  size_t min_num_hits;

   public:	  

	  HitCountList( int _num_samples )
	  {
		 // Position in the history considered in this list
		 num_samples = _num_samples;		 

		 // Minimum number of hits "0" as there are no real elements
		 min_num_hits = 0;

		 // Alloc the list of elements
		 hit_counts = (samson::hit::HitCount**) malloc( sizeof( samson::hit::HitCount* ) * NUM_TOP_ITEMS );

		 for ( int i = 0 ; i < NUM_TOP_ITEMS ; i++ )
		 {
			hit_counts[i] = new samson::hit::HitCount();
			hit_counts[i]->init();
		 }

	  }

	  ~HitCountList()
	  {
		 free( hit_counts );
	  }


	  std::string str()
	  {
		 std::ostringstream output;
		 output << "---------------------------------------\n";
		 output << "List for #samples " << num_samples << "\n";
		 output << "---------------------------------------\n";

		 for (int i = 0 ; i < NUM_TOP_ITEMS ; i++ )
			output << "\t" << hit_counts[i]->str() << "\n";

		 return output.str();
	  }

	  void add( samson::hit::HitCount* hit_count )
	  {
		 if( hit_count->hits[num_samples].value < min_num_hits )
		 {
			//printf("Not added since not enougth hits %lu < %lu\n" , hit_count->hits[num_samples].value  , min_num_hits );
			return; // Nothing to do since we do not have the minimum number of elements
		 }


		 // Look if the elements was previously posted to just update content...
		 for ( int i = 0 ; i < NUM_TOP_ITEMS ; i++ )
			if( hit_counts[i]->concept.value == hit_count->concept.value )
			{
			   // Update content
			   hit_counts[i]->copyFrom( hit_count );

			   while( (i>0) && ( hit_counts[i]->hits[num_samples] > hit_counts[i-1]->hits[num_samples] ) )
			   {
				  // Swap positions
				  samson::hit::HitCount* tmp = hit_counts[i];
				  hit_counts[i] = hit_counts[i-1];
				  hit_counts[i-1] = tmp;

				  i--;
			   }

			   while( (i<(NUM_TOP_ITEMS-1)) && ( hit_counts[i]->hits[num_samples] < hit_counts[i+1]->hits[num_samples] ) )
			   {
				  // Swap positions
				  samson::hit::HitCount* tmp = hit_counts[i];
				  hit_counts[i] = hit_counts[i+1];
				  hit_counts[i+1] = tmp;

				  i++;
			   }

			   return;
			}

		 // Look for the final position where this element will be placed
		 int pos = 0;
		 while( (pos<NUM_TOP_ITEMS) && hit_counts[pos]->hits[num_samples] > hit_count->hits[num_samples] )
			pos++;

		 if( pos < NUM_TOP_ITEMS )
		 {
			// Reserve the last element ( will be removed )
			samson::hit::HitCount* tmp = hit_counts[NUM_TOP_ITEMS-1]; // Take the last one

			// Move all elements lower than this one...
			for ( int j = (NUM_TOP_ITEMS-1) ; j >= pos ; j-- )
			   hit_counts[j] = hit_counts[j-1];

			// Put the last "reserved" element at the correct position
			hit_counts[pos] = tmp;

			// Copy content of the new one
			hit_counts[pos]->copyFrom( hit_count );

		 }

	  }

      void fill( samson::hit::HitCountCollection *hit_count_collection )
	  {
		 for ( int i = 0 ; i < NUM_TOP_ITEMS ; i++)
			if( hit_counts[i]->hasHits() )
			   hit_count_collection->hit_countsAdd()->copyFrom( hit_counts[i] );
	  }


   };


   class HitCountListCollection
   {
	  std::vector<HitCountList*> hit_count_lists; // length NUM_TIME_SLOTS

   public:

	  HitCountListCollection( )
	  {
		 for (int i = 0; i < NUM_TIME_SLOTS ; i++ )
			hit_count_lists.push_back( new HitCountList( i ) );
	  }

	  void add( samson::hit::HitCount* hit_count )
	  {
		 for (int i = 0; i < NUM_TIME_SLOTS ; i++ )
			hit_count_lists[i]->add( hit_count );
	  }

	  void fill( samson::hit::HitCountCollection *hit_count_collection )
	  {
		 // Export data to store as state
		 hit_count_collection->hit_countsSetLength( 0 );

		 // Add data
		 for (int i = 0; i < NUM_TIME_SLOTS ; i++ )
			hit_count_lists[i]->fill( hit_count_collection );
			
	  }

	  void fill_top( samson::hit::HitCountCollection *hit_count_collection )
	  {
		 // Export data to emit as top list
		 hit_count_collection->hit_countsSetLength( 0 );

		 // Add data of the top-level list
	   	hit_count_lists[ NUM_TIME_SLOTS-1 ]->fill( hit_count_collection );
			
	  }

	  std::string str()
      { 
		 std::ostringstream output;

		 for (int i = 0; i < NUM_TIME_SLOTS ; i++ )
            output << hit_count_lists[i]->str();

         return output.str();
      }


   };


	class reduceHitCountCollection : public samson::Reduce
	{
	   samson::system::String concept;                      // Concept
	   samson::hit::HitCountCollection hitCountCollection;  // Value at input

	   samson::hit::HitCount hit_count;                     // Input hit count

	   size_t current_time; // Current time to update 

	public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

input: system.String hit.HitCount  
input: system.String hit.HitCountCollection  
output: system.String hit.HitCountCollection
output: system.String hit.HitCountCollection

helpLine: Filter top elements per global-concept
#endif // de INFO_COMMENT

		void init( samson::KVWriter *writer )
		{
		   current_time = time(NULL)/SECONDS_PER_TIME_SLOT;		
		}

		void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{

		   // Global class to keep track of the top-lists
		   HitCountListCollection collection;

/*
		   printf("*********************************************************************************\n");
		   printf("Running....\n");
		   printf("*********************************************************************************\n");
		   printf("%s\n" , collection.str().c_str() );
*/

		   if( inputs[1].num_kvs > 0 )
		   {

			  concept.parse( inputs[1].kvs[0]->key );

			  // Previous state
			  hitCountCollection.parse( inputs[1].kvs[0]->value );			  

			  // Sent all data to "collection"
		      for ( int i = 0 ; i < hitCountCollection.hit_counts_length ; i++ )
			  {
				 //printf("Loading data from state %s\n" , hitCountCollection.hit_counts[i].str().c_str() );
				 hitCountCollection.hit_counts[i].set_current_time( current_time );   // Update state information if necessary

				 collection.add( &hitCountCollection.hit_counts[i] );
			  }


		   }
		   else
		   {
			  // Just take the concept from the first key-value
			  concept.parse( inputs[0].kvs[0]->key );
		   }


		   // Process all input data
		   //printf("Processing %lu input elements" , inputs[0].num_kvs );
		   for( size_t i = 0 ; i < inputs[0].num_kvs ; i++ )
		   {
			  hit_count.parse( inputs[0].kvs[i]->value );
			  hit_count.set_current_time( current_time );   // Update to the current time ( if necessary )

			  //printf("Processing %s\n" , hit_count.str().c_str() );
			  collection.add( &hit_count );
		   }


		   // Emit the top list at channel "0"
		   collection.fill_top( &hitCountCollection );
		   writer->emit( 0 , &concept , &hitCountCollection );
		   
		   // Emit state at the output "1"
		   collection.fill( &hitCountCollection );
		   writer->emit( 1 , &concept , &hitCountCollection );

		}

		void finish( samson::KVWriter *writer )
		{
		}



	};


} // end of namespace hit
} // end of namespace samson

#endif
