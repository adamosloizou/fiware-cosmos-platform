
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_mob_reduce_compute_mobility_degree
#define _H_SAMSON_mob_reduce_compute_mobility_degree


#include <samson/module/samson.h>

#include "../cdr/cdr_environment_parameters.h"


namespace samson{
namespace mob{


class reduce_compute_mobility_degree : public samson::Reduce
{

	// Input[012345k] & Output[0k]
	samson::system::UInt phone;
	// Input[0v]
	samson::cdr::mobCdr cdr;
	// Input[1v]
	MobilityDegree md;
	// Input[2345v]
	LocCounter locCounter;
public:


#ifdef INFO_COMMENT //Just to include a comment without conflicting anything
	// If interface changes and you do not recreate this file, consider updating this information (and of course, the module file)

	input: system.UInt cdr.mobCdr
	input: system.UInt mob.MobilityDegree
	input: system.UInt mob.LocCounter
	input: system.UInt mob.LocCounter
	input: system.UInt mob.LocCounter
	input: system.UInt mob.LocCounter
	output: system.UInt mob.MobilityDegree

	helpLine: Compute all the values necessary to get the mobility degree.
	extendedHelp: 		Compute all the values necessary to get the mobility degree.

#endif // de INFO_COMMENT

	void init(samson::KVWriter *writer )
	{
	}

	/**
	 * Fill the values related to mobility degree and
	 * compute the number of national and international
	 * calls when no cell information is available in
	 * the CDR.
	 *
	 * @return Void.
	 */
	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{

		if (inputs[0].num_kvs  == 0)
		{
			return;
		}

		// parse phone number
		phone.parse( inputs[0].kvs[0]->key );

		// Mobility degree was initialized at reduce_cdrs_clients with totalCalls
		// (so we don't have to handle again all the cdrs, but only the ones with cellId == 0
		// to check the mobScope

		if (inputs[1].num_kvs  == 0)
		{
			OLM_E(("Error, we should receive only one mobility_degree per user, not %lu\n", inputs[1].num_kvs));
			return;
		}
		md.parse(inputs[1].kvs[0]->value);

		// total number of calls
		//md.totalCalls = inputs[0].num_kvs;

		md.nationalCalls = 0;
		md.internationalCalls = 0;

		// cell level
		if( inputs[2].num_kvs > 0 )
		{
			locCounter.parse( inputs[2].kvs[0]->value );
			md.cellId.value = locCounter.loc.value;
			md.cellCalls = locCounter.count;
		}
		else
		{
			md.cellId.value = 0;
			md.cellCalls = 0;
		}

		// bts level
		if( inputs[3].num_kvs > 0 )
		{
			locCounter.parse( inputs[3].kvs[0]->value );
			md.btsId.value = locCounter.loc.value;
			md.btsCalls = locCounter.count;
		}
		else
		{
			md.btsId = 0;
			md.btsCalls = 0;
		}

		// lac level
		if( inputs[4].num_kvs > 0 )
		{
			locCounter.parse( inputs[4].kvs[0]->value );
			md.lacId.value = locCounter.loc.value;
			md.lacCalls = locCounter.count;
		}
		else
		{
			md.lacId = 0;
			md.lacCalls = 0;
		}

		// state level
		if( inputs[5].num_kvs > 0 )
		{
			locCounter.parse( inputs[5].kvs[0]->value );
			md.stateId.value = locCounter.loc.value;
			md.stateCalls = locCounter.count;
		}
		else
		{
			md.stateId = 0;
			md.stateCalls = 0;
		}

		// national and international calls
		for( size_t i=0; i<inputs[0].num_kvs; i++ )
		{
			cdr.parse( inputs[0].kvs[i]->value );
			// Since optimization, reduce_add_cell_info should emit only cdrs with cellId == 0
			if( cdr.cellId.value == 0 )
			{
				if( cdr.mobScope.value >= LOC_ROAMING_INTRARREGIONAL )
				{
					if( cdr.mobScope.value <= LOC_ROAMING_NACIONAL )
					{
						md.nationalCalls.value++;
					}
					else
					{
						md.internationalCalls.value++;
					}
				}
			}
			else
			{
				OLM_E(("We should receive no cdr with cellId != 0, but we do at i:%lu\n", i));
			}
		}

		// emit
		writer->emit(0, &phone, &md );
	}

	void finish(samson::KVWriter *writer )
	{
	}



};


} // end of namespace samson
} // end of namespace mob

#endif
