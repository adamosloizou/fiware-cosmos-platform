
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_sna_filter_graph_reduce
#define _H_SAMSON_sna_filter_graph_reduce


#include <samson/module/samson.h>



namespace samson{
namespace sna{


class filter_graph_reduce : public samson::Reduce
{

public:


	void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		Node node;
		samson::system::UInt node_id;
		std::vector <size_t> removedElement;

		//OLM_T(LMT_User01, ("Starts filter_graph_reduce::run()"));

		if (inputs[0].num_kvs <= 0)
		{
			OLM_E(("Error: (inputs[0].num_kvs(%d) <= 0)", inputs[0].num_kvs));
			exit(1);
		}


		//Get the key to discover the node of study
		node_id.parse(inputs[0].kvs[0]->key);

		//Element to get all information from the keyNode
		bool found = false;

		//Vector to hold all ids to be removed
		removedElement.clear();
		int nRemoved = 0;

		Node tmp_node;
		for (size_t i = 0 ; i < inputs[0].num_kvs ; ++i)
		{
			tmp_node.parse(inputs[0].kvs[i]->value);
			if ( tmp_node.id.value == node_id.value )
			{
				if( found )
				{
					OLM_E(("MRFilterGraphReduce error when processing node %d. .It appears twice in the reduce.", node_id.value));
					return;
				}

				found = true;
				node.parse(inputs[0].kvs[i]->value); //reparse to get all information again

				if( node.links_length == 0 )
				{
					OLM_E(("Node %d has 0 links... should not happen!!! %d.", node.id.value));
					OLM_E(("Error: ( node.links_length == 0 )"));
					exit(1);
				}
			}
			else
			{
				//Kill node...
				if ( tmp_node.links_length != 0 )
				{
					OLM_E(("Error: ( tmp_node.links_length(%d) != 0 )",tmp_node.links_length));
					exit(1);
				}
				//OLM_T(LMT_User01, ("node_id:%ld detects that tmp_node.id:%ld != node_id and should remove link at nRemoved:%d", node_id.value, tmp_node.id.value, nRemoved));
				removedElement.push_back( tmp_node.id.value );
				nRemoved++;
			}
		}

		if( found )
		{
			//This node should survive if it has still some connections

			int pos = 0;
			nRemoved = 0;
			std::vector<size_t>::iterator iter = removedElement.begin();
			for (int i = 0 ; i < node.links_length ; ++i)
			{
				while ((iter < removedElement.end()) && ((*iter) < node.links[i].id.value)) {
					//OLM_T(LMT_User01, ("node_id:%ld, Checks removedElement[%d]:%ld with node.links[%d].id(%ld)", node_id.value, nRemoved, *iter, i, node.links[i].id.value));
					iter++;
					nRemoved++;
				}

				if ((iter >= removedElement.end()) || ((*iter) != node.links[i].id.value))
				{
					if( i!=pos)
						node.links[pos] = node.links[i];
					pos++;
				}
				else if ((*iter) == node.links[i].id.value)
				{
					//OLM_T(LMT_User01, ("node_id:%ld, Deletes link:%ld at i:%d", node_id.value, node.links[i].id.value, i));
				}
			}
			node.linksSetLength(pos);
			if( node.links_length > 0)
			{
				//OLM_T(LMT_User01, ("node_id:%ld, Emits node with %d links", node_id.value, node.links_length));
				writer->emit(0, &node_id, &node);
			}
		}
		else if (nRemoved > 0)
		{
			//OLM_T(LMT_User01, ("node_id:%ld, NOT found but nRemoved(%d) > 0", nRemoved));
		}
	}


};


} // end of namespace samson
} // end of namespace sna

#endif
