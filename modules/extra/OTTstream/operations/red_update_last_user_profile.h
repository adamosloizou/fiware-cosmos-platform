/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_OTTstream_red_update_last_user_profile
#define _H_SAMSON_OTTstream_red_update_last_user_profile

#include <samson/module/samson.h>
#include <samson/modules/OTTstream/ActivityByUser.h>
#include <samson/modules/OTTstream/Sequence.h>
#include <samson/modules/OTTstream/SeqComponent.h>
#include <samson/modules/OTTstream/ServiceHit.h>
#include <samson/modules/system/Int32.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/UInt.h>
#include <samson/modules/system/TimeUnix.h>
#include <samson/modules/level/ValTimed.h>

#include <time.h>

#include "logMsg/logMsg.h"

namespace samson
{
namespace OTTstream
{

class red_update_last_user_profile: public samson::Reduce
{

    samson::OTTstream::ActivityByUser activity;
    samson::system::UInt user;
    samson::OTTstream::ServiceHit hit;
    samson::system::Int32 incOne;
    samson::system::Int32 decOne;
    samson::system::Int32 zero;
    samson::level::ValTimed outVal;
    samson::system::TimeUnix oldestHit;
    samson::system::TimeUnix initial_oldestHit;
    int timespan;

    samson::system::String serviceStr;
    samson::system::UInt serviceId;
    samson::OTTstream::ServiceHit hit_filtered;

#define MAX_STR_LEN 20
    char line[MAX_STR_LEN];

    public:

    //  INFO_MODULE
    // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
    // Please, do not remove this comments, as it will be used to check consistency on module declaration
    //
    //  input: system.UInt OTTstream.ServiceHit
    //  input: system.UInt  OTTstream.ActivityByUser
    //  output: system.String level.ValTimed
    //  output: system.UInt OTTstream.ServiceHit
    //  output: system.UInt  OTTstream.ActivityByUser
    //
    // helpLine: Update the latest user profile
    //  END_INFO_MODULE

    std::string decode_serviceId(uint64_t serviceId)
    {
        if (serviceId == 10)
        {
            return "COMMS";
        }
        if (serviceId == 11)
        {
            return "Skype";
        }
        if (serviceId == 12)
        {
            return "Viber";
        }
        if (serviceId == 13)
        {
            return "GTalk";
        }
        if (serviceId == 14)
        {
            return "WhatsApp";
        }
        if (serviceId == 15)
        {
            return "faceTime";
        }
        if (serviceId == 16)
        {
            return "iphoneMessage";
        }
        if (serviceId == 17)
        {
            return "Tango";
        }
        if (serviceId == 20)
        {
            return "SOCIAL";
        }
        if (serviceId == 21)
        {
            return "Facebook";
        }
        if (serviceId == 22)
        {
            return "Tuenti";
        }
        if (serviceId == 23)
        {
            return "Google+";
        }
        if (serviceId == 100)
        {
            return "Vodafone";
        }
        if (serviceId == 101)
        {
            return "VodafoneADSL";
        }
        if (serviceId == 102)
        {
            return "VodafoneClientes";
        }
        if (serviceId == 103)
        {
            return "VodafoneOnline";
        }
        if (serviceId == 104)
        {
            return "VodafoneContacto";
        }
        if (serviceId == 105)
        {
            return "VodafoneEmpresas";
        }
        if (serviceId == 106)
        {
            return "VodafoneInternetMovil";
        }
        if (serviceId == 107)
        {
            return "VodafoneMovilFijo";
        }
        if (serviceId == 108)
        {
            return "VodafoneTV";
        }
        if (serviceId == 109)
        {
            return "VodafoneTienda";
        }
        if (serviceId == 200)
        {
            return "Orange";
        }
        if (serviceId == 201)
        {
            return "OrangeClientes";
        }
        if (serviceId == 202)
        {
            return "OrangeOnline";
        }
        if (serviceId == 203)
        {
            return "OrangeEmpresas";
        }
        if (serviceId == 204)
        {
            return "OrangeADSL";
        }
        if (serviceId == 205)
        {
            return "OrangeInfoMovil";
        }
        if (serviceId == 206)
        {
            return "OrangePortabilidad";
        }
        if (serviceId == 207)
        {
            return "OrangeTienda";
        }
        if (serviceId == 208)
        {
            return "OrangeTonos";
        }
        if (serviceId == 300)
        {
            return "Yoigo";
        }
        if (serviceId == 301)
        {
            return "YoigoClientes";
        }
        if (serviceId == 302)
        {
            return "YoigoBlogs";
        }
        if (serviceId == 303)
        {
            return "YoigoOnline";
        }
        if (serviceId == 304)
        {
            return "YoigoCobertura";
        }
        if (serviceId == 305)
        {
            return "YoigoComparadorMoviles";
        }
        if (serviceId == 306)
        {
            return "YoigoCondiciones";
        }
        if (serviceId == 307)
        {
            return "YoigoInternet";
        }
        if (serviceId == 308)
        {
            return "YoigoRecarga";
        }
        if (serviceId == 309)
        {
            return "YoigoRevista";
        }
        if (serviceId == 310)
        {
            return "YoigoServicios";
        }
        if (serviceId == 311)
        {
            return "YoigoTarifas";
        }
        if (serviceId == 312)
        {
            return "YoigoTiendasFisicas";
        }
        if (serviceId == 1000)
        {
            return "CORE";
        }
        if (serviceId == 1001)
        {
            return "voice";
        }
        if (serviceId == 1002)
        {
            return "sms";
        }
        if (serviceId == 2000)
        {
            return "SEQS";
        }
        if (serviceId == 2001)
        {
            return "seqLargaGTalk";
        }
        if (serviceId == 2002)
        {
            return "seqCortaGTalk";
        }
        if (serviceId == 2003)
        {
            return "seqWhatsApp";
        }
        {
            LM_E(("Unknown state service:%lu", serviceId));
            return "other";
        }
    }


    void init(samson::KVWriter *writer)
    {
        timespan = environment->getInt("OTTstream.timespan", 300); // Activity window length, in seconds
        //LM_M(("timespan:%d", timespan));

        //#define INITIAL_FUTURE ((time_t)0xffffffffffffffff)
        oldestHit.value = initial_oldestHit.value = time(NULL);
        //LM_M(("Initial oldestHits:%s", oldestHit.str().c_str()));

        incOne.value = 1;
        decOne.value = -1;
        zero.value = 0;

        // TODO: Initialize sequences
    }

    void run(samson::KVSetStruct* inputs, samson::KVWriter *writer)
    {
        if (inputs[1].num_kvs == 0)
        {

            user.parse(inputs[0].kvs[0]->key);

            //LM_M(("New state for userId:%lu", user.value));
            // New user state
            activity.Init();
            {
                int seqId = 2000;
                const char *seq_name = "seqLargaGTalk";
                unsigned long time_window = 3600;
                const char *events = "40,1000,40,1000";
                int strict = 0;
                activity.AddSequence(seqId, seq_name, time_window, events, strict);
            }
            {
                int seqId = 2001;
                const char *seq_name = "seqCortaGTalk";
                unsigned long time_window = 300;
                const char *events = "40,1000";
                int strict = 1;
                activity.AddSequence(seqId, seq_name, time_window, events, strict);
            }
            {
                int seqId = 2002;
                const char *seq_name = "seqWhatsApp";
                unsigned long time_window = 600;
                const char *events = "50,1000";
                int strict = 0;
                activity.AddSequence(seqId, seq_name, time_window, events, strict);
            }
            {
                int seqId = 2002;
                const char *seq_name = "seqWhatsApp";
                unsigned long time_window = 600;
                const char *events = "1000,50";
                int strict = 0;
                activity.AddSequence(seqId, seq_name, time_window, events, strict);
            }
        }
        else
        {
            user.parse(inputs[1].kvs[0]->key);
            // Previous state
            activity.parse(inputs[1].kvs[0]->value); // We only consider one state

            if (inputs[1].num_kvs > 1)
            {
                LM_W(("Multiple states(%lu) for user:%lu", inputs[1].num_kvs, user.value));
            }
        }

        //LM_M(("For user:%lu, detected:%lu hits, with oldest_timestamp:%s", user.value,  inputs[0].num_kvs, oldestHit.str().c_str()));

        if (inputs[0].num_kvs == 0)
        {
            if (oldestHit.value != initial_oldestHit.value)
            {
                for (int j = 0; (j < activity.servActivity_length); j++)
                {
                    //LM_M(("Checking old serviceId:'%s because no activity:  count:%d, userId:%lu, oldestHit:%s, prev:%s",serviceStr.value.c_str(), decOne.value, userId.value,  oldestHit.str().c_str(), activity.servActivity[j].timestamp.str().c_str()));

                    if ((oldestHit.value > (activity.servActivity[j].timestamp.value + 10*timespan)) && (activity.servActivity[j].inCount.value == 1))
                    {
                        serviceStr.value = decode_serviceId(activity.servActivity[j].serviceId.value);

                        outVal.val.value = decOne.value;
                        outVal.t.value = hit.timestamp.value;

                        writer->emit(0, &serviceStr, &outVal);
                        if (serviceStr.value == "WhatsApp")
                        {
                            LM_M(("Reset serviceId:'%s because no activity:  count:%d, userId:%lu, oldestHit:%s, prev:%s",serviceStr.value.c_str(), decOne.value, user.value, oldestHit.str().c_str(), activity.servActivity[j].timestamp.str().c_str()));
                        }
                        //LM_M(("Reset serviceId:'%s because no activity:  count:%d, userId:%lu, oldestHit:%s, prev:%s",serviceStr.value.c_str(), decOne.value, user.value,  oldestHit.str().c_str(), activity.servActivity[j].timestamp.str().c_str()));
                        activity.servActivity[j].inCount.value = 0;
                        //activity.servActivity[j].timestamp.value = oldestHit.value;
                    }
                }
            }
        }

        for (uint64_t i = 0; i < inputs[0].num_kvs; i++)
        {
            bool serviceFound = false;
            hit.parse(inputs[0].kvs[i]->value);

            if (hit.timestamp.value < oldestHit.value)
            {
                oldestHit.value = hit.timestamp.value;
                //LM_M(("Update oldestHit:%s", oldestHit.str().c_str()));
            }
            else
            {
                //LM_M(("hit timestamp:%s newer than  oldestHit:%s", hit.timestamp.str().c_str(), oldestHit.str().c_str()));
            }

            //LM_M(("Before for Check for userId:%lu hit.serviceId:%lu", user.value, hit.serviceId.value));
            for (int j = 0; (j < activity.servActivity_length); j++)
            {
                //LM_M(("Check for userId:%lu hit.serviceId:%lu activity.serviceId:%lu at pos:%d", user.value, hit.serviceId.value, activity.servActivity[j].serviceId.value, j));
                serviceStr.value = decode_serviceId(activity.servActivity[j].serviceId.value);

                //LM_M(("Same check service and time: serviceId:'%s'(%lu) at pos:%d by hit:%lu, state:%d, userId:%lu, ts:%s, prev:%s",serviceStr.value.c_str(), activity.servActivity[j].serviceId.value, j, hit.serviceId.value, activity.servActivity[j].inCount.value, user.value,  hit.timestamp.str().c_str(), activity.servActivity[j].timestamp.str().c_str()));
                if (hit.serviceId.value == activity.servActivity[j].serviceId.value)
                {
                    serviceFound = true;
                    if (hit.timestamp.value > (activity.servActivity[j].timestamp.value + timespan))
                    {
                        if (activity.servActivity[j].inCount.value == 0)
                        {
                            outVal.val.value = incOne.value;
                            outVal.t.value = hit.timestamp.value;
                            writer->emit(0, &serviceStr, &outVal);
                            if (serviceStr.value == "WhatsApp")
                            {
                                LM_M(("Emit inc serviceId:'%s' at pos:%d, count:%d, userId:%lu, ts:%s, prv:%s",serviceStr.value.c_str(), j, incOne.value, user.value, hit.timestamp.str().c_str(), activity.servActivity[j].timestamp.str().c_str()));
                            }
                            //LM_M(("Emit inc serviceId:'%s' at pos:%d, count:%d, userId:%lu, ts:%s, prv:%s",serviceStr.value.c_str(), j, incOne.value, user.value, hit.timestamp.str().c_str(), activity.servActivity[j].timestamp.str().c_str()));
                            activity.servActivity[j].inCount.value = 1;
                        }
                    }
                    if (hit.timestamp.value > activity.servActivity[j].timestamp.value)
                    {
                        activity.servActivity[j].timestamp.value = hit.timestamp.value;
                    }
                }
                else
                {
                    if ((hit.timestamp.value > (activity.servActivity[j].timestamp.value + timespan)) && (activity.servActivity[j].inCount.value == 1))
                    {
                        outVal.val.value = decOne.value;
                        outVal.t.value = hit.timestamp.value;
                        writer->emit(0, &serviceStr, &outVal);
                        if (serviceStr.value == "WhatsApp")
                        {
                            LM_M(("Emit dec serviceId:'%s'(%lu) at pos:%d by hit:%lu, count:%d, userId:%lu, ts:%s, prev:%s",serviceStr.value.c_str(), activity.servActivity[j].serviceId.value, j, hit.serviceId.value, decOne.value, user.value, hit.timestamp.str().c_str(), activity.servActivity[j].timestamp.str().c_str()));
                        }
                        //LM_M(("Emit dec serviceId:'%s'(%lu) at pos:%d by hit:%lu, count:%d, userId:%lu, ts:%s, prev:%s",serviceStr.value.c_str(), activity.servActivity[j].serviceId.value, j, hit.serviceId.value, decOne.value, user.value,  hit.timestamp.str().c_str(), activity.servActivity[j].timestamp.str().c_str()));
                        activity.servActivity[j].inCount.value = 0;
                    }
                }
                //				{
                //					writer->emit(0, &serviceStr, &zero);
                //				}
            }

            if ((serviceFound == false) && (hit.serviceId.value != 0))
            {
                //serviceStr.value = hit.serviceId.str();
                serviceStr.value = decode_serviceId(hit.serviceId.value);

                outVal.val.value = incOne.value;
                outVal.t.value = hit.timestamp.value;
                writer->emit(0, &serviceStr, &outVal);
                //LM_M(("Emit first serviceId:'%s', count:%d, userId:%lu",serviceStr.value.c_str(), incOne.value, user.value ));
                if (serviceStr.value == "WhatsApp")
                {
                    LM_M(("Emit first serviceId:'%s', count:%d, userId:%lu at %s",serviceStr.value.c_str(), incOne.value, user.value, hit.timestamp.str().c_str() ));
                }

                //LM_M(("Create serviceId:%lu, count:%d, userId:%lu, at ts:%s(%lu)",hit.serviceId.value, 1, user.value,  hit.timestamp.str().c_str(), hit.timestamp.value));
                activity.AddService(hit.serviceId, hit.timestamp, 1);
            }

            // TODO: Check sequences
            if (hit.serviceId.value != 0)
            {
                //LM_M(("Before Check sequences for userId:%lu hit.serviceId:%lu", user.value, hit.serviceId.value));

                for (int j = 0; (j < activity.sequences_length); j++)
                {
                    if (activity.sequences[j].next_event_to_fulfill.value > 0)
                    {
                        //LM_M(("Check timestamp for userId:%lu hit.serviceId:%lu activity.seqenceId:%lu at pos:%d with hit.t:%s and seq.t:%s", user.value, hit.serviceId.value, activity.sequences[j].sequenceId.value, j, hit.timestamp.str().c_str(), activity.sequences[j].events[0].timestamp.str().c_str()));
                        if ((hit.timestamp.value > static_cast<time_t>(activity.sequences[j].events[0].timestamp.value + activity.sequences[j].time_window.value)))
                        {
                            if (activity.sequences[j].cloned.value == 1)
                            {
                                //LM_M(("Erasing for userId:%lu hit.serviceId:%lu activity.sequenceId:%lu at pos:%d", user.value, hit.serviceId.value, activity.sequences[j].events[0].expected_serviceId.value, j));
                                activity.sequencesErase(j);
                                j--;
                                //LM_M(("Erase because  timestamp new sequence length for userId:%lu, length:%d, and new pos:%d", user.value, activity.sequences_length, j));
                            }
                            else
                            {
                                //LM_M(("Reset because timestamp  for userId:%lu hit.serviceId:%lu activity.sequenceId:%lu at pos:%d", user.value, hit.serviceId.value, activity.sequences[j].events[0].expected_serviceId.value, j));
                                activity.sequences[j].Reset();
                            }
                        }
                        else
                        {
                            //LM_M(("Timestamp OK for userId:%lu hit.serviceId:%lu activity.sequenceId:%lu at pos:%d", user.value, hit.serviceId.value, activity.sequences[j].events[0].expected_serviceId.value, j));
                        }
                    }
                }


                //LM_M(("Check for Clone new sequences, if needed: userId%lu hit.serviceId:%lu", user.value, hit.serviceId.value));
                for (int j = 0; (j < activity.sequences_length); j++)
                {
                    if ((activity.sequences[j].next_event_to_fulfill.value > 0) &&  (activity.sequences[j].events_length > 1))
                    {
                        //LM_M(("Check for cloning for userId:%lu hit.serviceId:%lu activity.ev[0].serviceId:%lu at pos:%d", user.value, hit.serviceId.value, activity.sequences[j].events[0].expected_serviceId.value, j));
                        if ((activity.sequences[j].clonable.value == samson::OTTstream::Sequence::CLONE_ENABLED)
                                && (activity.sequences[j].events[1].fulfilled.value == 1)
                                && (hit.serviceId.value == activity.sequences[j].events[0].expected_serviceId.value))
                        {
                            //LM_M(("Cloned and clone  disabled for userId:%lu hit.serviceId:%lu activity.ev[0].serviceId:%lu at pos:%d of %d", user.value, hit.serviceId.value, activity.sequences[j].events[0].expected_serviceId.value, j, activity.sequences_length));
                            activity.sequences[j].clonable.value = samson::OTTstream::Sequence::CLONE_DISABLED;
                            activity.AddAndCloneSequence(j);
                            //LM_M(("After cloning new sequence length for userId:%lu, length:%d", user.value, activity.sequences_length));
                        }
                    }
                }

                //LM_M(("Check for matching hits for userId:%lu with sequences_length:%d", user.value, activity.sequences_length));
                for (int j = 0; (j < activity.sequences_length); j++)
                {
                    int next_event_to_fulfill = activity.sequences[j].next_event_to_fulfill.value;
                    int last_event_fulfilled = next_event_to_fulfill - 1 ;

                    //LM_M(("Check for matching hits for userId:%lu sequence[%d] hit.serviceId:%lu with next_event_to_fulfill:%d(serviceId:%lu) of events_length:%d", user.value, j, hit.serviceId.value, next_event_to_fulfill, activity.sequences[j].events[next_event_to_fulfill].expected_serviceId.value, activity.sequences[j].events_length));

                    //LM_M(("Trying match for userId:%lu hit.serviceId:%lu activity.ev[%d].serviceId:%lu at pos:%d", user.value, hit.serviceId.value,next_event_to_fulfill, activity.sequences[j].events[next_event_to_fulfill].expected_serviceId.value, j));
                    if (hit.serviceId.value == activity.sequences[j].events[next_event_to_fulfill].expected_serviceId.value)
                    {
                        activity.sequences[j].events[next_event_to_fulfill].fulfilled.value = 1;
                        activity.sequences[j].events[next_event_to_fulfill].timestamp.value = hit.timestamp.value;
                        activity.sequences[j].next_event_to_fulfill.value++;

                        if ((activity.sequences[j].clonable.value == samson::OTTstream::Sequence::CLONE_DISABLED)  && (hit.serviceId.value != activity.sequences[j].events[0].expected_serviceId.value))
                        {
                            //LM_M(("Clone enabled  for userId:%lu hit.serviceId:%lu activity.ev[0].serviceId:%lu at pos:%d", user.value, hit.serviceId.value, activity.sequences[j].events[0].expected_serviceId.value, j));
                            activity.sequences[j].clonable.value = samson::OTTstream::Sequence::CLONE_ENABLED;
                        }

                        if (next_event_to_fulfill == (activity.sequences[j].events_length - 1))
                        {
                            serviceStr.value = activity.sequences[j].sequence_name.value;
                            outVal.val.value = incOne.value;
                            outVal.t.value = activity.sequences[j].events[next_event_to_fulfill].timestamp.value;

                            writer->emit(0, &serviceStr, &outVal);

                            hit_filtered.serviceId = activity.sequences[j].sequenceId;
                            serviceId = activity.sequences[j].sequenceId;
                            hit_filtered.timestamp = activity.sequences[j].events[next_event_to_fulfill].timestamp;

                            writer->emit(1, &user, &hit_filtered);

                            //LM_M(("Sequence completed for userId:%lu hit.serviceId:%lu activity.ev[%d].serviceId:%lu at pos:%d", user.value, hit.serviceId.value,next_event_to_fulfill, activity.sequences[j].events[next_event_to_fulfill].expected_serviceId.value, j));
                            if (activity.sequences[j].cloned.value == 1)
                            {
                                //LM_M(("Erasing for userId:%lu hit.serviceId:%lu activity.ev[%d]sequenceId:%lu at pos:%d and last_event_fulfilled=%d", user.value, hit.serviceId.value, next_event_to_fulfill, activity.sequences[j].events[next_event_to_fulfill].expected_serviceId.value, j, next_event_to_fulfill));
                                activity.sequencesErase(j);
                                j--;
                                //LM_M(("Erase because emitted new sequence length for userId:%lu, length:%d, and new pos:%d", user.value, activity.sequences_length, j));
                            }
                            else
                            {
                                //LM_M(("Reset because emitted for userId:%lu hit.serviceId:%lu activity.ev[%d].serviceId:%lu at pos:%d and last_event_fulfilled=%d", user.value, hit.serviceId.value, next_event_to_fulfill, activity.sequences[j].events[next_event_to_fulfill].expected_serviceId.value, j, next_event_to_fulfill));
                                activity.sequences[j].Reset();
                            }
                        }
                    }
                    else if ((activity.sequences[j].strict.value == 1) && ((last_event_fulfilled >= 0)  && (hit.serviceId.value != activity.sequences[j].events[last_event_fulfilled].expected_serviceId.value)))
                    {
                        if (activity.sequences[j].cloned.value == 1)
                        {
                            //LM_M(("Erasing for userId:%lu hit.serviceId:%lu activity.ev[%d]sequenceId:%lu at pos:%d and last_event_fulfilled=%d", user.value, hit.serviceId.value, last_event_fulfilled, activity.sequences[j].events[last_event_fulfilled].expected_serviceId.value, j, last_event_fulfilled));
                            activity.sequencesErase(j);
                            j--;
                            //LM_M(("Erase because strict sequence new sequence length for userId:%lu, length:%d, and new pos:%d", user.value, activity.sequences_length, j));
                        }
                        else
                        {
                            //LM_M(("Reset because strict for userId:%lu hit.serviceId:%lu activity.ev[%d].serviceId:%lu at pos:%d and last_event_fulfilled=%d", user.value, hit.serviceId.value, last_event_fulfilled, activity.sequences[j].events[last_event_fulfilled].expected_serviceId.value, j, last_event_fulfilled));
                            activity.sequences[j].Reset();
                        }
                    }
                }
            }

            if ((hit.serviceId.value != 0) && (hit.serviceId.value != 1000) && (hit.serviceId.value != 1001) && (hit.serviceId.value != 1002))
            {
                writer->emit(1, &user, &hit);
            }
        }



        if (activity.sequences_length > 2)
        {
            //LM_M(("Update userId:%lu state with %d services and %d sequences", user.value, activity.servActivity_length, activity.sequences_length));
        }
        writer->emit(2, &user, &activity);
    }

    void finish(samson::KVWriter *writer)
    {
    }

};

} // end of namespace OTTstream
} // end of namespace samson

#endif
