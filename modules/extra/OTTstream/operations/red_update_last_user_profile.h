
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_OTTstream_red_update_last_user_profile
#define _H_SAMSON_OTTstream_red_update_last_user_profile


#include <samson/module/samson.h>
#include <samson/modules/OTTstream/LastHistory.h>
#include <samson/modules/OTTstream/ServiceHit.h>
#include <samson/modules/system/Int32.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/UInt.h>
#include <samson/modules/system/TimeUnix.h>

#include <time.h>


namespace samson{
namespace OTTstream{


class red_update_last_user_profile : public samson::Reduce
{

	samson::OTTstream::Activity activity;
	samson::system::UInt userId;
	samson::OTTstream::ServiceHit hit;
	samson::system::Int32 incOne;
	samson::system::Int32 decOne;
	samson::system::TimeUnix oldestHit;
	int timespan;

	samson::system::String serviceStr;

#define MAX_STR_LEN 20
	char line[MAX_STR_LEN];

public:


	//  INFO_MODULE
	// If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
	// Please, do not remove this comments, as it will be used to check consistency on module declaration
	//
	//  input: system.UInt OTTstream.ServiceHit
	//  input: system.UInt OTTstream.Activity
	//  output: system.String system.Int32
	//  output: system.UInt OTTstream.Activity
	//
	// helpLine: Update the latest user profile
	//  END_INFO_MODULE

	void init( samson::KVWriter *writer )
	{
		timespan = environment->getInt("OTTstream.timespan", 600);                // Activity window length, in seconds

#define INITIAL_FUTURE ((time_t)0xffffffffffffffff)
		oldestHit.value = INITIAL_FUTURE;

		incOne.value = 1;
		decOne.value = -1;
	}

	void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
	{
		if ( inputs[1].num_kvs == 0 )
		{
			// New user state
			activity.init();
			userId.parse( inputs[0].kvs[0]->key );
		}
		else
		{
			// Previous state
			activity.parse( inputs[1].kvs[0]->value ); // We only consider one state
			userId.parse( inputs[1].kvs[0]->key );
			if (inputs[1].num_kvs > 1)
			{
				LM_M(("Multiple states(%lu) for user:%lu", inputs[1].num_kvs, userId.value));
			}
		}

		if (inputs[0].num_kvs == 0)
		{
			if (oldestHit.value != INITIAL_FUTURE)
			{
				for (int i= 0; (i < activity.servActivity_length); i++)
				{
					serviceStr.value = activity.servActivity[i].serviceId.str();

					//					if ((oldestHit.value > (activity.servActivity[i].timestamp.value + timespan)) && (activity.servActivity[i].inCount.value == 1))
					//					{
					//						writer->emit(0, &serviceStr, decOne);
					//						activity.servActivity[i].inCount.value = 0;
					//					}
				}
				return;
			}
		}

		for (uint64_t i = 0 ; i < inputs[0].num_kvs ; i++ )
		{
			bool serviceFound = false;
			hit.parse(inputs[0].kvs[i]->value);

			for (int i= 0; (i < activity.servActivity_length); i++)
			{

				serviceStr.value = activity.servActivity[i].serviceId.str();

				if (hit.timestamp.value < oldestHit.value)
				{
					oldestHit.value = hit.timestamp.value;
				}

				if (hit.serviceId.value == activity.servActivity[i].serviceId.value)
				{
					serviceFound = true;
					if (hit.timestamp.value > (activity.servActivity[i].timestamp.value + timespan))
					{
						if (activity.servActivity[i].inCount.value == 0)
						{
							writer->emit(0, &serviceStr, &incOne);
							activity.servActivity[i].inCount.value = 1;
						}
					}
					activity.servActivity[i].timestamp.value = hit.timestamp.value;
				}
				else
				{
					if ((hit.timestamp.value > (activity.servActivity[i].timestamp.value + timespan)) && (activity.servActivity[i].inCount.value == 1))
					{
						writer->emit(0, &serviceStr, &decOne);
						activity.servActivity[i].inCount.value = 0;
					}
				}
			}

			if (serviceFound == 0)
			{
				serviceStr.value = hit.serviceId.str();
				writer->emit(0, &serviceStr, &incOne);

				activity.addService(hit.serviceId, hit.timestamp, 1);
			}
		}
		writer->emit(1, &userId, &activity);
	}

	void finish( samson::KVWriter *writer )
	{
	}

};


} // end of namespace OTTstream
} // end of namespace samson

#endif
