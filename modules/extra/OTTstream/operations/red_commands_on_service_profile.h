
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
 */

#ifndef _H_SAMSON_OTTstream_red_commands_on_service_profile
#define _H_SAMSON_OTTstream_red_commands_on_service_profile


#include <samson/module/samson.h>
#include <samson/modules/OTTstream/ActivityByService.h>
#include <samson/modules/system/String.h>
#include <samson/modules/system/UInt.h>

#include "logMsg/logMsg.h"


namespace samson{
namespace OTTstream{


class red_commands_on_service_profile : public samson::Reduce
{

  samson::OTTstream::ActivityByService activity;
  samson::system::UInt serviceId;
  samson::system::String command;


public:


  //  INFO_MODULE
  // If interface changes and you do not recreate this file, you will have to update this information (and of course, the module file)
  // Please, do not remove this comments, as it will be used to check consistency on module declaration
  //
  //  input: system.UInt system.String
  //  input: system.UInt OTTstream.ActivityByService
  //  output: system.UInt OTTstream.UserActivity
  //
  // helpLine: Update the latest user profile
  //  END_INFO_MODULE

  void init( samson::KVWriter *writer )
  {
  }

  void run( samson::KVSetStruct* inputs , samson::KVWriter *writer )
  {
    if (inputs[0].num_kvs == 0)
    {
      // No command
      if (inputs[1].num_kvs > 0)
      {
        serviceId.parse( inputs[1].kvs[0]->key );
        LM_W(("No command to process on serviceId:%lu", serviceId.value));
      }
      else
      {
        LM_W(("No command to process"));
      }

      return;
    }

    if (inputs[1].num_kvs == 0)
    {
      // No service activity
      if (inputs[0].num_kvs > 0)
      {
        serviceId.parse( inputs[0].kvs[0]->key );
        LM_W(("No state to process command on serviceId:%lu", serviceId.value));
      }
      else
      {
        LM_W(("No state to process command"));
      }
      return;
    }

    activity.parse( inputs[1].kvs[0]->value ); // We only consider one state
    serviceId.parse( inputs[1].kvs[0]->key );

    // First, we estimate the "now" time with the newest activity
    time_t newest_time = 0;
    if (inputs[0].num_kvs > 0)
    {
      for (int j = 0; (j < activity.user_activity_length); j++)
      {
        if (activity.user_activity[j].last_timestamp.value > newest_time)
        {
          newest_time = activity.user_activity[j].last_timestamp.value;
        }
      }
    }

    LM_M(("Processing %lu commands on service:%lu, newest_time:'%s'", inputs[0].num_kvs, serviceId.value, ctime(&newest_time)));
    for (uint64_t i = 0; (i < inputs[0].num_kvs); i++)
    {
      command.parse(inputs[0].kvs[i]->value);

      LM_M(("Command:'%s' on service:%lu", command.value.c_str(), serviceId.value));

      char command_name[256];
      int time_window = 0;
      int min_count = 0;

      if (sscanf(command.value.c_str(), "%s %d %d", command_name, &time_window, &min_count) < 2)
      {
        LM_W(("Ignoring command with less than 2 fields:'%s'", command.value.c_str()));
        continue;
      }
      else
      {
        LM_M(("Detected command:'%s, with time_window:%d, min_count:%d on serviceId:%li", command_name, time_window, min_count, serviceId.value));
      }

      //LM_M(("Checking command for serviceId:%lu with %d entries", serviceId.value, activity.user_activity_length));
      for (int j = 0; (j < activity.user_activity_length); j++)
      {
        if (strcmp(command_name, "NEWER") == 0)
        {
          //LM_M(("Checking NEWER for user:%lu with timestamp:%lu, (newest_time - time_window):%lu", activity.user_activity[j].userId.value, activity.user_activity[j].last_timestamp.value, (newest_time - time_window)));
          if ((activity.user_activity[j].last_timestamp.value > (newest_time - time_window)) && (activity.user_activity[j].count.value > static_cast<unsigned long>(min_count)))
          {
            //LM_M(("Emit userId:%lu", activity.user_activity[j].userId.value));
            writer->emit(0, &serviceId, &(activity.user_activity[j]));
          }
        }
        else if (strcmp(command_name, "OLDER") == 0)
        {
          //LM_M(("Checking OLDER for user:%lu with timestamp:%lu, (newest_time - time_window):%lu", activity.user_activity[j].userId.value, activity.user_activity[j].last_timestamp.value, (newest_time - time_window)));
          if ((activity.user_activity[j].last_timestamp.value < (newest_time - time_window)) && (activity.user_activity[j].count.value > static_cast<unsigned long>(min_count)))
          {
            //LM_M(("Emit userId:%lu", activity.user_activity[j].userId.value));
            writer->emit(0, &serviceId, &(activity.user_activity[j]));
          }
        }
        else
        {
          LM_E(("Unknown command:'%s' for serviceId:%lu", command_name, serviceId.value));
          break;
        }
      }
    }
    //LM_M(("Ended processing %lu commands on service:%lu", inputs[0].num_kvs, serviceId.value));


  }

  void finish( samson::KVWriter *writer )
  {
  }



};


} // end of namespace OTTstream
} // end of namespace samson

#endif
