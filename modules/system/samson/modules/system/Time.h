
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this data
*/

#ifndef _H_SAMSON_system_Time
#define _H_SAMSON_system_Time

#include <time.h>
#include <limits.h>


namespace samson{
namespace system{


		/** 
		 Time  Data Instance 
		 */
		
		class Time : public samson::DataInstance{

			inline int tmcomp(register const struct tm * const atmp,
					  register const struct tm * const btmp)
			{
				register int	result;

				if ((result = (atmp->tm_year - btmp->tm_year)) == 0 &&
					(result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
					(result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
					(result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
					(result = (atmp->tm_min - btmp->tm_min)) == 0)
						result = atmp->tm_sec - btmp->tm_sec;
				return result;
			}

		public:
			
			time_t value;

			Time() : samson::DataInstance(){
			}

			~Time() {
			}
			
			int parse(char *data){
				return samson::staticVarIntParse( data , (size_t *)&value);
			}
			
			int serialize(char *data){
				return samson::staticVarIntSerialize( data , value);
			}
			
			int hash(int max_num_partitions){
				return value%max_num_partitions;
			}
			
	
			static int size(char *data){
				time_t _value;
				return samson::staticVarIntParse( data , (size_t *)&_value);
			}

			int toInt()
			{
				return (value);
			}
	
			inline static int compare(char * data1 , char *data2 , size_t *offset1 , size_t *offset2 ){
				{ // comparing b
					size_t _value1;
					size_t _value2;
					*offset1 += samson::staticVarIntParse(data1 + (*offset1), &_value1);
					*offset2 += samson::staticVarIntParse(data2 + (*offset2), &_value2);
					if( _value1 < _value2 ) return -1;
					if( _value1 > _value2 ) return  1;
					return 0;
				}
				return 0; //If everything is equal
			}
			
			inline static int compare( char* data1 , char* data2 )
			{
				size_t offset_1=0;
				size_t offset_2=0;
				return compare( data1 , data2 , &offset_1 , &offset_2 );
			}
			
			static int *getDataPath(const std::string &dataPathString){
				const char *dataPathCharP = dataPathString.c_str();
				int nlevels = 1;
				int *dataPathIntP;

				const char *p_sep = dataPathCharP;
				while ((p_sep = strchr(p_sep, '.')) != NULL)
				{
					nlevels++;
					p_sep++;
				}

				if ((dataPathIntP = (int *)malloc((nlevels + 1)*sizeof(int))) == NULL)
				{
					return ((int *)NULL);
				}

				int retError = getDataPath(dataPathCharP, dataPathIntP);

				if (retError)
				{
					free(dataPathIntP);
					dataPathIntP = NULL;
				}

				return  (dataPathIntP);
			}

			static int getDataPath(const char * dataPathCharP, int *dataPathIntP){
				if (strcmp(dataPathCharP, "Time") == 0)
				{
					*dataPathIntP = -1;
					return (0);
				}

				if (strncmp(dataPathCharP, "Time.value", strlen("Time.value")) != 0)
				{
					*dataPathIntP = 0;
					*(dataPathIntP+1) = -1;
					return (0);
				}
				return -1;
			}
			static std::string getType(const int *dataPathIntP){
				switch(*dataPathIntP)
				{
					case -1:
						return ("Time");
						break;
					case 0:
						if ((*dataPathIntP+1) == -1)
						{
							return ("time_t");
						}
						else
						{
							return ("_Unkwown_");
						}
						break;
					default:
						return ("_Unknown_");
						break;
				};
			}

			DataInstance * getInstance(const int *dataPathIntP){
				switch(*dataPathIntP)
				{
					case -1:
						return (this);
						break;
					case 0:
						if ((*dataPathIntP+1) == -1)
						{
							return ((DataInstance *)&value);
						}
						else
						{
							return (NULL);
						}
					default:
						return (NULL);
						break;
				};
			}


			void copyFrom( Time *other ){
				value = other->value;
			};
			
			std::string str(){
				std::ostringstream o;
				o << value;
				return o.str();
			}
			/*
			void operator= (int _value) {
				value = _value;
			}			
			*/
			
			// Comparation with size_t
			
			void operator= (time_t _value) {
				value = _value;
			}			
			
			bool operator< (time_t _value) {
				return ( value < _value);
			}			
			
			bool operator> (time_t _value) {
				return ( value > _value);
			}			

			bool operator<= (time_t _value) {
				return ( value <= _value);
			}			
			
			bool operator>= (time_t _value) {
				return ( value >= _value);
			}			
			
			bool operator== (time_t _value) {
				return ( value == _value);
			}			

			bool operator!= (time_t _value) {
				return ( value != _value);
			}
			
			Time& operator+=(time_t _value) {
				value+=_value;
				return *this;
			}			
			
			Time& operator-=(time_t _value) {
				value-=_value;
				return *this;
			}			
			
			
			// Self comparison
			
			Time& operator+=(const Time &o) {
				value+=o.value;
				return *this;
			}			
			
			Time& operator=(const Time &o) {
				value=o.value;
				return *this;
			}			

			bool operator== (Time& o) {
				return ( value == o.value);
			}			
			
			bool operator!= (Time& o) {
				return ( value != o.value);
			}

			bool operator< (Time& o) {
				return ( value < o.value);
			}

			bool operator> (Time& o) {
				return ( value > o.value);
			}

			bool operator<= (Time& o) {
				return ( value <= o.value);
			}

			bool operator>= (Time& o) {
				return ( value >= o.value);
			}

			void getTimeFromCalendar (struct tm *tm)
			{
				value = mktime(tm);
			}

			struct tm *getCalendarFromTime (struct tm *result)
			{
				return (localtime_r(&value, result));
			}




			void getTimeUTCFromCalendar_shiftandcompare(struct tm *tm)
			{

				// Copied from utc_mktime
				// Idea of Bob Kridle (so its said...).
				// http://www.koders.com/c/fidB1A0A680FBCF84DDC534E66371053D726A5546EB.aspx?s=md5
				// Very cool, but not so efficient for 64 bits long time_t

				register int			dir;
				register int			bits;
				register int			saved_seconds;
				time_t				t;
				struct tm			yourtm, mytm;

				yourtm = *tm;
				saved_seconds = yourtm.tm_sec;
				yourtm.tm_sec = 0;
				/*
				** Calculate the number of magnitude bits in a time_t
				** (this works regardless of whether time_t is
				** signed or unsigned, though lint complains if unsigned).
				**
				** We check TIME_T_MAX_BITS beforehand since gmtime() may fail
				** with large 64bit values in some systems.
				*/
#define TIME_T_MAX_BITS 64
				for (bits = 0, t = 1; t > 0 && bits < TIME_T_MAX_BITS-1; bits++)
					t <<= 1;

				/*
				** If time_t is signed, then 0 is the median value,
				** if time_t is unsigned, then 1 << bits is median.
				*/
				t = (t < 0) ? 0 : ((time_t) 1 << bits);
				for ( ; ; ) {
					gmtime_r(&t, &mytm);
					dir = tmcomp(&mytm, &yourtm);
					if (dir != 0) {
						if (bits-- < 0)
						{
							value = (time_t) -1;
							return;
						}
						if (bits < 0)
							--t;
						else if (dir > 0)
							t -= (time_t) 1 << bits;
						else	t += (time_t) 1 << bits;
						continue;
					}
					break;
				}
				t += saved_seconds;
				value = t;
			}


#define  YEAR0   1900
#define  EPOCH_YR   1970
#define  SECS_DAY   (24L * 60L * 60L)
#define  LEAPYEAR(year)   (!((year) % 4) && (((year) % 100) || !((year) % 400)))
#define  YEARSIZE(year)   (LEAPYEAR(year) ? 366 : 365)
#define  FIRSTSUNDAY(timp)   (((timp)->tm_yday - (timp)->tm_wday + 420) % 7)
#define  FIRSTDAYOF(timp)   (((timp)->tm_wday - (timp)->tm_yday + 420) % 7)
#define  TIME_MAX   ULONG_MAX
#define  ABB_LEN   3

			void getTimeUTCFromCalendar(struct tm *tm)
			{
				register long day = 0;
				register long year = EPOCH_YR;
				register int tm_year;
				int yday, month;
				register unsigned long seconds = 0;
				int overflow = 0;
				//unsigned dst;

				/* Assume that when day becomes negative, there will certainly
				 * be overflow on seconds.
				 * The check for overflow needs not to be done for leapyears
				 * divisible by 400.
				 * The code only works when year (1970) is not a leapyear.
				 */

				tm_year = tm->tm_year + YEAR0;

				//if (LONG_MAX / 365 < tm_year - year)
				//	overflow++;
				day = (tm_year - year) * 365;
//				if (LONG_MAX - day < (tm_year - year) / 4 + 1)
//					overflow++;
				day += (tm_year - year) / 4 + ((tm_year % 4) && tm_year % 4 < year % 4);
				day -= (tm_year - year) / 100 + ((tm_year % 100) && tm_year % 100 < year % 100);
				day += (tm_year - year) / 400 + ((tm_year % 400) && tm_year % 400 < year % 400);

				yday = month = 0;
				switch (tm->tm_mon)
				{
				case 0:
					break;
				case 1:
					yday += 31;
					break;
				case 2:
					yday += 59 + LEAPYEAR(tm_year);
					break;
				case 3:
					yday += 90 + LEAPYEAR(tm_year);
					break;
				case 4:
					yday += 120 + LEAPYEAR(tm_year);
					break;
				case 5:
					yday += 151 + LEAPYEAR(tm_year);
					break;
				case 6:
					yday += 181 + LEAPYEAR(tm_year);
					break;
				case 7:
					yday += 212 + LEAPYEAR(tm_year);
					break;
				case 8:
					yday += 243 + LEAPYEAR(tm_year);
					break;
				case 9:
					yday += 273 + LEAPYEAR(tm_year);
					break;
				case 10:
					yday += 304 + LEAPYEAR(tm_year);
					break;
				case 11:
					yday += 334 + LEAPYEAR(tm_year);
					break;
				}

				yday += (tm->tm_mday - 1);
//				if (day + yday < 0)
//					overflow++;
				day += yday;

				tm->tm_yday = yday;
				tm->tm_wday = (day + 4)%7; /* day 0 was thursday (4) */

				seconds = ((tm->tm_hour * 60L) + tm->tm_min) * 60L + tm->tm_sec;

//				if ((TIME_MAX - seconds) / SECS_DAY < day)
//					overflow++;
				seconds += day * SECS_DAY;

				/* Now adjust according to timezone and daylight saving time */

				/* Not for us */
				/***********************************************************

				if (((_timezone > 0) && (TIME_MAX - _timezone < seconds))
						|| ((_timezone < 0) && (seconds < -_timezone)))
					overflow++;
				seconds += _timezone;

				if (tm->tm_isdst < 0)
					dst = _dstget(tm);
				else if (tm->tm_isdst)
					dst = _dst_off;
				else
					dst = 0;

				if (dst > seconds)
					overflow++; // dst is always non-negative
				seconds -= dst;

				/************************************************************/

				/***********************************************************

				if (overflow)
				{
					value = (time_t) -1;
					return;
				}
				/************************************************************/


				if ((time_t) seconds != seconds)
				{
					value = (time_t) -1;
				}
				else
				{
					value = (time_t) seconds;
				}
			}


			struct tm *getCalendarFromTimeUTC (struct tm *result)
			{
				return (gmtime_r(&value, result));
			}

			
			
		}; 	
	

} // end of namespace samson
} // end of namespace system

#endif
