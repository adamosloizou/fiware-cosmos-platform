
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this data
 */

#ifndef _H_SAMSON_system_Date
#define _H_SAMSON_system_Date


#include <samson/modules/system/Date_base.h>
#include <iostream>
#include <iomanip>


namespace samson{
namespace system{


class Date : public Date_base
{
public:
	bool operator== (Date& date) {

		if( day.value	!= date.day.value)		return false;
		if( month.value	!= date.month.value)	return false;
		if( year.value	!= date.year.value)		return false;

		return true;
	}
	bool operator!= (Date& date) {

		if( day.value	!= date.day.value)		return true;
		if( month.value	!= date.month.value)	return true;
		if( year.value	!= date.year.value)		return true;

		return false;
	}

	std::string str(){
		std::ostringstream o;
		o << std::setw(2) << std::setfill('0') << (int) day.value;
		o << "/";
		o << std::setw(2) << std::setfill('0') << (int) month.value;
		o << "/";
		o << std::setw(2) << std::setfill('0') << (int) (2000 + year.value);
		if (week_day_GetAssigned())
		{
			o << "(" << (int)week_day.value << ")";
		}
		return o.str();
	}


	// week_day from 0 to 6, starting on Sunday
	// same as in TimeUnix, tm_wday starts on Sunday
	// 0 -> Sunday
	// 1 -> Monday
	// 2 -> Tuesday
	// 3 -> Wednesday
	// 4 -> Thursday
	// 5 -> Friday
	// 6 -> Saturday

	void compute_day_of_the_week()
	{
		tm tm_original;

		tm_original.tm_hour = 12;
		tm_original.tm_min = 0;
		tm_original.tm_sec = 0;

		tm_original.tm_mday = day.value;
		tm_original.tm_mon = month.value - 1;	// Range 0-11

		if( year.value < 64 )
			tm_original.tm_year = 2000 + year.value - 1900;
		else
			tm_original.tm_year = 1900 + year.value - 1900;

		time_t t = mktime(&tm_original);

		tm result;
		gmtime_r(&t, &result);


		week_day.value = result.tm_wday;

		week_day_SetAssigned(true);
	}


	int daysFrom2000_01_01()
	{
		/* As a side effect, computes and stores the days_2000 and week_day fields */

		if (days_2000_GetAssigned())
		{
			return days_2000.value;
		}
		int duration_days = int(day.value);
		int offsetBisiesto = 0;

#ifdef CALCULO_EXACTO
		if ((year.value%4 == 0) && ((year.value%100 != 0) || (year.value%400 == 0)))
#else
			// OK if we start from 2000 year, and expect to last no more than one 99 years
			if (year.value%4 == 0)
#endif // de CALCULO_EXACTO
			{
				offsetBisiesto = 1;
			}

		switch (month.value)
		{
		case 1:
			break;
		case 2:
			duration_days += 31;
			break;
		case 3:
			duration_days += 59 + offsetBisiesto;
			break;
		case 4:
			duration_days += 90 + offsetBisiesto;
			break;
		case 5:
			duration_days += 120 + offsetBisiesto;
			break;
		case 6:
			duration_days += 151 + offsetBisiesto;
			break;
		case 7:
			duration_days += 181 + offsetBisiesto;
			break;
		case 8:
			duration_days += 212 + offsetBisiesto;
			break;
		case 9:
			duration_days += 243 + offsetBisiesto;
			break;
		case 10:
			duration_days += 273 + offsetBisiesto;
			break;
		case 11:
			duration_days += 304 + offsetBisiesto;
			break;
		case 12:
			duration_days += 334 + offsetBisiesto;
			break;
		}
		const int YEAR_2000 = 2000;
		const int DAYS_PER_YEAR = 365;
		const int SECS_PER_DAY = 86400;

		duration_days += DAYS_PER_YEAR * (year.value) + ((year.value - 1) / 4) + 1;
		duration_days--; // In order to not include the present day

		days_2000.value = duration_days;

		days_2000_SetAssigned(true);

		if (week_day_GetAssigned() == false)
		{

			const int DAYS_PER_WEEK = 7;
			const int DAYWEEK_20000101 = 6; // The 01-01-2000 was Saturday; we take Sunday as 0

			week_day.value = (duration_days + DAYWEEK_20000101)%DAYS_PER_WEEK;

			week_day_SetAssigned(true);
		}

		return duration_days;
	}

	/**
	 * Get the number of days of a month.
	 *
	 */
	unsigned int GetMonthDays()
	{
		unsigned int _month = month.value;
		unsigned int _year = year.value + 2000;
		unsigned int _monthDays = 0;



		if( _month == 1 || _month == 3 || _month == 5 || _month == 7 || _month == 8 || _month == 10 || _month == 12)
		{
			_monthDays = 31;
		}
		else if( _month == 2 )
		{
			// Check for leap year
			if( (_year % 4) == 0 )
			{
				// If date is divisible by 400, it's a leap year.
				// Otherwise, if it's divisible by 100 it's not.
				if( (_year % 400) == 0 )
				{
					_monthDays = 29;
				}
				else if( (_year % 100) == 0 )
				{
					_monthDays = 28;
				}
				else
				{
					// Divisible by 4 but not by 100 or 400
					// so it leaps
					_monthDays = 29;
				}
			}
			else
			{
				// Not a leap year
				_monthDays = 28;
			}
		}
		else
		{
			_monthDays = 30;
		}

		return _monthDays;
	}


};


} // end of namespace samson
} // end of namespace system

#endif
