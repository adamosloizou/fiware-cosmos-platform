
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_graph_filter_graph_map
#define _H_SAMSON_graph_filter_graph_map

#include <samson/module/samson.h>
#include <samson/modules/system/UInt.h>
#include "samson/modules/graph/Node.h"
#include <assert.h>

namespace samson{
namespace graph{


	class filter_graph_map : public samson::Map
	{

		samson::system::UInt killNode_id;
		samson::graph::Node killNode;
		
		//Inputs
		samson::system::UInt  node_id;
		samson::graph::Node node;
		
	public:

		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
			int max_strong_connections	= environment->getInt( "graph.max_strong_connections" ,  50 );
			int max_connections			= environment->getInt( "graph.max_connections" ,  400 );
			
			killNode.linksSetLength(0);	//A node with no links will be identified as a mark to be removed
			
			for (size_t i = 0 ; i < inputs[0].num_kvs ; i++)
			{
				//Parsing key and value
				node_id.parse( inputs[0].kvs[i]->key );
				node.parse( inputs[0].kvs[i]->value );
				
				
				assert( node_id.value == node.id.value );	//Graph correctly formed
				assert( node_id.value > 0 );
				
				if (
					(  node.numberOfLinksWithWeightEqualOrHigher( 1.0 ) > max_strong_connections ) ||
					(  node.numberOfLinksWithWeightEqualOrHigher( 0.0 ) > max_connections )
					)
				{
					//Emit kill messages to be removed in all the contrpart nodes in the reduce fase
					
					killNode.id = node_id.value ;	
					for (int j = 0 ; j < node.links_length ; j++)
					{
						killNode_id.value = node.links[j].id.value;		//This is the target node to be removed in
						writer->emit( 0 , &killNode_id, &killNode );
					}
				}
				else
				{
					//Simply by pass the map to the reduce
					writer->emit(0,&node_id, &node);
				}
			}			
		}


	};


} // end of namespace samson
} // end of namespace graph

#endif
