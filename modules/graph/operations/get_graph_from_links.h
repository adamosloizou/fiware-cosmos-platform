
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_sna_get_graph_from_links
#define _H_SAMSON_sna_get_graph_from_links


#include <samson/module/samson.h>
#include <samson/modules/system/UInt.h>
#include "samson/modules/graph/Node.h"
#include "samson/modules/graph/Link.h"
#include <iostream>

namespace samson{
namespace graph{


	class get_graph_from_links : public samson::Reduce
	{

				
	public:

		void run(  samson::KVSetStruct* inputs , samson::KVWriter *writer )
		{
		   samson::system::UInt node_id;			// Id of the node ( emitted as key at the output )
		   samson::graph::Node node;				// Node we are emiting at the output

			if (inputs[0].num_kvs == 0)
				return;

			// Get the key from the first element
			node.id.parse( inputs[0].kvs[0]->key );	
			node_id.value = node.id.value;

			node.linksSetLength( inputs[0].num_kvs );
			for ( size_t i = 0 ; i < inputs[0].num_kvs ; i++)
			{
			   samson::graph::Link l;
			   l.parse( inputs[0].kvs[i]->value );
			   node.links[i].copyFrom( &l );
			}
			if ((node.links_length == 1) && (node_id.value == node.links[0].id.value))
			{
				//With this structure, from links we are only able to build nodes with outgoing links.
				//We use an outgoing link to itself to represent a sink node.
				//To complete the dirty trick, we set the number of links to 0
				node.links_length = 0;
			}
			
			//By default all nodes belong to Telefonica
			node.flags = 0;					// No flag activated
			node.flags.value &= ~GRAPH_FLAG_EXTERN;		// Unset the extern flag ( no really necessary since we have all flags unset by default )
			
			//Emit the complete node information
			writer->emit( 0, &node_id, &node);			

		}


	};


} // end of namespace samson
} // end of namespace graph

#endif
