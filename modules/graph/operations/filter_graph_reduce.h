
/**
 File autogenerated with samsonModuleParser. Please, edit to complete this operation
*/

#ifndef _H_SAMSON_graph_filter_graph_reduce
#define _H_SAMSON_graph_filter_graph_reduce


#include <samson/Operation.h>
#include <samson/modules/system/UInt.h>
#include <vector>

namespace ss{
namespace graph{


	class filter_graph_reduce : public ss::Reduce
	{

		ss::system::UInt node_id;
		ss::graph::Node node;
		std::vector<size_t>removedElement;
		
	public:

		void run(  ss::KVSetStruct* inputs , ss::KVWriter *writer )
		{
			assert( inputs[0].num_kvs > 0 );
			
			//Get the key to discover the node of study	
			node_id.parse(inputs[0].kvs[0]->key);	
			
			//Element to get all information from the keyNode
			bool found = false;
			
			//Vector to hold all ids to be removed
			removedElement.clear();
			
			ss::graph::Node tmp_node;
			for (size_t i = 0 ; i < inputs[0].num_kvs ; i++)
			{
				tmp_node.parse(inputs[0].kvs[i]->value);
				
				if ( tmp_node.id == node_id.value )
				{
					if( found )
					{
						/*
						std::ostringstream o;
						o << "MRFilterGraphReduce error when processing node " << node_id.value << " .It appears twice in the reduce.";
						setErrorMessage( o.str() );
						return;
						 */
						assert(false);
					}
					
					found = true;
					node.parse(inputs[0].kvs[i]->value);	//reparse to get all information again
					assert( node.links_length > 0 );
				}
				else
				{
					//Kill node...
					assert( tmp_node.links_length == 0 );
					removedElement.push_back( tmp_node.id.value );
				}
			}
			
			if( found )
			{
				//This node should survive if it has still some connections
				
				int pos = 0;
				std::vector<size_t>::iterator iter = removedElement.begin();
				for (int i = 0 ; i < node.links_length ; i++)
				{
					while ( (iter < removedElement.end()) && ((*iter) < node.links[i].id.value ) ) {
						iter++;
					}
					
					if( ( iter >= removedElement.end() ) || ( (*iter) != node.links[i].id.value) )
					{
						if( i!=pos)
							node.links[pos] = node.links[i];
						pos++;
					}			
				}
				node.linksSetLength(pos);
				if( node.links_length > 0)
					writer->emit(0,&node_id, &node);
			}
			
		}


	};


} // end of namespace ss
} // end of namespace graph

#endif
